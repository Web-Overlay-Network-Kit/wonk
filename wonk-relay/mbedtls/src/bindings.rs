/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
	storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
	#[inline]
	pub const fn new(storage: Storage) -> Self {
		Self { storage }
	}
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
	Storage: AsRef<[u8]> + AsMut<[u8]>,
{
	#[inline]
	pub fn get_bit(&self, index: usize) -> bool {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = self.storage.as_ref()[byte_index];
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		byte & mask == mask
	}
	#[inline]
	pub fn set_bit(&mut self, index: usize, val: bool) {
		debug_assert!(index / 8 < self.storage.as_ref().len());
		let byte_index = index / 8;
		let byte = &mut self.storage.as_mut()[byte_index];
		let bit_index = if cfg!(target_endian = "big") {
			7 - (index % 8)
		} else {
			index % 8
		};
		let mask = 1 << bit_index;
		if val {
			*byte |= mask;
		} else {
			*byte &= !mask;
		}
	}
	#[inline]
	pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		let mut val = 0;
		for i in 0..(bit_width as usize) {
			if self.get_bit(i + bit_offset) {
				let index = if cfg!(target_endian = "big") {
					bit_width as usize - 1 - i
				} else {
					i
				};
				val |= 1 << index;
			}
		}
		val
	}
	#[inline]
	pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
		debug_assert!(bit_width <= 64);
		debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
		debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
		for i in 0..(bit_width as usize) {
			let mask = 1 << i;
			let val_bit_is_set = val & mask == mask;
			let index = if cfg!(target_endian = "big") {
				bit_width as usize - 1 - i
			} else {
				i
			};
			self.set_bit(index + bit_offset, val_bit_is_set);
		}
	}
}
pub const MBEDTLS_VERSION_MAJOR: u32 = 3;
pub const MBEDTLS_VERSION_MINOR: u32 = 4;
pub const MBEDTLS_VERSION_PATCH: u32 = 1;
pub const MBEDTLS_VERSION_NUMBER: u32 = 50594048;
pub const MBEDTLS_VERSION_STRING: &[u8; 6] = b"3.4.1\0";
pub const MBEDTLS_VERSION_STRING_FULL: &[u8; 15] = b"mbed TLS 3.4.1\0";
pub const MBEDTLS_SSL_DTLS_CONNECTION_ID_COMPAT: u32 = 0;
pub const MBEDTLS_SSL_MAX_EARLY_DATA_SIZE: u32 = 1024;
pub const MBEDTLS_RSA_GEN_KEY_MIN_BITS: u32 = 1024;
pub const MBEDTLS_SSL_TLS1_3_TICKET_AGE_TOLERANCE: u32 = 6000;
pub const MBEDTLS_SSL_TLS1_3_TICKET_NONCE_LENGTH: u32 = 32;
pub const MBEDTLS_SSL_TLS1_3_DEFAULT_NEW_SESSION_TICKETS: u32 = 1;
pub const PSA_WANT_ALG_MD5: u32 = 1;
pub const PSA_WANT_ALG_RIPEMD160: u32 = 1;
pub const PSA_WANT_ALG_SHA_1: u32 = 1;
pub const PSA_WANT_ALG_SHA_224: u32 = 1;
pub const PSA_WANT_ALG_SHA_256: u32 = 1;
pub const PSA_WANT_ALG_SHA_384: u32 = 1;
pub const PSA_WANT_ALG_SHA_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const PSA_WANT_ALG_CCM: u32 = 1;
pub const PSA_WANT_ALG_CCM_STAR_NO_TAG: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CMAC: u32 = 1;
pub const PSA_WANT_ALG_CMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDH: u32 = 1;
pub const PSA_WANT_ALG_ECDH: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_ECDSA_ANY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const PSA_WANT_ALG_DETERMINISTIC_ECDSA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_IMPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_EXPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_GENERATE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_DERIVE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_BASIC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_IMPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_EXPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_GENERATE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_KEY_PAIR_DERIVE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ECC_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DH_KEY_PAIR_BASIC: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DH_KEY_PAIR_IMPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DH_KEY_PAIR_EXPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DH_KEY_PAIR_GENERATE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DH_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_ALG_FFDH: u32 = 1;
pub const PSA_WANT_DH_FAMILY_RFC7919: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_FFDH: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_BASIC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_IMPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_EXPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_KEY_PAIR_GENERATE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DH_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_GCM: u32 = 1;
pub const PSA_WANT_ALG_GCM: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HMAC: u32 = 1;
pub const PSA_WANT_ALG_HMAC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF: u32 = 1;
pub const PSA_WANT_ALG_HKDF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXTRACT: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXTRACT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_HKDF_EXPAND: u32 = 1;
pub const PSA_WANT_ALG_HKDF_EXPAND: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PRF: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PRF: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_PSK_TO_MS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_MD5: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_PAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_JPAKE: u32 = 1;
pub const PSA_WANT_ALG_JPAKE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RIPEMD160: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_CRYPT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN: u32 = 1;
pub const PSA_WANT_ALG_RSA_PKCS1V15_SIGN_RAW: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_OAEP: u32 = 1;
pub const PSA_WANT_ALG_RSA_OAEP: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_RSA_PSS: u32 = 1;
pub const PSA_WANT_ALG_RSA_PSS: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_GENERATE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_GENERATE: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_BASIC: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_IMPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_KEY_PAIR_EXPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_IMPORT: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_EXPORT: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RSA_PUBLIC_KEY: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_1: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_SHA_512: u32 = 1;
pub const PSA_WANT_KEY_TYPE_AES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_AES: u32 = 1;
pub const PSA_WANT_KEY_TYPE_ARIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_ARIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CAMELLIA: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CAMELLIA: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_DES: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_ALG_TLS12_ECJPAKE_TO_PMS: u32 = 1;
pub const PSA_WANT_KEY_TYPE_CHACHA20: u32 = 1;
pub const PSA_WANT_ALG_STREAM_CIPHER: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_KEY_TYPE_CHACHA20: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_STREAM_CIPHER: u32 = 1;
pub const PSA_WANT_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CHACHA20_POLY1305: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_CBC_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CBC_PKCS7: u32 = 1;
pub const PSA_WANT_ALG_CBC_PKCS7: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_ECB_NO_PADDING: u32 = 1;
pub const PSA_WANT_ALG_ECB_NO_PADDING: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CFB: u32 = 1;
pub const PSA_WANT_ALG_CFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_CTR: u32 = 1;
pub const PSA_WANT_ALG_CTR: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ALG_OFB: u32 = 1;
pub const PSA_WANT_ALG_OFB: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_BRAINPOOL_P_R1_512: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_255: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_MONTGOMERY_448: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_224: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_256: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_384: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_R1_521: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_192: u32 = 1;
pub const MBEDTLS_PSA_BUILTIN_ECC_SECP_K1_256: u32 = 1;
pub const PSA_WANT_ALG_SOME_PAKE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_DERIVE: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD: u32 = 1;
pub const PSA_WANT_KEY_TYPE_PASSWORD_HASH: u32 = 1;
pub const PSA_WANT_KEY_TYPE_RAW_DATA: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const __WORDSIZE: u32 = 64;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 130300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const MBEDTLS_ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const MBEDTLS_ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const MBEDTLS_ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const MBEDTLS_MD_MAX_SIZE: u32 = 64;
pub const MBEDTLS_MD_MAX_BLOCK_SIZE: u32 = 144;
pub const MBEDTLS_ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const PSA_CRYPTO_API_VERSION_MAJOR: u32 = 1;
pub const PSA_CRYPTO_API_VERSION_MINOR: u32 = 0;
pub const PSA_MAC_TRUNCATION_OFFSET: u32 = 16;
pub const PSA_AEAD_TAG_LENGTH_OFFSET: u32 = 16;
pub const PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED: u32 = 4294967295;
pub const PSA_HASH_MAX_SIZE: u32 = 64;
pub const PSA_HMAC_MAX_HASH_BLOCK_SIZE: u32 = 128;
pub const PSA_MAC_MAX_SIZE: u32 = 64;
pub const PSA_AEAD_TAG_MAX_SIZE: u32 = 16;
pub const PSA_VENDOR_RSA_MAX_KEY_BITS: u32 = 4096;
pub const PSA_VENDOR_RSA_GENERATE_MIN_KEY_BITS: u32 = 1024;
pub const PSA_VENDOR_FFDH_MAX_KEY_BITS: u32 = 8192;
pub const PSA_VENDOR_ECC_MAX_CURVE_BITS: u32 = 521;
pub const PSA_TLS12_PSK_TO_MS_PSK_MAX_SIZE: u32 = 128;
pub const PSA_TLS12_ECJPAKE_TO_PMS_INPUT_SIZE: u32 = 65;
pub const PSA_TLS12_ECJPAKE_TO_PMS_DATA_SIZE: u32 = 32;
pub const PSA_VENDOR_PBKDF2_MAX_ITERATIONS: u32 = 4294967295;
pub const PSA_BLOCK_CIPHER_BLOCK_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_NONCE_MAX_SIZE: u32 = 13;
pub const PSA_AEAD_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE: u32 = 16;
pub const PSA_SIGNATURE_MAX_SIZE: u32 = 1;
pub const PSA_EXPORT_KEY_PAIR_MAX_SIZE: u32 = 1;
pub const PSA_EXPORT_PUBLIC_KEY_MAX_SIZE: u32 = 1;
pub const PSA_RAW_KEY_AGREEMENT_OUTPUT_MAX_SIZE: u32 = 1;
pub const PSA_CIPHER_IV_MAX_SIZE: u32 = 16;
pub const PSA_CIPHER_FINISH_OUTPUT_MAX_SIZE: u32 = 16;
pub const MBEDTLS_ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const MBEDTLS_ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const MBEDTLS_ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const MBEDTLS_ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const MBEDTLS_ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const MBEDTLS_ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const MBEDTLS_CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const MBEDTLS_CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MBEDTLS_MAX_IV_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_BLOCK_LENGTH: u32 = 16;
pub const MBEDTLS_MAX_KEY_LENGTH: u32 = 64;
pub const MBEDTLS_KEY_BITLEN_SHIFT: u32 = 6;
pub const MBEDTLS_IV_SIZE_SHIFT: u32 = 2;
pub const MBEDTLS_PSA_BUILTIN_CIPHER: u32 = 1;
pub const MBEDTLS_AES_BLOCK_SIZE: u32 = 16;
pub const MBEDTLS_DES3_BLOCK_SIZE: u32 = 8;
pub const MBEDTLS_CIPHER_BLKSIZE_MAX: u32 = 16;
pub const MBEDTLS_GCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_GCM_DECRYPT: u32 = 0;
pub const MBEDTLS_ERR_GCM_AUTH_FAILED: i32 = -18;
pub const MBEDTLS_ERR_GCM_BAD_INPUT: i32 = -20;
pub const MBEDTLS_ERR_GCM_BUFFER_TOO_SMALL: i32 = -22;
pub const MBEDTLS_CCM_DECRYPT: u32 = 0;
pub const MBEDTLS_CCM_ENCRYPT: u32 = 1;
pub const MBEDTLS_CCM_STAR_DECRYPT: u32 = 2;
pub const MBEDTLS_CCM_STAR_ENCRYPT: u32 = 3;
pub const MBEDTLS_ERR_CCM_BAD_INPUT: i32 = -13;
pub const MBEDTLS_ERR_CCM_AUTH_FAILED: i32 = -15;
pub const MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const MBEDTLS_ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const MBEDTLS_PSA_BUILTIN_AEAD: u32 = 1;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const MBEDTLS_ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const MBEDTLS_ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const MBEDTLS_ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const MBEDTLS_ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const MBEDTLS_ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const MBEDTLS_ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MBEDTLS_MPI_MAX_LIMBS: u32 = 10000;
pub const MBEDTLS_MPI_WINDOW_SIZE: u32 = 2;
pub const MBEDTLS_MPI_MAX_SIZE: u32 = 1024;
pub const MBEDTLS_MPI_MAX_BITS: u32 = 8192;
pub const MBEDTLS_MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const MBEDTLS_LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MBEDTLS_MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const MBEDTLS_MPI_UINT_MAX: i32 = -1;
pub const MBEDTLS_ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const MBEDTLS_ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const MBEDTLS_ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const MBEDTLS_ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const MBEDTLS_ERR_ECP_INVALID_KEY: i32 = -19584;
pub const MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const MBEDTLS_ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const MBEDTLS_ECP_DP_MAX: u32 = 14;
pub const MBEDTLS_ECP_WINDOW_SIZE: u32 = 4;
pub const MBEDTLS_ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const MBEDTLS_ECP_MAX_BITS: u32 = 521;
pub const MBEDTLS_ECP_MAX_BYTES: u32 = 66;
pub const MBEDTLS_ECP_MAX_PT_LEN: u32 = 133;
pub const MBEDTLS_ECP_PF_UNCOMPRESSED: u32 = 0;
pub const MBEDTLS_ECP_PF_COMPRESSED: u32 = 1;
pub const MBEDTLS_ECP_TLS_NAMED_CURVE: u32 = 3;
pub const MBEDTLS_PSA_JPAKE_BUFFER_SIZE: u32 = 336;
pub const PSA_MAX_KEY_BITS: u32 = 65528;
pub const MBEDTLS_PSA_KA_MASK_DUAL_USE: u32 = 0;
pub const PSA_CRYPTO_ITS_RANDOM_SEED_UID: u32 = 4294967122;
pub const MBEDTLS_PSA_KEY_SLOT_COUNT: u32 = 32;
pub const PSA_PAKE_OPERATION_STAGE_SETUP: u32 = 0;
pub const PSA_PAKE_OPERATION_STAGE_COLLECT_INPUTS: u32 = 1;
pub const PSA_PAKE_OPERATION_STAGE_COMPUTATION: u32 = 2;
pub const PSA_PAKE_OUTPUT_MAX_SIZE: u32 = 65;
pub const PSA_PAKE_INPUT_MAX_SIZE: u32 = 65;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
	pub __mbstate8: [::std::os::raw::c_char; 128usize],
	pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
	const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__mbstate_t>(),
		128usize,
		concat!("Size of: ", stringify!(__mbstate_t))
	);
	assert_eq!(
		::std::mem::align_of::<__mbstate_t>(),
		8usize,
		concat!("Alignment of ", stringify!(__mbstate_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__mbstate_t),
			"::",
			stringify!(__mbstate8)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__mbstate_t),
			"::",
			stringify!(_mbstateL)
		)
	);
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
	pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
	pub __arg: *mut ::std::os::raw::c_void,
	pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
	const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__darwin_pthread_handler_rec>(),
		24usize,
		concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
	);
	assert_eq!(
		::std::mem::align_of::<__darwin_pthread_handler_rec>(),
		8usize,
		concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__darwin_pthread_handler_rec),
			"::",
			stringify!(__routine)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__darwin_pthread_handler_rec),
			"::",
			stringify!(__arg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(__darwin_pthread_handler_rec),
			"::",
			stringify!(__next)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_attr_t>(),
		64usize,
		concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_attr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_attr_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_attr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_cond_t>(),
		48usize,
		concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_cond_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_cond_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_cond_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_condattr_t>(),
		16usize,
		concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_condattr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_condattr_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_condattr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_mutex_t>(),
		64usize,
		concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_mutex_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_mutex_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_mutex_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
		16usize,
		concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_mutexattr_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_mutexattr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_once_t>(),
		16usize,
		concat!("Size of: ", stringify!(_opaque_pthread_once_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_once_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_once_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_once_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
		200usize,
		concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_rwlock_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_rwlock_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
	pub __sig: ::std::os::raw::c_long,
	pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
		24usize,
		concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_rwlockattr_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_rwlockattr_t),
			"::",
			stringify!(__opaque)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
	pub __sig: ::std::os::raw::c_long,
	pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
	pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
	const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<_opaque_pthread_t>(),
		8192usize,
		concat!("Size of: ", stringify!(_opaque_pthread_t))
	);
	assert_eq!(
		::std::mem::align_of::<_opaque_pthread_t>(),
		8usize,
		concat!("Alignment of ", stringify!(_opaque_pthread_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_t),
			"::",
			stringify!(__sig)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_t),
			"::",
			stringify!(__cleanup_stack)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(_opaque_pthread_t),
			"::",
			stringify!(__opaque)
		)
	);
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type mbedtls_iso_c_forbids_empty_translation_units = ::std::os::raw::c_int;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
	pub tv_sec: __darwin_time_t,
	pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
	const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<timespec>(),
		16usize,
		concat!("Size of: ", stringify!(timespec))
	);
	assert_eq!(
		::std::mem::align_of::<timespec>(),
		8usize,
		concat!("Alignment of ", stringify!(timespec))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(timespec),
			"::",
			stringify!(tv_sec)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(timespec),
			"::",
			stringify!(tv_nsec)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
	pub tm_sec: ::std::os::raw::c_int,
	pub tm_min: ::std::os::raw::c_int,
	pub tm_hour: ::std::os::raw::c_int,
	pub tm_mday: ::std::os::raw::c_int,
	pub tm_mon: ::std::os::raw::c_int,
	pub tm_year: ::std::os::raw::c_int,
	pub tm_wday: ::std::os::raw::c_int,
	pub tm_yday: ::std::os::raw::c_int,
	pub tm_isdst: ::std::os::raw::c_int,
	pub tm_gmtoff: ::std::os::raw::c_long,
	pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
	const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<tm>(),
		56usize,
		concat!("Size of: ", stringify!(tm))
	);
	assert_eq!(
		::std::mem::align_of::<tm>(),
		8usize,
		concat!("Alignment of ", stringify!(tm))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_sec)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_min)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_hour)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_mday)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_mon)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
		20usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_year)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_wday)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_yday)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_isdst)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_gmtoff)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(tm),
			"::",
			stringify!(tm_zone)
		)
	);
}
extern "C" {
	pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
	pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
	pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
	pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
	pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn clock() -> clock_t;
}
extern "C" {
	pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
	pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
	pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
	pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
	pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
	pub fn strftime(
		arg1: *mut ::std::os::raw::c_char,
		arg2: usize,
		arg3: *const ::std::os::raw::c_char,
		arg4: *const tm,
	) -> usize;
}
extern "C" {
	pub fn strptime(
		arg1: *const ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: *mut tm,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
	pub fn tzset();
}
extern "C" {
	pub fn asctime_r(
		arg1: *const tm,
		arg2: *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn ctime_r(
		arg1: *const time_t,
		arg2: *mut ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
	pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
	pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
	pub fn tzsetwall();
}
extern "C" {
	pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
	pub fn timelocal(arg1: *mut tm) -> time_t;
}
extern "C" {
	pub fn timegm(arg1: *mut tm) -> time_t;
}
extern "C" {
	pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = ::std::os::raw::c_uint;
extern "C" {
	pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
	pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn timespec_get(ts: *mut timespec, base: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type mbedtls_time_t = time_t;
extern "C" {
	pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
	pub quot: intmax_t,
	pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
	const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<imaxdiv_t>(),
		16usize,
		concat!("Size of: ", stringify!(imaxdiv_t))
	);
	assert_eq!(
		::std::mem::align_of::<imaxdiv_t>(),
		8usize,
		concat!("Alignment of ", stringify!(imaxdiv_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(imaxdiv_t),
			"::",
			stringify!(quot)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(imaxdiv_t),
			"::",
			stringify!(rem)
		)
	);
}
extern "C" {
	pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
	pub fn strtoimax(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> intmax_t;
}
extern "C" {
	pub fn strtoumax(
		__nptr: *const ::std::os::raw::c_char,
		__endptr: *mut *mut ::std::os::raw::c_char,
		__base: ::std::os::raw::c_int,
	) -> uintmax_t;
}
extern "C" {
	pub fn wcstoimax(
		__nptr: *const wchar_t,
		__endptr: *mut *mut wchar_t,
		__base: ::std::os::raw::c_int,
	) -> intmax_t;
}
extern "C" {
	pub fn wcstoumax(
		__nptr: *const wchar_t,
		__endptr: *mut *mut wchar_t,
		__base: ::std::os::raw::c_int,
	) -> uintmax_t;
}
pub type mbedtls_ms_time_t = i64;
extern "C" {
	#[doc = " \\brief   Get time in milliseconds.\n\n \\return Monotonically-increasing current time in milliseconds.\n\n \\note Define MBEDTLS_PLATFORM_MS_TIME_ALT to be able to provide an\n       alternative implementation\n\n \\warning This function returns a monotonically-increasing time value from a\n          start time that will differ from platform to platform, and possibly\n          from run to run of the process.\n"]
	pub fn mbedtls_ms_time() -> mbedtls_ms_time_t;
}
extern "C" {
	#[doc = " \\brief       Securely zeroize a buffer\n\n              The function is meant to wipe the data contained in a buffer so\n              that it can no longer be recovered even if the program memory\n              is later compromised. Call this function on sensitive data\n              stored on the stack before returning from a function, and on\n              sensitive data stored on the heap before freeing the heap\n              object.\n\n              It is extremely difficult to guarantee that calls to\n              mbedtls_platform_zeroize() are not removed by aggressive\n              compiler optimizations in a portable way. For this reason, Mbed\n              TLS provides the configuration option\n              MBEDTLS_PLATFORM_ZEROIZE_ALT, which allows users to configure\n              mbedtls_platform_zeroize() to use a suitable implementation for\n              their platform and needs\n\n \\param buf   Buffer to be zeroized\n \\param len   Length of the buffer in bytes\n"]
	pub fn mbedtls_platform_zeroize(buf: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
	#[doc = " \\brief      Platform-specific implementation of gmtime_r()\n\n             The function is a thread-safe abstraction that behaves\n             similarly to the gmtime_r() function from Unix/POSIX.\n\n             Mbed TLS will try to identify the underlying platform and\n             make use of an appropriate underlying implementation (e.g.\n             gmtime_r() for POSIX and gmtime_s() for Windows). If this is\n             not possible, then gmtime() will be used. In this case, calls\n             from the library to gmtime() will be guarded by the mutex\n             mbedtls_threading_gmtime_mutex if MBEDTLS_THREADING_C is\n             enabled. It is recommended that calls from outside the library\n             are also guarded by this mutex.\n\n             If MBEDTLS_PLATFORM_GMTIME_R_ALT is defined, then Mbed TLS will\n             unconditionally use the alternative implementation for\n             mbedtls_platform_gmtime_r() supplied by the user at compile time.\n\n \\param tt     Pointer to an object containing time (in seconds) since the\n               epoch to be converted\n \\param tm_buf Pointer to an object where the results will be stored\n\n \\return      Pointer to an object of type struct tm on success, otherwise\n              NULL"]
	pub fn mbedtls_platform_gmtime_r(tt: *const mbedtls_time_t, tm_buf: *mut tm) -> *mut tm;
}
#[doc = "< None."]
pub const mbedtls_md_type_t_MBEDTLS_MD_NONE: mbedtls_md_type_t = 0;
#[doc = "< The MD5 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_MD5: mbedtls_md_type_t = 3;
#[doc = "< The RIPEMD-160 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_RIPEMD160: mbedtls_md_type_t = 4;
#[doc = "< The SHA-1 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA1: mbedtls_md_type_t = 5;
#[doc = "< The SHA-224 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA224: mbedtls_md_type_t = 8;
#[doc = "< The SHA-256 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA256: mbedtls_md_type_t = 9;
#[doc = "< The SHA-384 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA384: mbedtls_md_type_t = 10;
#[doc = "< The SHA-512 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA512: mbedtls_md_type_t = 11;
#[doc = "< The SHA3-224 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA3_224: mbedtls_md_type_t = 16;
#[doc = "< The SHA3-256 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA3_256: mbedtls_md_type_t = 17;
#[doc = "< The SHA3-384 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA3_384: mbedtls_md_type_t = 18;
#[doc = "< The SHA3-512 message digest."]
pub const mbedtls_md_type_t_MBEDTLS_MD_SHA3_512: mbedtls_md_type_t = 19;
#[doc = " \\brief     Supported message digests.\n\n \\warning   MD5 and SHA-1 are considered weak message digests and\n            their use constitutes a security risk. We recommend considering\n            stronger message digests instead.\n"]
pub type mbedtls_md_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_info_t {
	_unused: [u8; 0],
}
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_LEGACY: mbedtls_md_engine_t = 0;
pub const mbedtls_md_engine_t_MBEDTLS_MD_ENGINE_PSA: mbedtls_md_engine_t = 1;
#[doc = " Used internally to indicate whether a context uses legacy or PSA.\n\n Internal use only."]
pub type mbedtls_md_engine_t = ::std::os::raw::c_uint;
#[doc = " The generic message-digest context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md_context_t {
	pub private_md_info: *const mbedtls_md_info_t,
	pub private_md_ctx: *mut ::std::os::raw::c_void,
	pub private_hmac_ctx: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mbedtls_md_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_md_context_t> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_md_context_t>(),
		24usize,
		concat!("Size of: ", stringify!(mbedtls_md_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_md_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_md_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_md_info) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_md_context_t),
			"::",
			stringify!(private_md_info)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_md_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_md_context_t),
			"::",
			stringify!(private_md_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_hmac_ctx) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_md_context_t),
			"::",
			stringify!(private_hmac_ctx)
		)
	);
}
extern "C" {
	#[doc = " \\brief           This function returns the message-digest information\n                  associated with the given digest type.\n\n \\param md_type   The type of digest to search for.\n\n \\return          The message-digest information associated with \\p md_type.\n \\return          NULL if the associated message-digest information is not found."]
	pub fn mbedtls_md_info_from_type(md_type: mbedtls_md_type_t) -> *const mbedtls_md_info_t;
}
extern "C" {
	#[doc = " \\brief           This function initializes a message-digest context without\n                  binding it to a particular message-digest algorithm.\n\n                  This function should always be called first. It prepares the\n                  context for mbedtls_md_setup() for binding it to a\n                  message-digest algorithm."]
	pub fn mbedtls_md_init(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
	#[doc = " \\brief           This function clears the internal structure of \\p ctx and\n                  frees any embedded internal structure, but does not free\n                  \\p ctx itself.\n\n                  If you have called mbedtls_md_setup() on \\p ctx, you must\n                  call mbedtls_md_free() when you are no longer using the\n                  context.\n                  Calling this function if you have previously\n                  called mbedtls_md_init() and nothing else is optional.\n                  You must not call this function if you have not called\n                  mbedtls_md_init()."]
	pub fn mbedtls_md_free(ctx: *mut mbedtls_md_context_t);
}
extern "C" {
	#[doc = " \\brief           This function selects the message digest algorithm to use,\n                  and allocates internal structures.\n\n                  It should be called after mbedtls_md_init() or\n                  mbedtls_md_free(). Makes it necessary to call\n                  mbedtls_md_free() later.\n\n \\param ctx       The context to set up.\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n \\param hmac      Defines if HMAC is used. 0: HMAC is not used (saves some memory),\n                  or non-zero: HMAC is used with this context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure.\n \\return          #MBEDTLS_ERR_MD_ALLOC_FAILED on memory-allocation failure."]
	pub fn mbedtls_md_setup(
		ctx: *mut mbedtls_md_context_t,
		md_info: *const mbedtls_md_info_t,
		hmac: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function clones the state of a message-digest\n                  context.\n\n \\note            You must call mbedtls_md_setup() on \\c dst before calling\n                  this function.\n\n \\note            The two contexts must have the same type,\n                  for example, both are SHA-256.\n\n \\warning         This function clones the message-digest state, not the\n                  HMAC state.\n\n \\param dst       The destination context.\n \\param src       The context to be cloned.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification failure.\n \\return          #MBEDTLS_ERR_MD_FEATURE_UNAVAILABLE if both contexts are\n                  not using the same engine. This can be avoided by moving\n                  the call to psa_crypto_init() before the first call to\n                  mbedtls_md_setup()."]
	pub fn mbedtls_md_clone(
		dst: *mut mbedtls_md_context_t,
		src: *const mbedtls_md_context_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function extracts the message-digest size from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The size of the message-digest output in Bytes."]
	pub fn mbedtls_md_get_size(md_info: *const mbedtls_md_info_t) -> ::std::os::raw::c_uchar;
}
extern "C" {
	#[doc = " \\brief           This function extracts the message-digest type from the\n                  message-digest information structure.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The type of the message digest."]
	pub fn mbedtls_md_get_type(md_info: *const mbedtls_md_info_t) -> mbedtls_md_type_t;
}
extern "C" {
	#[doc = " \\brief           This function starts a message-digest computation.\n\n                  You must call this function after setting up the context\n                  with mbedtls_md_setup(), and before passing data with\n                  mbedtls_md_update().\n\n \\param ctx       The generic message-digest context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
	pub fn mbedtls_md_starts(ctx: *mut mbedtls_md_context_t) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function feeds an input buffer into an ongoing\n                  message-digest computation.\n\n                  You must call mbedtls_md_starts() before calling this\n                  function. You may call this function multiple times.\n                  Afterwards, call mbedtls_md_finish().\n\n \\param ctx       The generic message-digest context.\n \\param input     The buffer holding the input data.\n \\param ilen      The length of the input data.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
	pub fn mbedtls_md_update(
		ctx: *mut mbedtls_md_context_t,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function finishes the digest operation,\n                  and writes the result to the output buffer.\n\n                  Call this function after a call to mbedtls_md_starts(),\n                  followed by any number of calls to mbedtls_md_update().\n                  Afterwards, you may either clear the context with\n                  mbedtls_md_free(), or call mbedtls_md_starts() to reuse\n                  the context for another digest operation with the same\n                  algorithm.\n\n \\param ctx       The generic message-digest context.\n \\param output    The buffer for the generic message-digest checksum result.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
	pub fn mbedtls_md_finish(
		ctx: *mut mbedtls_md_context_t,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function calculates the message-digest of a buffer,\n                 with respect to a configurable message-digest algorithm\n                 in a single call.\n\n                 The result is calculated as\n                 Output = message_digest(input buffer).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param input    The buffer holding the data.\n \\param ilen     The length of the input data.\n \\param output   The generic message-digest checksum result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                 failure."]
	pub fn mbedtls_md(
		md_info: *const mbedtls_md_info_t,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function returns the list of digests supported by the\n                  generic digest module.\n\n \\note            The list starts with the strongest available hashes.\n\n \\return          A statically allocated array of digests. Each element\n                  in the returned list is an integer belonging to the\n                  message-digest enumeration #mbedtls_md_type_t.\n                  The last entry is 0."]
	pub fn mbedtls_md_list() -> *const ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function returns the message-digest information\n                  associated with the given digest name.\n\n \\param md_name   The name of the digest to search for.\n\n \\return          The message-digest information associated with \\p md_name.\n \\return          NULL if the associated message-digest information is not found."]
	pub fn mbedtls_md_info_from_string(
		md_name: *const ::std::os::raw::c_char,
	) -> *const mbedtls_md_info_t;
}
extern "C" {
	#[doc = " \\brief           This function returns the name of the message digest for\n                  the message-digest information structure given.\n\n \\param md_info   The information structure of the message-digest algorithm\n                  to use.\n\n \\return          The name of the message digest."]
	pub fn mbedtls_md_get_name(md_info: *const mbedtls_md_info_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
	#[doc = " \\brief           This function returns the message-digest information\n                  from the given context.\n\n \\param ctx       The context from which to extract the information.\n                  This must be initialized (or \\c NULL).\n\n \\return          The message-digest information associated with \\p ctx.\n \\return          \\c NULL if \\p ctx is \\c NULL."]
	pub fn mbedtls_md_info_from_ctx(ctx: *const mbedtls_md_context_t) -> *const mbedtls_md_info_t;
}
extern "C" {
	#[doc = " \\brief          This function calculates the message-digest checksum\n                 result of the contents of the provided file.\n\n                 The result is calculated as\n                 Output = message_digest(file contents).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param path     The input file name.\n \\param output   The generic message-digest checksum result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_FILE_IO_ERROR on an I/O error accessing\n                 the file pointed by \\p path.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA if \\p md_info was NULL."]
	pub fn mbedtls_md_file(
		md_info: *const mbedtls_md_info_t,
		path: *const ::std::os::raw::c_char,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function sets the HMAC key and prepares to\n                  authenticate a new message.\n\n                  Call this function after mbedtls_md_setup(), to use\n                  the MD context for an HMAC calculation, then call\n                  mbedtls_md_hmac_update() to provide the input data, and\n                  mbedtls_md_hmac_finish() to get the HMAC value.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param key       The HMAC secret key.\n \\param keylen    The length of the HMAC key in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
	pub fn mbedtls_md_hmac_starts(
		ctx: *mut mbedtls_md_context_t,
		key: *const ::std::os::raw::c_uchar,
		keylen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function feeds an input buffer into an ongoing HMAC\n                  computation.\n\n                  Call mbedtls_md_hmac_starts() or mbedtls_md_hmac_reset()\n                  before calling this function.\n                  You may call this function multiple times to pass the\n                  input piecewise.\n                  Afterwards, call mbedtls_md_hmac_finish().\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param input     The buffer holding the input data.\n \\param ilen      The length of the input data.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
	pub fn mbedtls_md_hmac_update(
		ctx: *mut mbedtls_md_context_t,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function finishes the HMAC operation, and writes\n                  the result to the output buffer.\n\n                  Call this function after mbedtls_md_hmac_starts() and\n                  mbedtls_md_hmac_update() to get the HMAC value. Afterwards\n                  you may either call mbedtls_md_free() to clear the context,\n                  or call mbedtls_md_hmac_reset() to reuse the context with\n                  the same HMAC key.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n \\param output    The generic HMAC checksum result.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
	pub fn mbedtls_md_hmac_finish(
		ctx: *mut mbedtls_md_context_t,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function prepares to authenticate a new message with\n                  the same key as the previous HMAC operation.\n\n                  You may call this function after mbedtls_md_hmac_finish().\n                  Afterwards call mbedtls_md_hmac_update() to pass the new\n                  input.\n\n \\param ctx       The message digest context containing an embedded HMAC\n                  context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                  failure."]
	pub fn mbedtls_md_hmac_reset(ctx: *mut mbedtls_md_context_t) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function calculates the full generic HMAC\n                 on the input buffer with the provided key.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The HMAC result is calculated as\n                 output = generic HMAC(hmac key, input buffer).\n\n \\param md_info  The information structure of the message-digest algorithm\n                 to use.\n \\param key      The HMAC secret key.\n \\param keylen   The length of the HMAC secret key in Bytes.\n \\param input    The buffer holding the input data.\n \\param ilen     The length of the input data.\n \\param output   The generic HMAC result.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_MD_BAD_INPUT_DATA on parameter-verification\n                 failure."]
	pub fn mbedtls_md_hmac(
		md_info: *const mbedtls_md_info_t,
		key: *const ::std::os::raw::c_uchar,
		keylen: usize,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
#[doc = " \\brief          MD5 context structure\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_md5_context {
	pub private_total: [u32; 2usize],
	pub private_state: [u32; 4usize],
	pub private_buffer: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_mbedtls_md5_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_md5_context> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_md5_context>(),
		88usize,
		concat!("Size of: ", stringify!(mbedtls_md5_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_md5_context>(),
		4usize,
		concat!("Alignment of ", stringify!(mbedtls_md5_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_total) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_md5_context),
			"::",
			stringify!(private_total)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_md5_context),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_md5_context),
			"::",
			stringify!(private_buffer)
		)
	);
}
extern "C" {
	#[doc = " \\brief          Initialize MD5 context\n\n \\param ctx      MD5 context to be initialized\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5_init(ctx: *mut mbedtls_md5_context);
}
extern "C" {
	#[doc = " \\brief          Clear MD5 context\n\n \\param ctx      MD5 context to be cleared\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5_free(ctx: *mut mbedtls_md5_context);
}
extern "C" {
	#[doc = " \\brief          Clone (the state of) an MD5 context\n\n \\param dst      The destination context\n \\param src      The context to be cloned\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5_clone(dst: *mut mbedtls_md5_context, src: *const mbedtls_md5_context);
}
extern "C" {
	#[doc = " \\brief          MD5 context setup\n\n \\param ctx      context to be initialized\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5_starts(ctx: *mut mbedtls_md5_context) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          MD5 process buffer\n\n \\param ctx      MD5 context\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5_update(
		ctx: *mut mbedtls_md5_context,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          MD5 final digest\n\n \\param ctx      MD5 context\n \\param output   MD5 checksum result\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5_finish(
		ctx: *mut mbedtls_md5_context,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          MD5 process data block (internal use only)\n\n \\param ctx      MD5 context\n \\param data     buffer holding one block of data\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_internal_md5_process(
		ctx: *mut mbedtls_md5_context,
		data: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Output = MD5( input buffer )\n\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n \\param output   MD5 checksum result\n\n \\return         0 if successful\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5(
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed\n\n \\warning        MD5 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
	pub fn mbedtls_md5_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " \\brief          The SHA-1 context structure.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha1_context {
	pub private_total: [u32; 2usize],
	pub private_state: [u32; 5usize],
	pub private_buffer: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_mbedtls_sha1_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_sha1_context> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_sha1_context>(),
		92usize,
		concat!("Size of: ", stringify!(mbedtls_sha1_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_sha1_context>(),
		4usize,
		concat!("Alignment of ", stringify!(mbedtls_sha1_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_total) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha1_context),
			"::",
			stringify!(private_total)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha1_context),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer) as usize - ptr as usize },
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha1_context),
			"::",
			stringify!(private_buffer)
		)
	);
}
extern "C" {
	#[doc = " \\brief          This function initializes a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to initialize.\n                 This must not be \\c NULL.\n"]
	pub fn mbedtls_sha1_init(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
	#[doc = " \\brief          This function clears a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to clear. This may be \\c NULL,\n                 in which case this function does nothing. If it is\n                 not \\c NULL, it must point to an initialized\n                 SHA-1 context.\n"]
	pub fn mbedtls_sha1_free(ctx: *mut mbedtls_sha1_context);
}
extern "C" {
	#[doc = " \\brief          This function clones the state of a SHA-1 context.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param dst      The SHA-1 context to clone to. This must be initialized.\n \\param src      The SHA-1 context to clone from. This must be initialized.\n"]
	pub fn mbedtls_sha1_clone(dst: *mut mbedtls_sha1_context, src: *const mbedtls_sha1_context);
}
extern "C" {
	#[doc = " \\brief          This function starts a SHA-1 checksum calculation.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to initialize. This must be initialized.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
	pub fn mbedtls_sha1_starts(ctx: *mut mbedtls_sha1_context) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function feeds an input buffer into an ongoing SHA-1\n                 checksum calculation.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the input data.\n                 This must be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data \\p input in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha1_update(
		ctx: *mut mbedtls_sha1_context,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function finishes the SHA-1 operation, and writes\n                 the result to the output buffer.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to use. This must be initialized and\n                 have a hash operation started.\n \\param output   The SHA-1 checksum result. This must be a writable\n                 buffer of length \\c 20 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha1_finish(
		ctx: *mut mbedtls_sha1_context,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          SHA-1 process data block (internal use only).\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param ctx      The SHA-1 context to use. This must be initialized.\n \\param data     The data block being processed. This must be a\n                 readable buffer of length \\c 64 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
	pub fn mbedtls_internal_sha1_process(
		ctx: *mut mbedtls_sha1_context,
		data: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function calculates the SHA-1 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-1 result is calculated as\n                 output = SHA-1(input buffer).\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\param input    The buffer holding the input data.\n                 This must be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data \\p input in Bytes.\n \\param output   The SHA-1 checksum result.\n                 This must be a writable buffer of length \\c 20 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure.\n"]
	pub fn mbedtls_sha1(
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The SHA-1 checkup routine.\n\n \\warning        SHA-1 is considered a weak message digest and its use\n                 constitutes a security risk. We recommend considering\n                 stronger message digests instead.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure.\n"]
	pub fn mbedtls_sha1_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type psa_status_t = i32;
#[doc = " \\brief Encoding of a key type.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_TYPE_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_type_t = u16;
#[doc = " The type of PSA elliptic curve family identifiers.\n\n Values of this type are generally constructed by macros called\n `PSA_ECC_FAMILY_xxx`.\n\n The curve identifier is required to create an ECC key using the\n PSA_KEY_TYPE_ECC_KEY_PAIR() or PSA_KEY_TYPE_ECC_PUBLIC_KEY()\n macros.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional families must use an encoding in this range.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_ecc_family_t = u8;
#[doc = " The type of PSA Diffie-Hellman group family identifiers.\n\n Values of this type are generally constructed by macros called\n `PSA_DH_FAMILY_xxx`.\n\n The group identifier is required to create a Diffie-Hellman key using the\n PSA_KEY_TYPE_DH_KEY_PAIR() or PSA_KEY_TYPE_DH_PUBLIC_KEY()\n macros.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional families must use an encoding in this range.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_dh_family_t = u8;
#[doc = " \\brief Encoding of a cryptographic algorithm.\n\n Values of this type are generally constructed by macros called\n `PSA_ALG_xxx`.\n\n For algorithms that can be applied to multiple key types, this type\n does not encode the key type. For example, for symmetric ciphers\n based on a block cipher, #psa_algorithm_t encodes the block cipher\n mode and the padding mode while the block cipher itself is encoded\n via #psa_key_type_t.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_algorithm_t = u32;
#[doc = " Encoding of key lifetimes.\n\n The lifetime of a key indicates where it is stored and what system actions\n may create and destroy it.\n\n Lifetime values have the following structure:\n - Bits 0-7 (#PSA_KEY_LIFETIME_GET_PERSISTENCE(\\c lifetime)):\n   persistence level. This value indicates what device management\n   actions can cause it to be destroyed. In particular, it indicates\n   whether the key is _volatile_ or _persistent_.\n   See ::psa_key_persistence_t for more information.\n - Bits 8-31 (#PSA_KEY_LIFETIME_GET_LOCATION(\\c lifetime)):\n   location indicator. This value indicates which part of the system\n   has access to the key material and can perform operations using the key.\n   See ::psa_key_location_t for more information.\n\n Volatile keys are automatically destroyed when the application instance\n terminates or on a power reset of the device. Persistent keys are\n preserved until the application explicitly destroys them or until an\n integration-specific device management event occurs (for example,\n a factory reset).\n\n Persistent keys have a key identifier of type #mbedtls_svc_key_id_t.\n This identifier remains valid throughout the lifetime of the key,\n even if the application instance that created the key terminates.\n The application can call psa_open_key() to open a persistent key that\n it created previously.\n\n The default lifetime of a key is #PSA_KEY_LIFETIME_VOLATILE. The lifetime\n #PSA_KEY_LIFETIME_PERSISTENT is supported if persistent storage is\n available. Other lifetime values may be supported depending on the\n library configuration.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_LIFETIME_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_lifetime_t = u32;
#[doc = " Encoding of key persistence levels.\n\n What distinguishes different persistence levels is what device management\n events may cause keys to be destroyed. _Volatile_ keys are destroyed\n by a power reset. Persistent keys may be destroyed by events such as\n a transfer of ownership or a factory reset. What management events\n actually affect persistent keys at different levels is outside the\n scope of the PSA Cryptography specification.\n\n The PSA Cryptography specification defines the following values of\n persistence levels:\n - \\c 0 = #PSA_KEY_PERSISTENCE_VOLATILE: volatile key.\n   A volatile key is automatically destroyed by the implementation when\n   the application instance terminates. In particular, a volatile key\n   is automatically destroyed on a power reset of the device.\n - \\c 1 = #PSA_KEY_PERSISTENCE_DEFAULT:\n   persistent key with a default lifetime.\n - \\c 2-254: currently not supported by Mbed TLS.\n - \\c 255 = #PSA_KEY_PERSISTENCE_READ_ONLY:\n   read-only or write-once key.\n   A key with this persistence level cannot be destroyed.\n   Mbed TLS does not currently offer a way to create such keys, but\n   integrations of Mbed TLS can use it for built-in keys that the\n   application cannot modify (for example, a hardware unique key (HUK)).\n\n \\note Key persistence levels are 8-bit values. Key management\n       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which\n       encode the persistence as the lower 8 bits of a 32-bit value.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_persistence_t = u8;
#[doc = " Encoding of key location indicators.\n\n If an integration of Mbed TLS can make calls to external\n cryptoprocessors such as secure elements, the location of a key\n indicates which secure element performs the operations on the key.\n Depending on the design of the secure element, the key\n material may be stored either in the secure element, or\n in wrapped (encrypted) form alongside the key metadata in the\n primary local storage.\n\n The PSA Cryptography API specification defines the following values of\n location indicators:\n - \\c 0: primary local storage.\n   This location is always available.\n   The primary local storage is typically the same storage area that\n   contains the key metadata.\n - \\c 1: primary secure element.\n   Integrations of Mbed TLS should support this value if there is a secure\n   element attached to the operating environment.\n   As a guideline, secure elements may provide higher resistance against\n   side channel and physical attacks than the primary local storage, but may\n   have restrictions on supported key types, sizes, policies and operations\n   and may have different performance characteristics.\n - \\c 2-0x7fffff: other locations defined by a PSA specification.\n   The PSA Cryptography API does not currently assign any meaning to these\n   locations, but future versions of that specification or other PSA\n   specifications may do so.\n - \\c 0x800000-0xffffff: vendor-defined locations.\n   No PSA specification will assign a meaning to locations in this range.\n\n \\note Key location indicators are 24-bit values. Key management\n       interfaces operate on lifetimes (type ::psa_key_lifetime_t) which\n       encode the location as the upper 24 bits of a 32-bit value.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_location_t = u32;
#[doc = " Encoding of identifiers of persistent keys.\n\n - Applications may freely choose key identifiers in the range\n   #PSA_KEY_ID_USER_MIN to #PSA_KEY_ID_USER_MAX.\n - The implementation may define additional key identifiers in the range\n   #PSA_KEY_ID_VENDOR_MIN to #PSA_KEY_ID_VENDOR_MAX.\n - 0 is reserved as an invalid key identifier.\n - Key identifiers outside these ranges are reserved for future use.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to how values are allocated must require careful\n       consideration to allow backward compatibility."]
pub type psa_key_id_t = u32;
pub type mbedtls_svc_key_id_t = psa_key_id_t;
#[doc = " \\brief Encoding of permitted usage on a key.\n\n Values of this type are generally constructed as bitwise-ors of macros\n called `PSA_KEY_USAGE_xxx`.\n\n \\note Values of this type are encoded in the persistent key store.\n       Any changes to existing values will require bumping the storage\n       format version and providing a translation when reading the old\n       format."]
pub type psa_key_usage_t = u32;
#[doc = " The type of a structure containing key attributes.\n\n This is an opaque structure that can represent the metadata of a key\n object. Metadata that can be stored in attributes includes:\n - The location of the key in storage, indicated by its key identifier\n   and its lifetime.\n - The key's policy, comprising usage flags and a specification of\n   the permitted algorithm(s).\n - Information about the key itself: the key type and its size.\n - Additional implementation-defined attributes.\n\n The actual key material is not considered an attribute of a key.\n Key attributes do not contain information that is generally considered\n highly confidential.\n\n An attribute structure works like a simple data structure where each function\n `psa_set_key_xxx` sets a field and the corresponding function\n `psa_get_key_xxx` retrieves the value of the corresponding field.\n However, a future version of the library  may report values that are\n equivalent to the original one, but have a different encoding. Invalid\n values may be mapped to different, also invalid values.\n\n An attribute structure may contain references to auxiliary resources,\n for example pointers to allocated memory or indirect references to\n pre-calculated values. In order to free such resources, the application\n must call psa_reset_key_attributes(). As an exception, calling\n psa_reset_key_attributes() on an attribute structure is optional if\n the structure has only been modified by the following functions\n since it was initialized or last reset with psa_reset_key_attributes():\n - psa_set_key_id()\n - psa_set_key_lifetime()\n - psa_set_key_type()\n - psa_set_key_bits()\n - psa_set_key_usage_flags()\n - psa_set_key_algorithm()\n\n Before calling any function on a key attribute structure, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_key_attributes_t attributes;\n   memset(&attributes, 0, sizeof(attributes));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_key_attributes_t attributes = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_KEY_ATTRIBUTES_INIT,\n   for example:\n   \\code\n   psa_key_attributes_t attributes = PSA_KEY_ATTRIBUTES_INIT;\n   \\endcode\n - Assign the result of the function psa_key_attributes_init()\n   to the structure, for example:\n   \\code\n   psa_key_attributes_t attributes;\n   attributes = psa_key_attributes_init();\n   \\endcode\n\n A freshly initialized attribute structure contains the following\n values:\n\n - lifetime: #PSA_KEY_LIFETIME_VOLATILE.\n - key identifier: 0 (which is not a valid key identifier).\n - type: \\c 0 (meaning that the type is unspecified).\n - key size: \\c 0 (meaning that the size is unspecified).\n - usage flags: \\c 0 (which allows no usage except exporting a public key).\n - algorithm: \\c 0 (which allows no cryptographic usage, but allows\n   exporting).\n\n A typical sequence to create a key is as follows:\n -# Create and initialize an attribute structure.\n -# If the key is persistent, call psa_set_key_id().\n    Also call psa_set_key_lifetime() to place the key in a non-default\n    location.\n -# Set the key policy with psa_set_key_usage_flags() and\n    psa_set_key_algorithm().\n -# Set the key type with psa_set_key_type().\n    Skip this step if copying an existing key with psa_copy_key().\n -# When generating a random key with psa_generate_key() or deriving a key\n    with psa_key_derivation_output_key(), set the desired key size with\n    psa_set_key_bits().\n -# Call a key creation function: psa_import_key(), psa_generate_key(),\n    psa_key_derivation_output_key() or psa_copy_key(). This function reads\n    the attribute structure, creates a key with these attributes, and\n    outputs a key identifier to the newly created key.\n -# The attribute structure is now no longer necessary.\n    You may call psa_reset_key_attributes(), although this is optional\n    with the workflow presented here because the attributes currently\n    defined in this specification do not require any additional resources\n    beyond the structure itself.\n\n A typical sequence to query a key's attributes is as follows:\n -# Call psa_get_key_attributes().\n -# Call `psa_get_key_xxx` functions to retrieve the attribute(s) that\n    you are interested in.\n -# Call psa_reset_key_attributes() to free any resources that may be\n    used by the attribute structure.\n\n Once a key has been created, it is impossible to change its attributes."]
pub type psa_key_attributes_t = psa_key_attributes_s;
#[doc = " \\brief Encoding of the step of a key derivation.\n\n Values of this type are generally constructed by macros called\n `PSA_KEY_DERIVATION_INPUT_xxx`."]
pub type psa_key_derivation_step_t = u16;
extern "C" {
	#[doc = " \\brief Library initialization.\n\n Applications must call this function before calling any other\n function in this module.\n\n Applications may call this function more than once. Once a call\n succeeds, subsequent calls are guaranteed to succeed.\n\n If the application calls other functions before calling psa_crypto_init(),\n the behavior is undefined. Implementations are encouraged to either perform\n the operation as if the library had been initialized or to return\n #PSA_ERROR_BAD_STATE or some other applicable error. In particular,\n implementations should not return a success status if the lack of\n initialization may have security implications, for example due to improper\n seeding of the random number generator.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription"]
	pub fn psa_crypto_init() -> psa_status_t;
}
extern "C" {
	#[doc = " Retrieve the attributes of a key.\n\n This function first resets the attribute structure as with\n psa_reset_key_attributes(). It then copies the attributes of\n the given key into the given attribute structure.\n\n \\note This function may allocate memory or other resources.\n       Once you have called this function on an attribute structure,\n       you must call psa_reset_key_attributes() to free these resources.\n\n \\param[in] key               Identifier of the key to query.\n \\param[in,out] attributes    On success, the attributes of the key.\n                              On failure, equivalent to a\n                              freshly-initialized structure.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_get_key_attributes(
		key: mbedtls_svc_key_id_t,
		attributes: *mut psa_key_attributes_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Reset a key attribute structure to a freshly initialized state.\n\n You must initialize the attribute structure as described in the\n documentation of the type #psa_key_attributes_t before calling this\n function. Once the structure has been initialized, you may call this\n function at any time.\n\n This function frees any auxiliary resources that the structure\n may contain.\n\n \\param[in,out] attributes    The attribute structure to reset."]
	pub fn psa_reset_key_attributes(attributes: *mut psa_key_attributes_t);
}
extern "C" {
	#[doc = " Remove non-essential copies of key material from memory.\n\n If the key identifier designates a volatile key, this functions does not do\n anything and returns successfully.\n\n If the key identifier designates a persistent key, then this function will\n free all resources associated with the key in volatile memory. The key\n data in persistent storage is not affected and the key can still be used.\n\n \\param key Identifier of the key to purge.\n\n \\retval #PSA_SUCCESS\n         The key material will have been removed from memory if it is not\n         currently required.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not a valid key identifier.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_purge_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
	#[doc = " Make a copy of a key.\n\n Copy key material from one location to another.\n\n This function is primarily useful to copy a key from one location\n to another, since it populates a key using the material from\n another key which may have a different lifetime.\n\n This function may be used to share a key with a different party,\n subject to implementation-defined restrictions on key sharing.\n\n The policy on the source key must have the usage flag\n #PSA_KEY_USAGE_COPY set.\n This flag is sufficient to permit the copy if the key has the lifetime\n #PSA_KEY_LIFETIME_VOLATILE or #PSA_KEY_LIFETIME_PERSISTENT.\n Some secure elements do not provide a way to copy a key without\n making it extractable from the secure element. If a key is located\n in such a secure element, then the key must have both usage flags\n #PSA_KEY_USAGE_COPY and #PSA_KEY_USAGE_EXPORT in order to make\n a copy of the key outside the secure element.\n\n The resulting key may only be used in a way that conforms to\n both the policy of the original key and the policy specified in\n the \\p attributes parameter:\n - The usage flags on the resulting key are the bitwise-and of the\n   usage flags on the source policy and the usage flags in \\p attributes.\n - If both allow the same algorithm or wildcard-based\n   algorithm policy, the resulting key has the same algorithm policy.\n - If either of the policies allows an algorithm and the other policy\n   allows a wildcard-based algorithm policy that includes this algorithm,\n   the resulting key allows the same algorithm.\n - If the policies do not allow any algorithm in common, this function\n   fails with the status #PSA_ERROR_INVALID_ARGUMENT.\n\n The effect of this function on implementation-defined attributes is\n implementation-defined.\n\n \\param source_key        The key to copy. It must allow the usage\n                          #PSA_KEY_USAGE_COPY. If a private or secret key is\n                          being copied outside of a secure element it must\n                          also allow #PSA_KEY_USAGE_EXPORT.\n \\param[in] attributes    The attributes for the new key.\n                          They are used as follows:\n                          - The key type and size may be 0. If either is\n                            nonzero, it must match the corresponding\n                            attribute of the source key.\n                          - The key location (the lifetime and, for\n                            persistent keys, the key identifier) is\n                            used directly.\n                          - The policy constraints (usage flags and\n                            algorithm policy) are combined from\n                            the source key and \\p attributes so that\n                            both sets of restrictions apply, as\n                            described in the documentation of this function.\n \\param[out] target_key   On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p source_key is invalid.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The lifetime or identifier in \\p attributes are invalid, or\n         the policy constraints on the source and specified in\n         \\p attributes are incompatible, or\n         \\p attributes specifies a key type or key size\n         which does not match the attributes of the source key.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The source key does not have the #PSA_KEY_USAGE_COPY usage flag, or\n         the source key is not exportable and its lifetime does not\n         allow copying it to the target's lifetime.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_copy_key(
		source_key: mbedtls_svc_key_id_t,
		attributes: *const psa_key_attributes_t,
		target_key: *mut mbedtls_svc_key_id_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Destroy a key.\n\n This function destroys a key from both volatile\n memory and, if applicable, non-volatile storage. Implementations shall\n make a best effort to ensure that the key material cannot be recovered.\n\n This function also erases any metadata such as policies and frees\n resources associated with the key.\n\n If a key is currently in use in a multipart operation, then destroying the\n key will cause the multipart operation to fail.\n\n \\param key  Identifier of the key to erase. If this is \\c 0, do nothing and\n             return #PSA_SUCCESS.\n\n \\retval #PSA_SUCCESS\n         \\p key was a valid identifier and the key material that it\n         referred to has been erased. Alternatively, \\p key is \\c 0.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key cannot be erased because it is\n         read-only, either due to a policy or due to physical restrictions.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p key is not a valid identifier nor \\c 0.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE\n         There was a failure in communication with the cryptoprocessor.\n         The key material may still be present in the cryptoprocessor.\n \\retval #PSA_ERROR_DATA_INVALID\n         This error is typically a result of either storage corruption on a\n         cleartext storage backend, or an attempt to read data that was\n         written by an incompatible version of the library.\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The storage is corrupted. Implementations shall make a best effort\n         to erase key material even in this stage, however applications\n         should be aware that it may be impossible to guarantee that the\n         key material is not recoverable in such cases.\n \\retval #PSA_ERROR_CORRUPTION_DETECTED\n         An unexpected condition which is not a storage corruption or\n         a communication failure occurred. The cryptoprocessor may have\n         been compromised.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_destroy_key(key: mbedtls_svc_key_id_t) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Import a key in binary format.\n\n This function supports any output from psa_export_key(). Refer to the\n documentation of psa_export_public_key() for the format of public keys\n and to the documentation of psa_export_key() for the format for\n other key types.\n\n The key data determines the key size. The attributes may optionally\n specify a key size; in this case it must match the size determined\n from the key data. A key size of 0 in \\p attributes indicates that\n the key size is solely determined by the key data.\n\n Implementations must reject an attempt to import a key of size 0.\n\n This specification supports a single format for each key type.\n Implementations may support other formats as long as the standard\n format is supported. Implementations that support other formats\n should ensure that the formats are clearly unambiguous so as to\n minimize the risk that an invalid input is accidentally interpreted\n according to a different format.\n\n \\param[in] attributes    The attributes for the new key.\n                          The key size is always determined from the\n                          \\p data buffer.\n                          If the key size in \\p attributes is nonzero,\n                          it must be equal to the size from \\p data.\n \\param[out] key          On success, an identifier to the newly created key.\n                          For persistent keys, this is the key identifier\n                          defined in \\p attributes.\n                          \\c 0 on failure.\n \\param[in] data    Buffer containing the key data. The content of this\n                    buffer is interpreted according to the type declared\n                    in \\p attributes.\n                    All implementations must support at least the format\n                    described in the documentation\n                    of psa_export_key() or psa_export_public_key() for\n                    the chosen type. Implementations may allow other\n                    formats, but should be conservative: implementations\n                    should err on the side of rejecting content if it\n                    may be erroneous (e.g. wrong type or truncated data).\n \\param data_length Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size is not supported, either by the\n         implementation in general or in this particular persistent location.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key attributes, as a whole, are invalid, or\n         the key data is not correctly formatted, or\n         the size in \\p attributes is nonzero and does not match the size\n         of the key data.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_import_key(
		attributes: *const psa_key_attributes_t,
		data: *const u8,
		data_length: usize,
		key: *mut mbedtls_svc_key_id_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Export a key in binary format.\n\n The output of this function can be passed to psa_import_key() to\n create an equivalent object.\n\n If the implementation of psa_import_key() supports other formats\n beyond the format specified here, the output from psa_export_key()\n must use the representation specified here, not the original\n representation.\n\n For standard key types, the output format is as follows:\n\n - For symmetric keys (including MAC keys), the format is the\n   raw bytes of the key.\n - For DES, the key data consists of 8 bytes. The parity bits must be\n   correct.\n - For Triple-DES, the format is the concatenation of the\n   two or three DES keys.\n - For RSA key pairs (#PSA_KEY_TYPE_RSA_KEY_PAIR), the format\n   is the non-encrypted DER encoding of the representation defined by\n   PKCS\\#1 (RFC 8017) as `RSAPrivateKey`, version 0.\n   ```\n   RSAPrivateKey ::= SEQUENCE {\n       version             INTEGER,  -- must be 0\n       modulus             INTEGER,  -- n\n       publicExponent      INTEGER,  -- e\n       privateExponent     INTEGER,  -- d\n       prime1              INTEGER,  -- p\n       prime2              INTEGER,  -- q\n       exponent1           INTEGER,  -- d mod (p-1)\n       exponent2           INTEGER,  -- d mod (q-1)\n       coefficient         INTEGER,  -- (inverse of q) mod p\n   }\n   ```\n - For elliptic curve key pairs (key types for which\n   #PSA_KEY_TYPE_IS_ECC_KEY_PAIR is true), the format is\n   a representation of the private value as a `ceiling(m/8)`-byte string\n   where `m` is the bit size associated with the curve, i.e. the bit size\n   of the order of the curve's coordinate field. This byte string is\n   in little-endian order for Montgomery curves (curve types\n   `PSA_ECC_FAMILY_CURVEXXX`), and in big-endian order for Weierstrass\n   curves (curve types `PSA_ECC_FAMILY_SECTXXX`, `PSA_ECC_FAMILY_SECPXXX`\n   and `PSA_ECC_FAMILY_BRAINPOOL_PXXX`).\n   For Weierstrass curves, this is the content of the `privateKey` field of\n   the `ECPrivateKey` format defined by RFC 5915.  For Montgomery curves,\n   the format is defined by RFC 7748, and output is masked according to 5.\n   For twisted Edwards curves, the private key is as defined by RFC 8032\n   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).\n - For Diffie-Hellman key exchange key pairs (key types for which\n   #PSA_KEY_TYPE_IS_DH_KEY_PAIR is true), the\n   format is the representation of the private key `x` as a big-endian byte\n   string. The length of the byte string is the private key size in bytes\n   (leading zeroes are not stripped).\n - For public keys (key types for which #PSA_KEY_TYPE_IS_PUBLIC_KEY is\n   true), the format is the same as for psa_export_public_key().\n\n The policy on the key must have the usage flag #PSA_KEY_USAGE_EXPORT set.\n\n \\param key               Identifier of the key to export. It must allow the\n                          usage #PSA_KEY_USAGE_EXPORT, unless it is a public\n                          key.\n \\param[out] data         Buffer where the key data is to be written.\n \\param data_size         Size of the \\p data buffer in bytes.\n \\param[out] data_length  On success, the number of bytes\n                          that make up the key data.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_EXPORT flag.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p data buffer is too small. You can determine a\n         sufficient buffer size by calling\n         #PSA_EXPORT_KEY_OUTPUT_SIZE(\\c type, \\c bits)\n         where \\c type is the key type\n         and \\c bits is the key size in bits.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_export_key(
		key: mbedtls_svc_key_id_t,
		data: *mut u8,
		data_size: usize,
		data_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Export a public key or the public part of a key pair in binary format.\n\n The output of this function can be passed to psa_import_key() to\n create an object that is equivalent to the public key.\n\n This specification supports a single format for each key type.\n Implementations may support other formats as long as the standard\n format is supported. Implementations that support other formats\n should ensure that the formats are clearly unambiguous so as to\n minimize the risk that an invalid input is accidentally interpreted\n according to a different format.\n\n For standard key types, the output format is as follows:\n - For RSA public keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY), the DER encoding of\n   the representation defined by RFC 3279 &sect;2.3.1 as `RSAPublicKey`.\n   ```\n   RSAPublicKey ::= SEQUENCE {\n      modulus            INTEGER,    -- n\n      publicExponent     INTEGER  }  -- e\n   ```\n - For elliptic curve keys on a twisted Edwards curve (key types for which\n   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true and #PSA_KEY_TYPE_ECC_GET_FAMILY\n   returns #PSA_ECC_FAMILY_TWISTED_EDWARDS), the public key is as defined\n   by RFC 8032\n   (a 32-byte string for Edwards25519, a 57-byte string for Edwards448).\n - For other elliptic curve public keys (key types for which\n   #PSA_KEY_TYPE_IS_ECC_PUBLIC_KEY is true), the format is the uncompressed\n   representation defined by SEC1 &sect;2.3.3 as the content of an ECPoint.\n   Let `m` be the bit size associated with the curve, i.e. the bit size of\n   `q` for a curve over `F_q`. The representation consists of:\n      - The byte 0x04;\n      - `x_P` as a `ceiling(m/8)`-byte string, big-endian;\n      - `y_P` as a `ceiling(m/8)`-byte string, big-endian.\n - For Diffie-Hellman key exchange public keys (key types for which\n   #PSA_KEY_TYPE_IS_DH_PUBLIC_KEY is true),\n   the format is the representation of the public key `y = g^x mod p` as a\n   big-endian byte string. The length of the byte string is the length of the\n   base prime `p` in bytes.\n\n Exporting a public key object or the public part of a key pair is\n always permitted, regardless of the key's usage flags.\n\n \\param key               Identifier of the key to export.\n \\param[out] data         Buffer where the key data is to be written.\n \\param data_size         Size of the \\p data buffer in bytes.\n \\param[out] data_length  On success, the number of bytes\n                          that make up the key data.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key is neither a public key nor a key pair.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p data buffer is too small. You can determine a\n         sufficient buffer size by calling\n         #PSA_EXPORT_KEY_OUTPUT_SIZE(#PSA_KEY_TYPE_PUBLIC_KEY_OF_KEY_PAIR(\\c type), \\c bits)\n         where \\c type is the key type\n         and \\c bits is the key size in bits.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_export_public_key(
		key: mbedtls_svc_key_id_t,
		data: *mut u8,
		data_size: usize,
		data_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Calculate the hash (digest) of a message.\n\n \\note To verify the hash of a message against an\n       expected value, use psa_hash_compare() instead.\n\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n \\param[in] input         Buffer containing the message to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] hash         Buffer where the hash is to be written.\n \\param hash_size         Size of the \\p hash buffer in bytes.\n \\param[out] hash_length  On success, the number of bytes\n                          that make up the hash value. This is always\n                          #PSA_HASH_LENGTH(\\p alg).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p hash_size is too small\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_compute(
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		hash: *mut u8,
		hash_size: usize,
		hash_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Calculate the hash (digest) of a message and compare it with a\n reference value.\n\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n \\param[in] input         Buffer containing the message to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] hash         Buffer containing the expected hash value.\n \\param hash_length       Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected hash is identical to the actual hash of the input.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The hash of the message was calculated successfully, but it\n         differs from the expected hash.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p input_length or \\p hash_length do not match the hash size for \\p alg\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_compare(
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		hash: *const u8,
		hash_length: usize,
	) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart hash operations.\n\n Before calling any function on a hash operation object, the application must\n initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_hash_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_hash_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_HASH_OPERATION_INIT,\n   for example:\n   \\code\n   psa_hash_operation_t operation = PSA_HASH_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_hash_operation_init()\n   to the structure, for example:\n   \\code\n   psa_hash_operation_t operation;\n   operation = psa_hash_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_hash_operation_t = psa_hash_operation_s;
extern "C" {
	#[doc = " Set up a multipart hash operation.\n\n The sequence of operations to calculate a hash (message digest)\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_hash_operation_t, e.g. #PSA_HASH_OPERATION_INIT.\n -# Call psa_hash_setup() to specify the algorithm.\n -# Call psa_hash_update() zero, one or more times, passing a fragment\n    of the message each time. The hash that is calculated is the hash\n    of the concatenation of these messages in order.\n -# To calculate the hash, call psa_hash_finish().\n    To compare the hash with an expected value, call psa_hash_verify().\n\n If an error occurs at any step after a call to psa_hash_setup(), the\n operation will need to be reset by a call to psa_hash_abort(). The\n application may call psa_hash_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_hash_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_hash_finish() or psa_hash_verify().\n - A call to psa_hash_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_hash_operation_t and not yet in use.\n \\param alg               The hash algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_HASH(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not a supported hash algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p alg is not a hash algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_setup(
		operation: *mut psa_hash_operation_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Add a message fragment to a multipart hash operation.\n\n The application must call psa_hash_setup() before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\param[in,out] operation Active hash operation.\n \\param[in] input         Buffer containing the message fragment to hash.\n \\param input_length      Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_update(
		operation: *mut psa_hash_operation_t,
		input: *const u8,
		input_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Finish the calculation of the hash of a message.\n\n The application must call psa_hash_setup() before calling this function.\n This function calculates the hash of the message formed by concatenating\n the inputs passed to preceding calls to psa_hash_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\warning Applications should not call this function if they expect\n          a specific value for the hash. Call psa_hash_verify() instead.\n          Beware that comparing integrity or authenticity data such as\n          hash values with a function such as \\c memcmp is risky\n          because the time taken by the comparison may leak information\n          about the hashed data which could allow an attacker to guess\n          a valid hash and thereby bypass security controls.\n\n \\param[in,out] operation     Active hash operation.\n \\param[out] hash             Buffer where the hash is to be written.\n \\param hash_size             Size of the \\p hash buffer in bytes.\n \\param[out] hash_length      On success, the number of bytes\n                              that make up the hash value. This is always\n                              #PSA_HASH_LENGTH(\\c alg) where \\c alg is the\n                              hash algorithm that is calculated.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p hash buffer is too small. You can determine a\n         sufficient buffer size by calling #PSA_HASH_LENGTH(\\c alg)\n         where \\c alg is the hash algorithm that is calculated.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_finish(
		operation: *mut psa_hash_operation_t,
		hash: *mut u8,
		hash_size: usize,
		hash_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Finish the calculation of the hash of a message and compare it with\n an expected value.\n\n The application must call psa_hash_setup() before calling this function.\n This function calculates the hash of the message formed by concatenating\n the inputs passed to preceding calls to psa_hash_update(). It then\n compares the calculated hash with the expected hash passed as a\n parameter to this function.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_hash_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual hash and the expected hash is performed\n in constant time.\n\n \\param[in,out] operation     Active hash operation.\n \\param[in] hash              Buffer containing the expected hash value.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected hash is identical to the actual hash of the message.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The hash of the message was calculated successfully, but it\n         differs from the expected hash.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_verify(
		operation: *mut psa_hash_operation_t,
		hash: *const u8,
		hash_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Abort a hash operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_hash_setup() again.\n\n You may call this function any time after the operation object has\n been initialized by one of the methods described in #psa_hash_operation_t.\n\n In particular, calling psa_hash_abort() after the operation has been\n terminated by a call to psa_hash_abort(), psa_hash_finish() or\n psa_hash_verify() is safe and has no effect.\n\n \\param[in,out] operation     Initialized hash operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_abort(operation: *mut psa_hash_operation_t) -> psa_status_t;
}
extern "C" {
	#[doc = " Clone a hash operation.\n\n This function copies the state of an ongoing hash operation to\n a new operation object. In other words, this function is equivalent\n to calling psa_hash_setup() on \\p target_operation with the same\n algorithm that \\p source_operation was set up for, then\n psa_hash_update() on \\p target_operation with the same input that\n that was passed to \\p source_operation. After this function returns, the\n two objects are independent, i.e. subsequent calls involving one of\n the objects do not affect the other object.\n\n \\param[in] source_operation      The active hash operation to clone.\n \\param[in,out] target_operation  The operation object to set up.\n                                  It must be initialized but not active.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The \\p source_operation state is not valid (it must be active), or\n         the \\p target_operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_hash_clone(
		source_operation: *const psa_hash_operation_t,
		target_operation: *mut psa_hash_operation_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Calculate the MAC (message authentication code) of a message.\n\n \\note To verify the MAC of a message against an\n       expected value, use psa_mac_verify() instead.\n       Beware that comparing integrity or authenticity data such as\n       MAC values with a function such as \\c memcmp is risky\n       because the time taken by the comparison may leak information\n       about the MAC value which could allow an attacker to guess\n       a valid MAC and thereby bypass security controls.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n \\param[in] input         Buffer containing the input message.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] mac          Buffer where the MAC value is to be written.\n \\param mac_size          Size of the \\p mac buffer in bytes.\n \\param[out] mac_length   On success, the number of bytes\n                          that make up the MAC value.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p mac_size is too small\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_compute(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		mac: *mut u8,
		mac_size: usize,
		mac_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Calculate the MAC of a message and compare it with a reference value.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must allow the usage PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n \\param[in] input         Buffer containing the input message.\n \\param input_length      Size of the \\p input buffer in bytes.\n \\param[out] mac          Buffer containing the expected MAC value.\n \\param mac_length        Size of the \\p mac buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected MAC is identical to the actual MAC of the input.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The MAC of the message was calculated successfully, but it\n         differs from the expected value.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_verify(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		mac: *const u8,
		mac_length: usize,
	) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart MAC operations.\n\n Before calling any function on a MAC operation object, the application must\n initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_mac_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_mac_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_MAC_OPERATION_INIT,\n   for example:\n   \\code\n   psa_mac_operation_t operation = PSA_MAC_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_mac_operation_init()\n   to the structure, for example:\n   \\code\n   psa_mac_operation_t operation;\n   operation = psa_mac_operation_init();\n   \\endcode\n\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_mac_operation_t = psa_mac_operation_s;
extern "C" {
	#[doc = " Set up a multipart MAC calculation operation.\n\n This function sets up the calculation of the MAC\n (message authentication code) of a byte string.\n To verify the MAC of a message against an\n expected value, use psa_mac_verify_setup() instead.\n\n The sequence of operations to calculate a MAC is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.\n -# Call psa_mac_sign_setup() to specify the algorithm and key.\n -# Call psa_mac_update() zero, one or more times, passing a fragment\n    of the message each time. The MAC that is calculated is the MAC\n    of the concatenation of these messages in order.\n -# At the end of the message, call psa_mac_sign_finish() to finish\n    calculating the MAC value and retrieve it.\n\n If an error occurs at any step after a call to psa_mac_sign_setup(), the\n operation will need to be reset by a call to psa_mac_abort(). The\n application may call psa_mac_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_mac_sign_setup(), the application must\n eventually terminate the operation through one of the following methods:\n - A successful call to psa_mac_sign_finish().\n - A call to psa_mac_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_mac_operation_t and not yet in use.\n \\param key               Identifier of the key to use for the operation. It\n                          must remain valid until the operation terminates.\n                          It must allow the usage PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_sign_setup(
		operation: *mut psa_mac_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set up a multipart MAC verification operation.\n\n This function sets up the verification of the MAC\n (message authentication code) of a byte string against an expected value.\n\n The sequence of operations to verify a MAC is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_mac_operation_t, e.g. #PSA_MAC_OPERATION_INIT.\n -# Call psa_mac_verify_setup() to specify the algorithm and key.\n -# Call psa_mac_update() zero, one or more times, passing a fragment\n    of the message each time. The MAC that is calculated is the MAC\n    of the concatenation of these messages in order.\n -# At the end of the message, call psa_mac_verify_finish() to finish\n    calculating the actual MAC of the message and verify it against\n    the expected value.\n\n If an error occurs at any step after a call to psa_mac_verify_setup(), the\n operation will need to be reset by a call to psa_mac_abort(). The\n application may call psa_mac_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_mac_verify_setup(), the application must\n eventually terminate the operation through one of the following methods:\n - A successful call to psa_mac_verify_finish().\n - A call to psa_mac_abort().\n\n \\param[in,out] operation The operation object to set up. It must have\n                          been initialized as per the documentation for\n                          #psa_mac_operation_t and not yet in use.\n \\param key               Identifier of the key to use for the operation. It\n                          must remain valid until the operation terminates.\n                          It must allow the usage\n                          PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param alg               The MAC algorithm to compute (\\c PSA_ALG_XXX value\n                          such that #PSA_ALG_IS_MAC(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c key is not compatible with \\c alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a MAC algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The key could not be retrieved from storage.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_verify_setup(
		operation: *mut psa_mac_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Add a message fragment to a multipart MAC operation.\n\n The application must call psa_mac_sign_setup() or psa_mac_verify_setup()\n before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\param[in,out] operation Active MAC operation.\n \\param[in] input         Buffer containing the message fragment to add to\n                          the MAC calculation.\n \\param input_length      Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_update(
		operation: *mut psa_mac_operation_t,
		input: *const u8,
		input_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Finish the calculation of the MAC of a message.\n\n The application must call psa_mac_sign_setup() before calling this function.\n This function calculates the MAC of the message formed by concatenating\n the inputs passed to preceding calls to psa_mac_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\warning Applications should not call this function if they expect\n          a specific value for the MAC. Call psa_mac_verify_finish() instead.\n          Beware that comparing integrity or authenticity data such as\n          MAC values with a function such as \\c memcmp is risky\n          because the time taken by the comparison may leak information\n          about the MAC value which could allow an attacker to guess\n          a valid MAC and thereby bypass security controls.\n\n \\param[in,out] operation Active MAC operation.\n \\param[out] mac          Buffer where the MAC value is to be written.\n \\param mac_size          Size of the \\p mac buffer in bytes.\n \\param[out] mac_length   On success, the number of bytes\n                          that make up the MAC value. This is always\n                          #PSA_MAC_LENGTH(\\c key_type, \\c key_bits, \\c alg)\n                          where \\c key_type and \\c key_bits are the type and\n                          bit-size respectively of the key and \\c alg is the\n                          MAC algorithm that is calculated.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p mac buffer is too small. You can determine a\n         sufficient buffer size by calling PSA_MAC_LENGTH().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active mac sign\n         operation), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_sign_finish(
		operation: *mut psa_mac_operation_t,
		mac: *mut u8,
		mac_size: usize,
		mac_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Finish the calculation of the MAC of a message and compare it with\n an expected value.\n\n The application must call psa_mac_verify_setup() before calling this function.\n This function calculates the MAC of the message formed by concatenating\n the inputs passed to preceding calls to psa_mac_update(). It then\n compares the calculated MAC with the expected MAC passed as a\n parameter to this function.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_mac_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual MAC and the expected MAC is performed\n in constant time.\n\n \\param[in,out] operation Active MAC operation.\n \\param[in] mac           Buffer containing the expected MAC value.\n \\param mac_length        Size of the \\p mac buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The expected MAC is identical to the actual MAC of the message.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The MAC of the message was calculated successfully, but it\n         differs from the expected MAC.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active mac verify\n         operation), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_verify_finish(
		operation: *mut psa_mac_operation_t,
		mac: *const u8,
		mac_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Abort a MAC operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_mac_sign_setup() or psa_mac_verify_setup() again.\n\n You may call this function any time after the operation object has\n been initialized by one of the methods described in #psa_mac_operation_t.\n\n In particular, calling psa_mac_abort() after the operation has been\n terminated by a call to psa_mac_abort(), psa_mac_sign_finish() or\n psa_mac_verify_finish() is safe and has no effect.\n\n \\param[in,out] operation Initialized MAC operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_mac_abort(operation: *mut psa_mac_operation_t) -> psa_status_t;
}
extern "C" {
	#[doc = " Encrypt a message using a symmetric cipher.\n\n This function encrypts a message with a random IV (initialization\n vector). Use the multipart operation interface with a\n #psa_cipher_operation_t object to provide other forms of IV.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must allow the usage #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n \\param[in] input             Buffer containing the message to encrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n                              The output contains the IV followed by\n                              the ciphertext proper.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_encrypt(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Decrypt a message using a symmetric cipher.\n\n This function decrypts a message encrypted with a symmetric cipher.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n \\param[in] input             Buffer containing the message to decrypt.\n                              This consists of the IV followed by the\n                              ciphertext proper.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the plaintext is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_decrypt(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart cipher operations.\n\n Before calling any function on a cipher operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_cipher_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_cipher_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_CIPHER_OPERATION_INIT,\n   for example:\n   \\code\n   psa_cipher_operation_t operation = PSA_CIPHER_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_cipher_operation_init()\n   to the structure, for example:\n   \\code\n   psa_cipher_operation_t operation;\n   operation = psa_cipher_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_cipher_operation_t = psa_cipher_operation_s;
extern "C" {
	#[doc = " Set the key for a multipart symmetric encryption operation.\n\n The sequence of operations to encrypt a message with a symmetric cipher\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_cipher_operation_t, e.g.\n    #PSA_CIPHER_OPERATION_INIT.\n -# Call psa_cipher_encrypt_setup() to specify the algorithm and key.\n -# Call either psa_cipher_generate_iv() or psa_cipher_set_iv() to\n    generate or set the IV (initialization vector). You should use\n    psa_cipher_generate_iv() unless the protocol you are implementing\n    requires a specific IV value.\n -# Call psa_cipher_update() zero, one or more times, passing a fragment\n    of the message each time.\n -# Call psa_cipher_finish().\n\n If an error occurs at any step after a call to psa_cipher_encrypt_setup(),\n the operation will need to be reset by a call to psa_cipher_abort(). The\n application may call psa_cipher_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_cipher_encrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_cipher_finish().\n - A call to psa_cipher_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_cipher_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_encrypt_setup(
		operation: *mut psa_cipher_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the key for a multipart symmetric decryption operation.\n\n The sequence of operations to decrypt a message with a symmetric cipher\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_cipher_operation_t, e.g.\n    #PSA_CIPHER_OPERATION_INIT.\n -# Call psa_cipher_decrypt_setup() to specify the algorithm and key.\n -# Call psa_cipher_set_iv() with the IV (initialization vector) for the\n    decryption. If the IV is prepended to the ciphertext, you can call\n    psa_cipher_update() on a buffer containing the IV followed by the\n    beginning of the message.\n -# Call psa_cipher_update() zero, one or more times, passing a fragment\n    of the message each time.\n -# Call psa_cipher_finish().\n\n If an error occurs at any step after a call to psa_cipher_decrypt_setup(),\n the operation will need to be reset by a call to psa_cipher_abort(). The\n application may call psa_cipher_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_cipher_decrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_cipher_finish().\n - A call to psa_cipher_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_cipher_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The cipher algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_CIPHER(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not a cipher algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_decrypt_setup(
		operation: *mut psa_cipher_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Generate an IV for a symmetric encryption operation.\n\n This function generates a random IV (initialization vector), nonce\n or initial counter value for the encryption operation as appropriate\n for the chosen algorithm, key type and key size.\n\n The application must call psa_cipher_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[out] iv               Buffer where the generated IV is to be written.\n \\param iv_size               Size of the \\p iv buffer in bytes.\n \\param[out] iv_length        On success, the number of bytes of the\n                              generated IV.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p iv buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with no IV set),\n         or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_generate_iv(
		operation: *mut psa_cipher_operation_t,
		iv: *mut u8,
		iv_size: usize,
		iv_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the IV for a symmetric encryption or decryption operation.\n\n This function sets the IV (initialization vector), nonce\n or initial counter value for the encryption or decryption operation.\n\n The application must call psa_cipher_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\note When encrypting, applications should use psa_cipher_generate_iv()\n instead of this function, unless implementing a protocol that requires\n a non-random IV.\n\n \\param[in,out] operation     Active cipher operation.\n \\param[in] iv                Buffer containing the IV to use.\n \\param iv_length             Size of the IV in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The size of \\p iv is not acceptable for the chosen algorithm,\n         or the chosen algorithm does not use an IV.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active cipher\n         encrypt operation, with no IV set), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_set_iv(
		operation: *mut psa_cipher_operation_t,
		iv: *const u8,
		iv_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Encrypt or decrypt a message fragment in an active cipher operation.\n\n Before calling this function, you must:\n 1. Call either psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup().\n    The choice of setup function determines whether this function\n    encrypts or decrypts its input.\n 2. If the algorithm requires an IV, call psa_cipher_generate_iv()\n    (recommended when encrypting) or psa_cipher_set_iv().\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[in] input             Buffer containing the message fragment to\n                              encrypt or decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with an IV set\n         if required for the algorithm), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_update(
		operation: *mut psa_cipher_operation_t,
		input: *const u8,
		input_length: usize,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Finish encrypting or decrypting a message in a cipher operation.\n\n The application must call psa_cipher_encrypt_setup() or\n psa_cipher_decrypt_setup() before calling this function. The choice\n of setup function determines whether this function encrypts or\n decrypts its input.\n\n This function finishes the encryption or decryption of the message\n formed by concatenating the inputs passed to preceding calls to\n psa_cipher_update().\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_cipher_abort().\n\n \\param[in,out] operation     Active cipher operation.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total input size passed to this operation is not valid for\n         this particular algorithm. For example, the algorithm is a based\n         on block cipher and requires a whole number of blocks, but the\n         total input size is not a multiple of the block size.\n \\retval #PSA_ERROR_INVALID_PADDING\n         This is a decryption operation for an algorithm that includes\n         padding, and the ciphertext does not contain valid padding.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with an IV set\n         if required for the algorithm), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_finish(
		operation: *mut psa_cipher_operation_t,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Abort a cipher operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_cipher_encrypt_setup() or psa_cipher_decrypt_setup() again.\n\n You may call this function any time after the operation object has\n been initialized as described in #psa_cipher_operation_t.\n\n In particular, calling psa_cipher_abort() after the operation has been\n terminated by a call to psa_cipher_abort() or psa_cipher_finish()\n is safe and has no effect.\n\n \\param[in,out] operation     Initialized cipher operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_cipher_abort(operation: *mut psa_cipher_operation_t) -> psa_status_t;
}
extern "C" {
	#[doc = " Process an authenticated encryption operation.\n\n \\param key                     Identifier of the key to use for the\n                                operation. It must allow the usage\n                                #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                     The AEAD algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_AEAD(\\p alg) is true).\n \\param[in] nonce               Nonce or IV to use.\n \\param nonce_length            Size of the \\p nonce buffer in bytes.\n \\param[in] additional_data     Additional data that will be authenticated\n                                but not encrypted.\n \\param additional_data_length  Size of \\p additional_data in bytes.\n \\param[in] plaintext           Data that will be authenticated and\n                                encrypted.\n \\param plaintext_length        Size of \\p plaintext in bytes.\n \\param[out] ciphertext         Output buffer for the authenticated and\n                                encrypted data. The additional data is not\n                                part of this output. For algorithms where the\n                                encrypted data and the authentication tag\n                                are defined as separate outputs, the\n                                authentication tag is appended to the\n                                encrypted data.\n \\param ciphertext_size         Size of the \\p ciphertext buffer in bytes.\n                                This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type,\n                                  \\p alg, \\p plaintext_length) where\n                                  \\c key_type is the type of \\p key.\n                                - #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p\n                                  plaintext_length) evaluates to the maximum\n                                  ciphertext size of any supported AEAD\n                                  encryption.\n \\param[out] ciphertext_length  On success, the size of the output\n                                in the \\p ciphertext buffer.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p ciphertext_size is too small.\n         #PSA_AEAD_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,\n         \\p plaintext_length) or\n         #PSA_AEAD_ENCRYPT_OUTPUT_MAX_SIZE(\\p plaintext_length) can be used to\n         determine the required buffer size.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_encrypt(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		nonce: *const u8,
		nonce_length: usize,
		additional_data: *const u8,
		additional_data_length: usize,
		plaintext: *const u8,
		plaintext_length: usize,
		ciphertext: *mut u8,
		ciphertext_size: usize,
		ciphertext_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Process an authenticated decryption operation.\n\n \\param key                     Identifier of the key to use for the\n                                operation. It must allow the usage\n                                #PSA_KEY_USAGE_DECRYPT.\n \\param alg                     The AEAD algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_AEAD(\\p alg) is true).\n \\param[in] nonce               Nonce or IV to use.\n \\param nonce_length            Size of the \\p nonce buffer in bytes.\n \\param[in] additional_data     Additional data that has been authenticated\n                                but not encrypted.\n \\param additional_data_length  Size of \\p additional_data in bytes.\n \\param[in] ciphertext          Data that has been authenticated and\n                                encrypted. For algorithms where the\n                                encrypted data and the authentication tag\n                                are defined as separate inputs, the buffer\n                                must contain the encrypted data followed\n                                by the authentication tag.\n \\param ciphertext_length       Size of \\p ciphertext in bytes.\n \\param[out] plaintext          Output buffer for the decrypted data.\n \\param plaintext_size          Size of the \\p plaintext buffer in bytes.\n                                This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type,\n                                  \\p alg, \\p ciphertext_length) where\n                                  \\c key_type is the type of \\p key.\n                                - #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p\n                                  ciphertext_length) evaluates to the maximum\n                                  plaintext size of any supported AEAD\n                                  decryption.\n \\param[out] plaintext_length   On success, the size of the output\n                                in the \\p plaintext buffer.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The ciphertext is not authentic.\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p plaintext_size is too small.\n         #PSA_AEAD_DECRYPT_OUTPUT_SIZE(\\c key_type, \\p alg,\n         \\p ciphertext_length) or\n         #PSA_AEAD_DECRYPT_OUTPUT_MAX_SIZE(\\p ciphertext_length) can be used\n         to determine the required buffer size.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_decrypt(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		nonce: *const u8,
		nonce_length: usize,
		additional_data: *const u8,
		additional_data_length: usize,
		ciphertext: *const u8,
		ciphertext_length: usize,
		plaintext: *mut u8,
		plaintext_size: usize,
		plaintext_length: *mut usize,
	) -> psa_status_t;
}
#[doc = " The type of the state data structure for multipart AEAD operations.\n\n Before calling any function on an AEAD operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_aead_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_aead_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_AEAD_OPERATION_INIT,\n   for example:\n   \\code\n   psa_aead_operation_t operation = PSA_AEAD_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_aead_operation_init()\n   to the structure, for example:\n   \\code\n   psa_aead_operation_t operation;\n   operation = psa_aead_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_aead_operation_t = psa_aead_operation_s;
extern "C" {
	#[doc = " Set the key for a multipart authenticated encryption operation.\n\n The sequence of operations to encrypt a message with authentication\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_aead_operation_t, e.g.\n    #PSA_AEAD_OPERATION_INIT.\n -# Call psa_aead_encrypt_setup() to specify the algorithm and key.\n -# If needed, call psa_aead_set_lengths() to specify the length of the\n    inputs to the subsequent calls to psa_aead_update_ad() and\n    psa_aead_update(). See the documentation of psa_aead_set_lengths()\n    for details.\n -# Call either psa_aead_generate_nonce() or psa_aead_set_nonce() to\n    generate or set the nonce. You should use\n    psa_aead_generate_nonce() unless the protocol you are implementing\n    requires a specific nonce value.\n -# Call psa_aead_update_ad() zero, one or more times, passing a fragment\n    of the non-encrypted additional authenticated data each time.\n -# Call psa_aead_update() zero, one or more times, passing a fragment\n    of the message to encrypt each time.\n -# Call psa_aead_finish().\n\n If an error occurs at any step after a call to psa_aead_encrypt_setup(),\n the operation will need to be reset by a call to psa_aead_abort(). The\n application may call psa_aead_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_aead_encrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_aead_finish().\n - A call to psa_aead_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_aead_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   The AEAD algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_AEAD(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_encrypt_setup(
		operation: *mut psa_aead_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the key for a multipart authenticated decryption operation.\n\n The sequence of operations to decrypt a message with authentication\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_aead_operation_t, e.g.\n    #PSA_AEAD_OPERATION_INIT.\n -# Call psa_aead_decrypt_setup() to specify the algorithm and key.\n -# If needed, call psa_aead_set_lengths() to specify the length of the\n    inputs to the subsequent calls to psa_aead_update_ad() and\n    psa_aead_update(). See the documentation of psa_aead_set_lengths()\n    for details.\n -# Call psa_aead_set_nonce() with the nonce for the decryption.\n -# Call psa_aead_update_ad() zero, one or more times, passing a fragment\n    of the non-encrypted additional authenticated data each time.\n -# Call psa_aead_update() zero, one or more times, passing a fragment\n    of the ciphertext to decrypt each time.\n -# Call psa_aead_verify().\n\n If an error occurs at any step after a call to psa_aead_decrypt_setup(),\n the operation will need to be reset by a call to psa_aead_abort(). The\n application may call psa_aead_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_aead_decrypt_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A successful call to psa_aead_verify().\n - A call to psa_aead_abort().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized as per the documentation for\n                              #psa_aead_operation_t and not yet in use.\n \\param key                   Identifier of the key to use for the operation.\n                              It must remain valid until the operation\n                              terminates. It must allow the usage\n                              #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   The AEAD algorithm to compute\n                              (\\c PSA_ALG_XXX value such that\n                              #PSA_ALG_IS_AEAD(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not compatible with \\p alg.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not supported or is not an AEAD algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_decrypt_setup(
		operation: *mut psa_aead_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Generate a random nonce for an authenticated encryption operation.\n\n This function generates a random nonce for the authenticated encryption\n operation with an appropriate size for the chosen algorithm, key type\n and key size.\n\n The application must call psa_aead_encrypt_setup() before\n calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] nonce            Buffer where the generated nonce is to be\n                              written.\n \\param nonce_size            Size of the \\p nonce buffer in bytes.\n \\param[out] nonce_length     On success, the number of bytes of the\n                              generated nonce.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p nonce buffer is too small.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active aead encrypt\n         operation, with no nonce set), or the library has not been\n         previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_generate_nonce(
		operation: *mut psa_aead_operation_t,
		nonce: *mut u8,
		nonce_size: usize,
		nonce_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the nonce for an authenticated encryption or decryption operation.\n\n This function sets the nonce for the authenticated\n encryption or decryption operation.\n\n The application must call psa_aead_encrypt_setup() or\n psa_aead_decrypt_setup() before calling this function.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\note When encrypting, applications should use psa_aead_generate_nonce()\n instead of this function, unless implementing a protocol that requires\n a non-random IV.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] nonce             Buffer containing the nonce to use.\n \\param nonce_length          Size of the nonce in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The size of \\p nonce is not acceptable for the chosen algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, with no nonce\n         set), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_set_nonce(
		operation: *mut psa_aead_operation_t,
		nonce: *const u8,
		nonce_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Declare the lengths of the message and additional data for AEAD.\n\n The application must call this function before calling\n psa_aead_update_ad() or psa_aead_update() if the algorithm for\n the operation requires it. If the algorithm does not require it,\n calling this function is optional, but if this function is called\n then the implementation must enforce the lengths.\n\n You may call this function before or after setting the nonce with\n psa_aead_set_nonce() or psa_aead_generate_nonce().\n\n - For #PSA_ALG_CCM, calling this function is required.\n - For the other AEAD algorithms defined in this specification, calling\n   this function is not required.\n - For vendor-defined algorithm, refer to the vendor documentation.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param ad_length             Size of the non-encrypted additional\n                              authenticated data in bytes.\n \\param plaintext_length      Size of the plaintext to encrypt in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         At least one of the lengths is not acceptable for the chosen\n         algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and\n         psa_aead_update_ad() and psa_aead_update() must not have been\n         called yet), or the library has not been previously initialized\n         by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_set_lengths(
		operation: *mut psa_aead_operation_t,
		ad_length: usize,
		plaintext_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Pass additional data to an active AEAD operation.\n\n Additional data is authenticated, but not encrypted.\n\n You may call this function multiple times to pass successive fragments\n of the additional data. You may not call this function after passing\n data to encrypt or decrypt with psa_aead_update().\n\n Before calling this function, you must:\n 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().\n 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,\n          there is no guarantee that the input is valid. Therefore, until\n          you have called psa_aead_verify() and it has returned #PSA_SUCCESS,\n          treat the input as untrusted and prepare to undo any action that\n          depends on the input if psa_aead_verify() returns an error status.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] input             Buffer containing the fragment of\n                              additional data.\n \\param input_length          Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total input length overflows the additional data length that\n         was previously specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, have a nonce\n         set, have lengths set if required by the algorithm, and\n         psa_aead_update() must not have been called yet), or the library\n         has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_update_ad(
		operation: *mut psa_aead_operation_t,
		input: *const u8,
		input_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Encrypt or decrypt a message fragment in an active AEAD operation.\n\n Before calling this function, you must:\n 1. Call either psa_aead_encrypt_setup() or psa_aead_decrypt_setup().\n    The choice of setup function determines whether this function\n    encrypts or decrypts its input.\n 2. Set the nonce with psa_aead_generate_nonce() or psa_aead_set_nonce().\n 3. Call psa_aead_update_ad() to pass all the additional data.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\warning When decrypting, until psa_aead_verify() has returned #PSA_SUCCESS,\n          there is no guarantee that the input is valid. Therefore, until\n          you have called psa_aead_verify() and it has returned #PSA_SUCCESS:\n          - Do not use the output in any way other than storing it in a\n            confidential location. If you take any action that depends\n            on the tentative decrypted data, this action will need to be\n            undone if the input turns out not to be valid. Furthermore,\n            if an adversary can observe that this action took place\n            (for example through timing), they may be able to use this\n            fact as an oracle to decrypt any message encrypted with the\n            same key.\n          - In particular, do not copy the output anywhere but to a\n            memory or storage space that you have exclusive access to.\n\n This function does not require the input to be aligned to any\n particular block boundary. If the implementation can only process\n a whole block at a time, it must consume all the input provided, but\n it may delay the end of the corresponding output until a subsequent\n call to psa_aead_update(), psa_aead_finish() or psa_aead_verify()\n provides sufficient input. The amount of data that can be delayed\n in this way is bounded by #PSA_AEAD_UPDATE_OUTPUT_SIZE.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[in] input             Buffer containing the message fragment to\n                              encrypt or decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[out] output           Buffer where the output is to be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n                              This must be appropriate for the selected\n                                algorithm and key:\n                                - A sufficient output size is\n                                  #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type,\n                                  \\c alg, \\p input_length) where\n                                  \\c key_type is the type of key and \\c alg is\n                                  the algorithm that were used to set up the\n                                  operation.\n                                - #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p\n                                  input_length) evaluates to the maximum\n                                  output size of any supported AEAD\n                                  algorithm.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n         #PSA_AEAD_UPDATE_OUTPUT_SIZE(\\c key_type, \\c alg, \\p input_length) or\n         #PSA_AEAD_UPDATE_OUTPUT_MAX_SIZE(\\p input_length) can be used to\n         determine the required buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total input length overflows the plaintext length that\n         was previously specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, have a nonce\n         set, and have lengths set if required by the algorithm), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_update(
		operation: *mut psa_aead_operation_t,
		input: *const u8,
		input_length: usize,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Finish encrypting a message in an AEAD operation.\n\n The operation must have been set up with psa_aead_encrypt_setup().\n\n This function finishes the authentication of the additional data\n formed by concatenating the inputs passed to preceding calls to\n psa_aead_update_ad() with the plaintext formed by concatenating the\n inputs passed to preceding calls to psa_aead_update().\n\n This function has two output buffers:\n - \\p ciphertext contains trailing ciphertext that was buffered from\n   preceding calls to psa_aead_update().\n - \\p tag contains the authentication tag.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] ciphertext       Buffer where the last part of the ciphertext\n                              is to be written.\n \\param ciphertext_size       Size of the \\p ciphertext buffer in bytes.\n                              This must be appropriate for the selected\n                              algorithm and key:\n                              - A sufficient output size is\n                                #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type,\n                                \\c alg) where \\c key_type is the type of key\n                                and \\c alg is the algorithm that were used to\n                                set up the operation.\n                              - #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE evaluates to\n                                the maximum output size of any supported AEAD\n                                algorithm.\n \\param[out] ciphertext_length On success, the number of bytes of\n                              returned ciphertext.\n \\param[out] tag              Buffer where the authentication tag is\n                              to be written.\n \\param tag_size              Size of the \\p tag buffer in bytes.\n                              This must be appropriate for the selected\n                              algorithm and key:\n                              - The exact tag size is #PSA_AEAD_TAG_LENGTH(\\c\n                                key_type, \\c key_bits, \\c alg) where\n                                \\c key_type and \\c key_bits are the type and\n                                bit-size of the key, and \\c alg is the\n                                algorithm that were used in the call to\n                                psa_aead_encrypt_setup().\n                              - #PSA_AEAD_TAG_MAX_SIZE evaluates to the\n                                maximum tag size of any supported AEAD\n                                algorithm.\n \\param[out] tag_length       On success, the number of bytes\n                              that make up the returned tag.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p ciphertext or \\p tag buffer is too small.\n         #PSA_AEAD_FINISH_OUTPUT_SIZE(\\c key_type, \\c alg) or\n         #PSA_AEAD_FINISH_OUTPUT_MAX_SIZE can be used to determine the\n         required \\p ciphertext buffer size. #PSA_AEAD_TAG_LENGTH(\\c key_type,\n         \\c key_bits, \\c alg) or #PSA_AEAD_TAG_MAX_SIZE can be used to\n         determine the required \\p tag buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total length of input to psa_aead_update() so far is\n         less than the plaintext length that was previously\n         specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active encryption\n         operation with a nonce set), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_finish(
		operation: *mut psa_aead_operation_t,
		ciphertext: *mut u8,
		ciphertext_size: usize,
		ciphertext_length: *mut usize,
		tag: *mut u8,
		tag_size: usize,
		tag_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Finish authenticating and decrypting a message in an AEAD operation.\n\n The operation must have been set up with psa_aead_decrypt_setup().\n\n This function finishes the authenticated decryption of the message\n components:\n\n -  The additional data consisting of the concatenation of the inputs\n    passed to preceding calls to psa_aead_update_ad().\n -  The ciphertext consisting of the concatenation of the inputs passed to\n    preceding calls to psa_aead_update().\n -  The tag passed to this function call.\n\n If the authentication tag is correct, this function outputs any remaining\n plaintext and reports success. If the authentication tag is not correct,\n this function returns #PSA_ERROR_INVALID_SIGNATURE.\n\n When this function returns successfully, the operation becomes inactive.\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_aead_abort().\n\n \\note Implementations shall make the best effort to ensure that the\n comparison between the actual tag and the expected tag is performed\n in constant time.\n\n \\param[in,out] operation     Active AEAD operation.\n \\param[out] plaintext        Buffer where the last part of the plaintext\n                              is to be written. This is the remaining data\n                              from previous calls to psa_aead_update()\n                              that could not be processed until the end\n                              of the input.\n \\param plaintext_size        Size of the \\p plaintext buffer in bytes.\n                              This must be appropriate for the selected algorithm and key:\n                              - A sufficient output size is\n                                #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type,\n                                \\c alg) where \\c key_type is the type of key\n                                and \\c alg is the algorithm that were used to\n                                set up the operation.\n                              - #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE evaluates to\n                                the maximum output size of any supported AEAD\n                                algorithm.\n \\param[out] plaintext_length On success, the number of bytes of\n                              returned plaintext.\n \\param[in] tag               Buffer containing the authentication tag.\n \\param tag_length            Size of the \\p tag buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculations were successful, but the authentication tag is\n         not correct.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p plaintext buffer is too small.\n         #PSA_AEAD_VERIFY_OUTPUT_SIZE(\\c key_type, \\c alg) or\n         #PSA_AEAD_VERIFY_OUTPUT_MAX_SIZE can be used to determine the\n         required buffer size.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The total length of input to psa_aead_update_ad() so far is\n         less than the additional data length that was previously\n         specified with psa_aead_set_lengths(), or\n         the total length of input to psa_aead_update() so far is\n         less than the plaintext length that was previously\n         specified with psa_aead_set_lengths().\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be an active decryption\n         operation with a nonce set), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_verify(
		operation: *mut psa_aead_operation_t,
		plaintext: *mut u8,
		plaintext_size: usize,
		plaintext_length: *mut usize,
		tag: *const u8,
		tag_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Abort an AEAD operation.\n\n Aborting an operation frees all associated resources except for the\n \\p operation structure itself. Once aborted, the operation object\n can be reused for another operation by calling\n psa_aead_encrypt_setup() or psa_aead_decrypt_setup() again.\n\n You may call this function any time after the operation object has\n been initialized as described in #psa_aead_operation_t.\n\n In particular, calling psa_aead_abort() after the operation has been\n terminated by a call to psa_aead_abort(), psa_aead_finish() or\n psa_aead_verify() is safe and has no effect.\n\n \\param[in,out] operation     Initialized AEAD operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_aead_abort(operation: *mut psa_aead_operation_t) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Sign a message with a private key. For hash-and-sign algorithms,\n        this includes the hashing step.\n\n \\note To perform a multi-part hash-and-sign signature algorithm, first use\n       a multi-part hash operation and then pass the resulting hash to\n       psa_sign_hash(). PSA_ALG_GET_HASH(\\p alg) can be used to determine the\n       hash algorithm to use.\n\n \\param[in]  key              Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_MESSAGE.\n \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)\n                              is true), that is compatible with the type of\n                              \\p key.\n \\param[in]  input            The input message to sign.\n \\param[in]  input_length     Size of the \\p input buffer in bytes.\n \\param[out] signature        Buffer where the signature is to be written.\n \\param[in]  signature_size   Size of the \\p signature buffer in bytes. This\n                              must be appropriate for the selected\n                              algorithm and key:\n                              - The required signature size is\n                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n                                where \\c key_type and \\c key_bits are the type and\n                                bit-size respectively of key.\n                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the\n                                maximum signature size of any supported\n                                signature algorithm.\n \\param[out] signature_length On success, the number of bytes that make up\n                              the returned signature value.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,\n         or it does not permit the requested algorithm.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_sign_message(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		signature: *mut u8,
		signature_size: usize,
		signature_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Verify the signature of a message with a public key, using\n         a hash-and-sign verification algorithm.\n\n \\note To perform a multi-part hash-and-sign signature verification\n       algorithm, first use a multi-part hash operation to hash the message\n       and then pass the resulting hash to psa_verify_hash().\n       PSA_ALG_GET_HASH(\\p alg) can be used to determine the hash algorithm\n       to use.\n\n \\param[in]  key              Identifier of the key to use for the operation.\n                              It must be a public key or an asymmetric key\n                              pair. The key must allow the usage\n                              #PSA_KEY_USAGE_VERIFY_MESSAGE.\n \\param[in]  alg              An asymmetric signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_MESSAGE(\\p alg)\n                              is true), that is compatible with the type of\n                              \\p key.\n \\param[in]  input            The message whose signature is to be verified.\n \\param[in]  input_length     Size of the \\p input buffer in bytes.\n \\param[out] signature        Buffer containing the signature to verify.\n \\param[in]  signature_length Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_MESSAGE flag,\n         or it does not permit the requested algorithm.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed signature\n         is not a valid signature.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_verify_message(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		signature: *const u8,
		signature_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Sign a hash or short message with a private key.\n\n Note that to perform a hash-and-sign signature algorithm, you must\n first calculate the hash by calling psa_hash_setup(), psa_hash_update()\n and psa_hash_finish(), or alternatively by calling psa_hash_compute().\n Then pass the resulting hash as the \\p hash\n parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)\n to determine the hash algorithm to use.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_HASH.\n \\param alg                   A signature algorithm (PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                              is true), that is compatible with\n                              the type of \\p key.\n \\param[in] hash              The hash or message to sign.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n \\param[out] signature        Buffer where the signature is to be written.\n \\param signature_size        Size of the \\p signature buffer in bytes.\n \\param[out] signature_length On success, the number of bytes\n                              that make up the returned signature value.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_sign_hash(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		hash: *const u8,
		hash_length: usize,
		signature: *mut u8,
		signature_size: usize,
		signature_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Verify the signature of a hash or short message using a public key.\n\n Note that to perform a hash-and-sign signature algorithm, you must\n first calculate the hash by calling psa_hash_setup(), psa_hash_update()\n and psa_hash_finish(), or alternatively by calling psa_hash_compute().\n Then pass the resulting hash as the \\p hash\n parameter to this function. You can use #PSA_ALG_SIGN_GET_HASH(\\p alg)\n to determine the hash algorithm to use.\n\n \\param key               Identifier of the key to use for the operation. It\n                          must be a public key or an asymmetric key pair. The\n                          key must allow the usage\n                          #PSA_KEY_USAGE_VERIFY_HASH.\n \\param alg               A signature algorithm (PSA_ALG_XXX\n                          value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                          is true), that is compatible with\n                          the type of \\p key.\n \\param[in] hash          The hash or message whose signature is to be\n                          verified.\n \\param hash_length       Size of the \\p hash buffer in bytes.\n \\param[in] signature     Buffer containing the signature to verify.\n \\param signature_length  Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The signature is valid.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed\n         signature is not a valid signature.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_verify_hash(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		hash: *const u8,
		hash_length: usize,
		signature: *const u8,
		signature_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Encrypt a short message with a public key.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be a public key or an asymmetric key\n                              pair. It must allow the usage\n                              #PSA_KEY_USAGE_ENCRYPT.\n \\param alg                   An asymmetric encryption algorithm that is\n                              compatible with the type of \\p key.\n \\param[in] input             The message to encrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[in] salt              A salt or label, if supported by the\n                              encryption algorithm.\n                              If the algorithm does not support a\n                              salt, pass \\c NULL.\n                              If the algorithm supports an optional\n                              salt and you do not want to pass a salt,\n                              pass \\c NULL.\n\n                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is\n                                supported.\n \\param salt_length           Size of the \\p salt buffer in bytes.\n                              If \\p salt is \\c NULL, pass 0.\n \\param[out] output           Buffer where the encrypted message is to\n                              be written.\n \\param output_size           Size of the \\p output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_ASYMMETRIC_ENCRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_asymmetric_encrypt(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		salt: *const u8,
		salt_length: usize,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Decrypt a short message with a private key.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. It must\n                              allow the usage #PSA_KEY_USAGE_DECRYPT.\n \\param alg                   An asymmetric encryption algorithm that is\n                              compatible with the type of \\p key.\n \\param[in] input             The message to decrypt.\n \\param input_length          Size of the \\p input buffer in bytes.\n \\param[in] salt              A salt or label, if supported by the\n                              encryption algorithm.\n                              If the algorithm does not support a\n                              salt, pass \\c NULL.\n                              If the algorithm supports an optional\n                              salt and you do not want to pass a salt,\n                              pass \\c NULL.\n\n                              - For #PSA_ALG_RSA_PKCS1V15_CRYPT, no salt is\n                                supported.\n \\param salt_length           Size of the \\p salt buffer in bytes.\n                              If \\p salt is \\c NULL, pass 0.\n \\param[out] output           Buffer where the decrypted message is to\n                              be written.\n \\param output_size           Size of the \\c output buffer in bytes.\n \\param[out] output_length    On success, the number of bytes\n                              that make up the returned output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_ASYMMETRIC_DECRYPT_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\p alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\p key.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_INVALID_PADDING \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_asymmetric_decrypt(
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		input: *const u8,
		input_length: usize,
		salt: *const u8,
		salt_length: usize,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
#[doc = " The type of the state data structure for key derivation operations.\n\n Before calling any function on a key derivation operation object, the\n application must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_key_derivation_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_key_derivation_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_KEY_DERIVATION_OPERATION_INIT,\n   for example:\n   \\code\n   psa_key_derivation_operation_t operation = PSA_KEY_DERIVATION_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_key_derivation_operation_init()\n   to the structure, for example:\n   \\code\n   psa_key_derivation_operation_t operation;\n   operation = psa_key_derivation_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_key_derivation_operation_t = psa_key_derivation_s;
extern "C" {
	#[doc = " Set up a key derivation operation.\n\n A key derivation algorithm takes some inputs and uses them to generate\n a byte stream in a deterministic way.\n This byte stream can be used to produce keys and other\n cryptographic material.\n\n To derive a key:\n -# Start with an initialized object of type #psa_key_derivation_operation_t.\n -# Call psa_key_derivation_setup() to select the algorithm.\n -# Provide the inputs for the key derivation by calling\n    psa_key_derivation_input_bytes() or psa_key_derivation_input_key()\n    as appropriate. Which inputs are needed, in what order, and whether\n    they may be keys and if so of what type depends on the algorithm.\n -# Optionally set the operation's maximum capacity with\n    psa_key_derivation_set_capacity(). You may do this before, in the middle\n    of or after providing inputs. For some algorithms, this step is mandatory\n    because the output depends on the maximum capacity.\n -# To derive a key, call psa_key_derivation_output_key().\n    To derive a byte string for a different purpose, call\n    psa_key_derivation_output_bytes().\n    Successive calls to these functions use successive output bytes\n    calculated by the key derivation algorithm.\n -# Clean up the key derivation operation object with\n    psa_key_derivation_abort().\n\n If this function returns an error, the key derivation operation object is\n not changed.\n\n If an error occurs at any step after a call to psa_key_derivation_setup(),\n the operation will need to be reset by a call to psa_key_derivation_abort().\n\n Implementations must reject an attempt to derive a key of size 0.\n\n \\param[in,out] operation       The key derivation operation object\n                                to set up. It must\n                                have been initialized but not set up yet.\n \\param alg                     The key derivation algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_KEY_DERIVATION(\\p alg) is true).\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c alg is not a key derivation algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a key derivation algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be inactive), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_setup(
		operation: *mut psa_key_derivation_operation_t,
		alg: psa_algorithm_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Retrieve the current capacity of a key derivation operation.\n\n The capacity of a key derivation is the maximum number of bytes that it can\n return. When you get *N* bytes of output from a key derivation operation,\n this reduces its capacity by *N*.\n\n \\param[in] operation     The operation to query.\n \\param[out] capacity     On success, the capacity of the operation.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_get_capacity(
		operation: *const psa_key_derivation_operation_t,
		capacity: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the maximum capacity of a key derivation operation.\n\n The capacity of a key derivation operation is the maximum number of bytes\n that the key derivation operation can return from this point onwards.\n\n \\param[in,out] operation The key derivation operation object to modify.\n \\param capacity          The new capacity of the operation.\n                          It must be less or equal to the operation's\n                          current capacity.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p capacity is larger than the operation's current capacity.\n         In this case, the operation object remains valid and its capacity\n         remains unchanged.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active), or the\n         library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_set_capacity(
		operation: *mut psa_key_derivation_operation_t,
		capacity: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Provide an input for key derivation or key agreement.\n\n Which inputs are required and in what order depends on the algorithm.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function passes direct inputs, which is usually correct for\n non-secret inputs. To pass a secret input, which should be in a key\n object, call psa_key_derivation_input_key() instead of this function.\n Refer to the documentation of individual step types\n (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)\n for more information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param[in] data                Input data to use.\n \\param data_length             Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow direct inputs.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_input_bytes(
		operation: *mut psa_key_derivation_operation_t,
		step: psa_key_derivation_step_t,
		data: *const u8,
		data_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Provide a numeric input for key derivation or key agreement.\n\n Which inputs are required and in what order depends on the algorithm.\n However, when an algorithm requires a particular order, numeric inputs\n usually come first as they tend to be configuration parameters.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function is used for inputs which are fixed-size non-negative\n integers.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param[in] value               The value of the numeric input.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow numeric inputs.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_input_integer(
		operation: *mut psa_key_derivation_operation_t,
		step: psa_key_derivation_step_t,
		value: u64,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Provide an input for key derivation in the form of a key.\n\n Which inputs are required and in what order depends on the algorithm.\n Refer to the documentation of each key derivation or key agreement\n algorithm for information.\n\n This function obtains input from a key object, which is usually correct for\n secret inputs or for non-secret personalization strings kept in the key\n store. To pass a non-secret parameter which is not in the key store,\n call psa_key_derivation_input_bytes() instead of this function.\n Refer to the documentation of individual step types\n (`PSA_KEY_DERIVATION_INPUT_xxx` values of type ::psa_key_derivation_step_t)\n for more information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() and must not\n                                have produced any output yet.\n \\param step                    Which step the input data is for.\n \\param key                     Identifier of the key. It must have an\n                                appropriate type for step and must allow the\n                                usage #PSA_KEY_USAGE_DERIVE or\n                                #PSA_KEY_USAGE_VERIFY_DERIVATION (see note)\n                                and the algorithm used by the operation.\n\n \\note Once all inputs steps are completed, the operations will allow:\n - psa_key_derivation_output_bytes() if each input was either a direct input\n   or  a key with #PSA_KEY_USAGE_DERIVE set;\n - psa_key_derivation_output_key() if the input for step\n   #PSA_KEY_DERIVATION_INPUT_SECRET or #PSA_KEY_DERIVATION_INPUT_PASSWORD\n   was from a key slot with #PSA_KEY_USAGE_DERIVE and each other input was\n   either a direct input or a key with #PSA_KEY_USAGE_DERIVE set;\n - psa_key_derivation_verify_bytes() if each input was either a direct input\n   or  a key with #PSA_KEY_USAGE_VERIFY_DERIVATION set;\n - psa_key_derivation_verify_key() under the same conditions as\n   psa_key_derivation_verify_bytes().\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key allows neither #PSA_KEY_USAGE_DERIVE nor\n         #PSA_KEY_USAGE_VERIFY_DERIVATION, or it doesn't allow this\n         algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c step is not compatible with the operation's algorithm, or\n         \\c step does not allow key inputs of the given type\n         or does not allow key inputs at all.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this input \\p step, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_input_key(
		operation: *mut psa_key_derivation_operation_t,
		step: psa_key_derivation_step_t,
		key: mbedtls_svc_key_id_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Perform a key agreement and use the shared secret as input to a key\n derivation.\n\n A key agreement algorithm takes two inputs: a private key \\p private_key\n a public key \\p peer_key.\n The result of this function is passed as input to a key derivation.\n The output of this key derivation can be extracted by reading from the\n resulting operation to produce keys and other cryptographic material.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation       The key derivation operation object to use.\n                                It must have been set up with\n                                psa_key_derivation_setup() with a\n                                key agreement and derivation algorithm\n                                \\c alg (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_KEY_AGREEMENT(\\c alg) is true\n                                and #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\c alg)\n                                is false).\n                                The operation must be ready for an\n                                input of the type given by \\p step.\n \\param step                    Which step the input data is for.\n \\param private_key             Identifier of the private key to use. It must\n                                allow the usage #PSA_KEY_USAGE_DERIVE.\n \\param[in] peer_key      Public key of the peer. The peer key must be in the\n                          same format that psa_import_key() accepts for the\n                          public key type corresponding to the type of\n                          private_key. That is, this function performs the\n                          equivalent of\n                          #psa_import_key(...,\n                          `peer_key`, `peer_key_length`) where\n                          with key attributes indicating the public key\n                          type corresponding to the type of `private_key`.\n                          For example, for EC keys, this means that peer_key\n                          is interpreted as a point on the curve that the\n                          private key is on. The standard formats for public\n                          keys are documented in the documentation of\n                          psa_export_public_key().\n \\param peer_key_length         Size of \\p peer_key in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\c private_key is not compatible with \\c alg,\n         or \\p peer_key is not valid for \\c alg or not compatible with\n         \\c private_key, or \\c step does not allow an input resulting\n         from a key agreement.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\c alg is not supported or is not a key derivation algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid for this key agreement \\p step,\n         or the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_key_agreement(
		operation: *mut psa_key_derivation_operation_t,
		step: psa_key_derivation_step_t,
		private_key: mbedtls_svc_key_id_t,
		peer_key: *const u8,
		peer_key_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Read some data from a key derivation operation.\n\n This function calculates output bytes from a key derivation algorithm and\n return those bytes.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the requested number of bytes from the\n stream.\n The operation's capacity decreases by the number of bytes read.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[out] output       Buffer where the output will be written.\n \\param output_length     Number of bytes to output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         One of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_DERIVE.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          \\p output_length bytes. Note that in this case,\n                          no output is written to the output buffer.\n                          The operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller output buffer.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_output_bytes(
		operation: *mut psa_key_derivation_operation_t,
		output: *mut u8,
		output_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Derive a key from an ongoing key derivation operation.\n\n This function calculates output bytes from a key derivation algorithm\n and uses those bytes to generate a key deterministically.\n The key's location, usage policy, type and size are taken from\n \\p attributes.\n\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads as many bytes as required from the\n stream.\n The operation's capacity decreases by the number of bytes read.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA, the operation enters an error\n state and must be aborted by calling psa_key_derivation_abort().\n\n How much output is produced and consumed from the operation, and how\n the key is derived, depends on the key type and on the key size\n (denoted \\c bits below):\n\n - For key types for which the key is an arbitrary sequence of bytes\n   of a given size, this function is functionally equivalent to\n   calling #psa_key_derivation_output_bytes\n   and passing the resulting output to #psa_import_key.\n   However, this function has a security benefit:\n   if the implementation provides an isolation boundary then\n   the key material is not exposed outside the isolation boundary.\n   As a consequence, for these key types, this function always consumes\n   exactly (\\c bits / 8) bytes from the operation.\n   The following key types defined in this specification follow this scheme:\n\n     - #PSA_KEY_TYPE_AES;\n     - #PSA_KEY_TYPE_ARIA;\n     - #PSA_KEY_TYPE_CAMELLIA;\n     - #PSA_KEY_TYPE_DERIVE;\n     - #PSA_KEY_TYPE_HMAC;\n     - #PSA_KEY_TYPE_PASSWORD_HASH.\n\n - For ECC keys on a Montgomery elliptic curve\n   (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a\n   Montgomery curve), this function always draws a byte string whose\n   length is determined by the curve, and sets the mandatory bits\n   accordingly. That is:\n\n     - Curve25519 (#PSA_ECC_FAMILY_MONTGOMERY, 255 bits): draw a 32-byte\n       string and process it as specified in RFC 7748 &sect;5.\n     - Curve448 (#PSA_ECC_FAMILY_MONTGOMERY, 448 bits): draw a 56-byte\n       string and process it as specified in RFC 7748 &sect;5.\n\n - For key types for which the key is represented by a single sequence of\n   \\c bits bits with constraints as to which bit sequences are acceptable,\n   this function draws a byte string of length (\\c bits / 8) bytes rounded\n   up to the nearest whole number of bytes. If the resulting byte string\n   is acceptable, it becomes the key, otherwise the drawn bytes are discarded.\n   This process is repeated until an acceptable byte string is drawn.\n   The byte string drawn from the operation is interpreted as specified\n   for the output produced by psa_export_key().\n   The following key types defined in this specification follow this scheme:\n\n     - #PSA_KEY_TYPE_DES.\n       Force-set the parity bits, but discard forbidden weak keys.\n       For 2-key and 3-key triple-DES, the three keys are generated\n       successively (for example, for 3-key triple-DES,\n       if the first 8 bytes specify a weak key and the next 8 bytes do not,\n       discard the first 8 bytes, use the next 8 bytes as the first key,\n       and continue reading output from the operation to derive the other\n       two keys).\n     - Finite-field Diffie-Hellman keys (#PSA_KEY_TYPE_DH_KEY_PAIR(\\c group)\n       where \\c group designates any Diffie-Hellman group) and\n       ECC keys on a Weierstrass elliptic curve\n       (#PSA_KEY_TYPE_ECC_KEY_PAIR(\\c curve) where \\c curve designates a\n       Weierstrass curve).\n       For these key types, interpret the byte string as integer\n       in big-endian order. Discard it if it is not in the range\n       [0, *N* - 2] where *N* is the boundary of the private key domain\n       (the prime *p* for Diffie-Hellman, the subprime *q* for DSA,\n       or the order of the curve's base point for ECC).\n       Add 1 to the resulting integer and use this as the private key *x*.\n       This method allows compliance to NIST standards, specifically\n       the methods titled \"key-pair generation by testing candidates\"\n       in NIST SP 800-56A &sect;5.6.1.1.4 for Diffie-Hellman,\n       in FIPS 186-4 &sect;B.1.2 for DSA, and\n       in NIST SP 800-56A &sect;5.6.1.2.2 or\n       FIPS 186-4 &sect;B.4.2 for elliptic curve keys.\n\n - For other key types, including #PSA_KEY_TYPE_RSA_KEY_PAIR,\n   the way in which the operation output is consumed is\n   implementation-defined.\n\n In all cases, the data that is read is discarded from the operation.\n The operation's capacity is decreased by the number of bytes read.\n\n For algorithms that take an input step #PSA_KEY_DERIVATION_INPUT_SECRET,\n the input to that step must be provided with psa_key_derivation_input_key().\n Future versions of this specification may include additional restrictions\n on the derived key based on the attributes and strength of the secret key.\n\n \\param[in] attributes    The attributes for the new key.\n                          If the key type to be created is\n                          #PSA_KEY_TYPE_PASSWORD_HASH then the algorithm in\n                          the policy must be the same as in the current\n                          operation.\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[out] key          On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n         There was not enough data to create the desired key.\n         Note that in this case, no output is written to the output buffer.\n         The operation's capacity is set to 0, thus subsequent calls to\n         this function will not succeed, even with a smaller output buffer.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size is not supported, either by the\n         implementation in general or in this particular location.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The provided key attributes are not valid for the operation.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The #PSA_KEY_DERIVATION_INPUT_SECRET or\n         #PSA_KEY_DERIVATION_INPUT_PASSWORD input was not provided through a\n         key; or one of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_DERIVE.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_output_key(
		attributes: *const psa_key_attributes_t,
		operation: *mut psa_key_derivation_operation_t,
		key: *mut mbedtls_svc_key_id_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Compare output data from a key derivation operation to an expected value.\n\n This function calculates output bytes from a key derivation algorithm and\n compares those bytes to an expected value in constant time.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the expected number of bytes from the\n stream before comparing them.\n The operation's capacity decreases by the number of bytes read.\n\n This is functionally equivalent to the following code:\n \\code\n psa_key_derivation_output_bytes(operation, tmp, output_length);\n if (memcmp(output, tmp, output_length) != 0)\n     return PSA_ERROR_INVALID_SIGNATURE;\n \\endcode\n except (1) it works even if the key's policy does not allow outputting the\n bytes, and (2) the comparison will be done in constant time.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,\n the operation enters an error state and must be aborted by calling\n psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[in] expected_output Buffer containing the expected derivation output.\n \\param output_length     Length of the expected output; this is also the\n                          number of bytes that will be read.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The output was read successfully, but it differs from the expected\n         output.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         One of the inputs was a key whose policy didn't allow\n         #PSA_KEY_USAGE_VERIFY_DERIVATION.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          \\p output_length bytes. Note that in this case,\n                          the operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller expected output.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_verify_bytes(
		operation: *mut psa_key_derivation_operation_t,
		expected_output: *const u8,
		output_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Compare output data from a key derivation operation to an expected value\n stored in a key object.\n\n This function calculates output bytes from a key derivation algorithm and\n compares those bytes to an expected value, provided as key of type\n #PSA_KEY_TYPE_PASSWORD_HASH.\n If you view the key derivation's output as a stream of bytes, this\n function destructively reads the number of bytes corresponding to the\n length of the expected value from the stream before comparing them.\n The operation's capacity decreases by the number of bytes read.\n\n This is functionally equivalent to exporting the key and calling\n psa_key_derivation_verify_bytes() on the result, except that it\n works even if the key cannot be exported.\n\n If this function returns an error status other than\n #PSA_ERROR_INSUFFICIENT_DATA or #PSA_ERROR_INVALID_SIGNATURE,\n the operation enters an error state and must be aborted by calling\n psa_key_derivation_abort().\n\n \\param[in,out] operation The key derivation operation object to read from.\n \\param[in] expected      A key of type #PSA_KEY_TYPE_PASSWORD_HASH\n                          containing the expected output. Its policy must\n                          include the #PSA_KEY_USAGE_VERIFY_DERIVATION flag\n                          and the permitted algorithm must match the\n                          operation. The value of this key was likely\n                          computed by a previous call to\n                          psa_key_derivation_output_key().\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The output was read successfully, but if differs from the expected\n         output.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         The key passed as the expected value does not exist.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key passed as the expected value has an invalid type.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key passed as the expected value does not allow this usage or\n         this algorithm; or one of the inputs was a key whose policy didn't\n         allow #PSA_KEY_USAGE_VERIFY_DERIVATION.\n \\retval #PSA_ERROR_INSUFFICIENT_DATA\n                          The operation's capacity was less than\n                          the length of the expected value. In this case,\n                          the operation's capacity is set to 0, thus\n                          subsequent calls to this function will not\n                          succeed, even with a smaller expected output.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active and completed\n         all required input steps), or the library has not been previously\n         initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_verify_key(
		operation: *mut psa_key_derivation_operation_t,
		expected: psa_key_id_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Abort a key derivation operation.\n\n Aborting an operation frees all associated resources except for the \\c\n operation structure itself. Once aborted, the operation object can be reused\n for another operation by calling psa_key_derivation_setup() again.\n\n This function may be called at any time after the operation\n object has been initialized as described in #psa_key_derivation_operation_t.\n\n In particular, it is valid to call psa_key_derivation_abort() twice, or to\n call psa_key_derivation_abort() on an operation that has not been set up.\n\n \\param[in,out] operation    The operation to abort.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_key_derivation_abort(operation: *mut psa_key_derivation_operation_t)
		-> psa_status_t;
}
extern "C" {
	#[doc = " Perform a key agreement and return the raw shared secret.\n\n \\warning The raw result of a key agreement algorithm such as finite-field\n Diffie-Hellman or elliptic curve Diffie-Hellman has biases and should\n not be used directly as key material. It should instead be passed as\n input to a key derivation algorithm. To chain a key agreement with\n a key derivation, use psa_key_derivation_key_agreement() and other\n functions from the key derivation interface.\n\n \\param alg                     The key agreement algorithm to compute\n                                (\\c PSA_ALG_XXX value such that\n                                #PSA_ALG_IS_RAW_KEY_AGREEMENT(\\p alg)\n                                is true).\n \\param private_key             Identifier of the private key to use. It must\n                                allow the usage #PSA_KEY_USAGE_DERIVE.\n \\param[in] peer_key            Public key of the peer. It must be\n                                in the same format that psa_import_key()\n                                accepts. The standard formats for public\n                                keys are documented in the documentation\n                                of psa_export_public_key().\n \\param peer_key_length         Size of \\p peer_key in bytes.\n \\param[out] output             Buffer where the decrypted message is to\n                                be written.\n \\param output_size             Size of the \\c output buffer in bytes.\n \\param[out] output_length      On success, the number of bytes\n                                that make up the returned output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p alg is not a key agreement algorithm, or\n         \\p private_key is not compatible with \\p alg,\n         or \\p peer_key is not valid for \\p alg or not compatible with\n         \\p private_key.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         \\p output_size is too small\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p alg is not a supported key agreement algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_raw_key_agreement(
		alg: psa_algorithm_t,
		private_key: mbedtls_svc_key_id_t,
		peer_key: *const u8,
		peer_key_length: usize,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Generate random bytes.\n\n \\warning This function **can** fail! Callers MUST check the return status\n          and MUST NOT use the content of the output buffer if the return\n          status is not #PSA_SUCCESS.\n\n \\note    To generate a key, use psa_generate_key() instead.\n\n \\param[out] output       Output buffer for the generated data.\n \\param output_size       Number of bytes to generate and output.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_generate_random(output: *mut u8, output_size: usize) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Generate a key or key pair.\n\n The key is generated randomly.\n Its location, usage policy, type and size are taken from \\p attributes.\n\n Implementations must reject an attempt to generate a key of size 0.\n\n The following type-specific considerations apply:\n - For RSA keys (#PSA_KEY_TYPE_RSA_KEY_PAIR),\n   the public exponent is 65537.\n   The modulus is a product of two probabilistic primes\n   between 2^{n-1} and 2^n where n is the bit size specified in the\n   attributes.\n\n \\param[in] attributes    The attributes for the new key.\n \\param[out] key          On success, an identifier for the newly created\n                          key. For persistent keys, this is the key\n                          identifier defined in \\p attributes.\n                          \\c 0 on failure.\n\n \\retval #PSA_SUCCESS\n         Success.\n         If the key is persistent, the key material and the key's metadata\n         have been saved to persistent storage.\n \\retval #PSA_ERROR_ALREADY_EXISTS\n         This is an attempt to create a persistent key, and there is\n         already a persistent key with the given identifier.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_STORAGE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_generate_key(
		attributes: *const psa_key_attributes_t,
		key: *mut mbedtls_svc_key_id_t,
	) -> psa_status_t;
}
#[doc = " The type of the state data structure for interruptible hash\n  signing operations.\n\n Before calling any function on a sign hash operation object, the\n application must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer\n   #PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation =\n   PSA_SIGN_HASH_INTERRUPTIBLE_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function\n   psa_sign_hash_interruptible_operation_init() to the structure, for\n   example:\n   \\code\n   psa_sign_hash_interruptible_operation_t operation;\n   operation = psa_sign_hash_interruptible_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_sign_hash_interruptible_operation_t = psa_sign_hash_interruptible_operation_s;
#[doc = " The type of the state data structure for interruptible hash\n  verification operations.\n\n Before calling any function on a sign hash operation object, the\n application must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer\n   #PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT, for example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation =\n   PSA_VERIFY_HASH_INTERRUPTIBLE_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function\n   psa_verify_hash_interruptible_operation_init() to the structure, for\n   example:\n   \\code\n   psa_verify_hash_interruptible_operation_t operation;\n   operation = psa_verify_hash_interruptible_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_verify_hash_interruptible_operation_t = psa_verify_hash_interruptible_operation_s;
extern "C" {
	#[doc = " \\brief                       Set the maximum number of ops allowed to be\n                              executed by an interruptible function in a\n                              single call.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        The time taken to execute a single op is\n                              implementation specific and depends on\n                              software, hardware, the algorithm, key type and\n                              curve chosen. Even within a single operation,\n                              successive ops can take differing amounts of\n                              time. The only guarantee is that lower values\n                              for \\p max_ops means functions will block for a\n                              lesser maximum amount of time. The functions\n                              \\c psa_sign_interruptible_get_num_ops() and\n                              \\c psa_verify_interruptible_get_num_ops() are\n                              provided to help with tuning this value.\n\n \\note                        This value defaults to\n                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, which\n                              means the whole operation will be done in one\n                              go, regardless of the number of ops required.\n\n \\note                        If more ops are needed to complete a\n                              computation, #PSA_OPERATION_INCOMPLETE will be\n                              returned by the function performing the\n                              computation. It is then the caller's\n                              responsibility to either call again with the\n                              same operation context until it returns 0 or an\n                              error code; or to call the relevant abort\n                              function if the answer is no longer required.\n\n \\note                        The interpretation of \\p max_ops is also\n                              implementation defined. On a hard real time\n                              system, this can indicate a hard deadline, as a\n                              real-time system needs a guarantee of not\n                              spending more than X time, however care must be\n                              taken in such an implementation to avoid the\n                              situation whereby calls just return, not being\n                              able to do any actual work within the allotted\n                              time.  On a non-real-time system, the\n                              implementation can be more relaxed, but again\n                              whether this number should be interpreted as as\n                              hard or soft limit or even whether a less than\n                              or equals as regards to ops executed in a\n                              single call is implementation defined.\n\n \\note                        For keys in local storage when no accelerator\n                              driver applies, please see also the\n                              documentation for \\c mbedtls_ecp_set_max_ops(),\n                              which is the internal implementation in these\n                              cases.\n\n \\warning                     With implementations that interpret this number\n                              as a hard limit, setting this number too small\n                              may result in an infinite loop, whereby each\n                              call results in immediate return with no ops\n                              done (as there is not enough time to execute\n                              any), and thus no result will ever be achieved.\n\n \\note                        This only applies to functions whose\n                              documentation mentions they may return\n                              #PSA_OPERATION_INCOMPLETE.\n\n \\param max_ops               The maximum number of ops to be executed in a\n                              single call. This can be a number from 0 to\n                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED, where 0\n                              is the least amount of work done per call."]
	pub fn psa_interruptible_set_max_ops(max_ops: u32);
}
extern "C" {
	#[doc = " \\brief                       Get the maximum number of ops allowed to be\n                              executed by an interruptible function in a\n                              single call. This will return the last\n                              value set by\n                              \\c psa_interruptible_set_max_ops() or\n                              #PSA_INTERRUPTIBLE_MAX_OPS_UNLIMITED if\n                              that function has never been called.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\return                      Maximum number of ops allowed to be\n                              executed by an interruptible function in a\n                              single call."]
	pub fn psa_interruptible_get_max_ops() -> u32;
}
extern "C" {
	#[doc = " \\brief                       Get the number of ops that a hash signing\n                              operation has taken so far. If the operation\n                              has completed, then this will represent the\n                              number of ops required for the entire\n                              operation. After initialization or calling\n                              \\c psa_sign_hash_interruptible_abort() on\n                              the operation, a value of 0 will be returned.\n\n \\note                        This interface is guaranteed re-entrant and\n                              thus may be called from driver code.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n                              This is a helper provided to help you tune the\n                              value passed to \\c\n                              psa_interruptible_set_max_ops().\n\n \\param operation             The \\c psa_sign_hash_interruptible_operation_t\n                              to use. This must be initialized first.\n\n \\return                      Number of ops that the operation has taken so\n                              far."]
	pub fn psa_sign_hash_get_num_ops(
		operation: *const psa_sign_hash_interruptible_operation_t,
	) -> u32;
}
extern "C" {
	#[doc = " \\brief                       Get the number of ops that a hash verification\n                              operation has taken so far. If the operation\n                              has completed, then this will represent the\n                              number of ops required for the entire\n                              operation. After initialization or calling \\c\n                              psa_verify_hash_interruptible_abort() on the\n                              operation, a value of 0 will be returned.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n                              This is a helper provided to help you tune the\n                              value passed to \\c\n                              psa_interruptible_set_max_ops().\n\n \\param operation             The \\c\n                              psa_verify_hash_interruptible_operation_t to\n                              use. This must be initialized first.\n\n \\return                      Number of ops that the operation has taken so\n                              far."]
	pub fn psa_verify_hash_get_num_ops(
		operation: *const psa_verify_hash_interruptible_operation_t,
	) -> u32;
}
extern "C" {
	#[doc = " \\brief                       Start signing a hash or short message with a\n                              private key, in an interruptible manner.\n\n \\see                         \\c psa_sign_hash_complete()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_sign_hash_complete() is equivalent to\n                              \\c psa_sign_hash() but\n                              \\c psa_sign_hash_complete() can return early and\n                              resume according to the limit set with \\c\n                              psa_interruptible_set_max_ops() to reduce the\n                              maximum time spent in a function call.\n\n \\note                        Users should call \\c psa_sign_hash_complete()\n                              repeatedly on the same context after a\n                              successful call to this function until \\c\n                              psa_sign_hash_complete() either returns 0 or an\n                              error. \\c psa_sign_hash_complete() will return\n                              #PSA_OPERATION_INCOMPLETE if there is more work\n                              to do. Alternatively users can call\n                              \\c psa_sign_hash_abort() at any point if they no\n                              longer want the result.\n\n \\note                        If this function returns an error status, the\n                              operation enters an error state and must be\n                              aborted by calling \\c psa_sign_hash_abort().\n\n \\param[in, out] operation    The \\c psa_sign_hash_interruptible_operation_t\n                              to use. This must be initialized first.\n\n \\param key                   Identifier of the key to use for the operation.\n                              It must be an asymmetric key pair. The key must\n                              allow the usage #PSA_KEY_USAGE_SIGN_HASH.\n \\param alg                   A signature algorithm (\\c PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                              is true), that is compatible with\n                              the type of \\p key.\n \\param[in] hash              The hash or message to sign.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The operation started successfully - call \\c psa_sign_hash_complete()\n         with the same context to complete the operation\n\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_SIGN_HASH flag, or it does\n         not permit the requested algorithm.\n \\retval #PSA_ERROR_BAD_STATE\n         An operation has previously been started on this context, and is\n         still in progress.\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_sign_hash_start(
		operation: *mut psa_sign_hash_interruptible_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		hash: *const u8,
		hash_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief                       Continue and eventually complete the action of\n                              signing a hash or short message with a private\n                              key, in an interruptible manner.\n\n \\see                         \\c psa_sign_hash_start()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_sign_hash_start() is equivalent to\n                              \\c psa_sign_hash() but this function can return\n                              early and resume according to the limit set with\n                              \\c psa_interruptible_set_max_ops() to reduce the\n                              maximum time spent in a function call.\n\n \\note                        Users should call this function on the same\n                              operation object repeatedly until it either\n                              returns 0 or an error. This function will return\n                              #PSA_OPERATION_INCOMPLETE if there is more work\n                              to do. Alternatively users can call\n                              \\c psa_sign_hash_abort() at any point if they no\n                              longer want the result.\n\n \\note                        When this function returns successfully, the\n                              operation becomes inactive. If this function\n                              returns an error status, the operation enters an\n                              error state and must be aborted by calling\n                              \\c psa_sign_hash_abort().\n\n \\param[in, out] operation    The \\c psa_sign_hash_interruptible_operation_t\n                              to use. This must be initialized first, and have\n                              had \\c psa_sign_hash_start() called with it\n                              first.\n\n \\param[out] signature        Buffer where the signature is to be written.\n \\param signature_size        Size of the \\p signature buffer in bytes. This\n                              must be appropriate for the selected\n                              algorithm and key:\n                              - The required signature size is\n                                #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c\n                                key_bits, \\c alg) where \\c key_type and \\c\n                                key_bits are the type and bit-size\n                                respectively of key.\n                              - #PSA_SIGNATURE_MAX_SIZE evaluates to the\n                                maximum signature size of any supported\n                                signature algorithm.\n \\param[out] signature_length On success, the number of bytes that make up\n                              the returned signature value.\n\n \\retval #PSA_SUCCESS\n         Operation completed successfully\n\n \\retval #PSA_OPERATION_INCOMPLETE\n         Operation was interrupted due to the setting of \\c\n         psa_interruptible_set_max_ops(). There is still work to be done.\n         Call this function again with the same operation object.\n\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p signature buffer is too small. You can\n         determine a sufficient buffer size by calling\n         #PSA_SIGN_OUTPUT_SIZE(\\c key_type, \\c key_bits, \\c alg)\n         where \\c key_type and \\c key_bits are the type and bit-size\n         respectively of \\c key.\n\n \\retval #PSA_ERROR_BAD_STATE\n         An operation was not previously started on this context via\n         \\c psa_sign_hash_start().\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has either not been previously initialized by\n         psa_crypto_init() or you did not previously call\n         psa_sign_hash_start() with this operation object. It is\n         implementation-dependent whether a failure to initialize results in\n         this error code."]
	pub fn psa_sign_hash_complete(
		operation: *mut psa_sign_hash_interruptible_operation_t,
		signature: *mut u8,
		signature_size: usize,
		signature_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief                       Abort a sign hash operation.\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function is the only function that clears\n                              the number of ops completed as part of the\n                              operation. Please ensure you copy this value via\n                              \\c psa_sign_hash_get_num_ops() if required\n                              before calling.\n\n \\note                        Aborting an operation frees all associated\n                              resources except for the \\p operation structure\n                              itself. Once aborted, the operation object can\n                              be reused for another operation by calling \\c\n                              psa_sign_hash_start() again.\n\n \\note                        You may call this function any time after the\n                              operation object has been initialized. In\n                              particular, calling \\c psa_sign_hash_abort()\n                              after the operation has already been terminated\n                              by a call to \\c psa_sign_hash_abort() or\n                              psa_sign_hash_complete() is safe.\n\n \\param[in,out] operation     Initialized sign hash operation.\n\n \\retval #PSA_SUCCESS\n         The operation was aborted successfully.\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_sign_hash_abort(
		operation: *mut psa_sign_hash_interruptible_operation_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief                       Start reading and verifying a hash or short\n                              message, in an interruptible manner.\n\n \\see                         \\c psa_verify_hash_complete()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_verify_hash_complete() is equivalent to\n                              \\c psa_verify_hash() but \\c\n                              psa_verify_hash_complete() can return early and\n                              resume according to the limit set with \\c\n                              psa_interruptible_set_max_ops() to reduce the\n                              maximum time spent in a function.\n\n \\note                        Users should call \\c psa_verify_hash_complete()\n                              repeatedly on the same operation object after a\n                              successful call to this function until \\c\n                              psa_verify_hash_complete() either returns 0 or\n                              an error. \\c psa_verify_hash_complete() will\n                              return #PSA_OPERATION_INCOMPLETE if there is\n                              more work to do. Alternatively users can call\n                              \\c psa_verify_hash_abort() at any point if they\n                              no longer want the result.\n\n \\note                        If this function returns an error status, the\n                              operation enters an error state and must be\n                              aborted by calling \\c psa_verify_hash_abort().\n\n \\param[in, out] operation    The \\c psa_verify_hash_interruptible_operation_t\n                              to use. This must be initialized first.\n\n \\param key                   Identifier of the key to use for the operation.\n                              The key must allow the usage\n                              #PSA_KEY_USAGE_VERIFY_HASH.\n \\param alg                   A signature algorithm (\\c PSA_ALG_XXX\n                              value such that #PSA_ALG_IS_SIGN_HASH(\\p alg)\n                              is true), that is compatible with\n                              the type of \\p key.\n \\param[in] hash              The hash whose signature is to be verified.\n \\param hash_length           Size of the \\p hash buffer in bytes.\n \\param[in] signature         Buffer containing the signature to verify.\n \\param signature_length      Size of the \\p signature buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         The operation started successfully - please call \\c\n         psa_verify_hash_complete() with the same context to complete the\n         operation.\n\n \\retval #PSA_ERROR_BAD_STATE\n         Another operation has already been started on this context, and is\n         still in progress.\n\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_VERIFY_HASH flag, or it does\n         not permit the requested algorithm.\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_verify_hash_start(
		operation: *mut psa_verify_hash_interruptible_operation_t,
		key: mbedtls_svc_key_id_t,
		alg: psa_algorithm_t,
		hash: *const u8,
		hash_length: usize,
		signature: *const u8,
		signature_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief                       Continue and eventually complete the action of\n                              reading and verifying a hash or short message\n                              signed with a private key, in an interruptible\n                              manner.\n\n \\see                         \\c psa_verify_hash_start()\n\n \\warning                     This is a beta API, and thus subject to change\n                              at any point. It is not bound by the usual\n                              interface stability promises.\n\n \\note                        This function combined with \\c\n                              psa_verify_hash_start() is equivalent to\n                              \\c psa_verify_hash() but this function can\n                              return early and resume according to the limit\n                              set with \\c psa_interruptible_set_max_ops() to\n                              reduce the maximum time spent in a function\n                              call.\n\n \\note                        Users should call this function on the same\n                              operation object repeatedly until it either\n                              returns 0 or an error. This function will return\n                              #PSA_OPERATION_INCOMPLETE if there is more work\n                              to do. Alternatively users can call\n                              \\c psa_verify_hash_abort() at any point if they\n                              no longer want the result.\n\n \\note                        When this function returns successfully, the\n                              operation becomes inactive. If this function\n                              returns an error status, the operation enters an\n                              error state and must be aborted by calling\n                              \\c psa_verify_hash_abort().\n\n \\param[in, out] operation    The \\c psa_verify_hash_interruptible_operation_t\n                              to use. This must be initialized first, and have\n                              had \\c psa_verify_hash_start() called with it\n                              first.\n\n \\retval #PSA_SUCCESS\n         Operation completed successfully, and the passed signature is valid.\n\n \\retval #PSA_OPERATION_INCOMPLETE\n         Operation was interrupted due to the setting of \\c\n         psa_interruptible_set_max_ops(). There is still work to be done.\n         Call this function again with the same operation object.\n\n \\retval #PSA_ERROR_INVALID_HANDLE \\emptydescription\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The calculation was performed successfully, but the passed\n         signature is not a valid signature.\n \\retval #PSA_ERROR_BAD_STATE\n         An operation was not previously started on this context via\n         \\c psa_verify_hash_start().\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_HARDWARE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has either not been previously initialized by\n         psa_crypto_init() or you did not previously call\n         psa_verify_hash_start() on this object. It is\n         implementation-dependent whether a failure to initialize results in\n         this error code."]
	pub fn psa_verify_hash_complete(
		operation: *mut psa_verify_hash_interruptible_operation_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief                     Abort a verify hash operation.\n\n \\warning                   This is a beta API, and thus subject to change at\n                            any point. It is not bound by the usual interface\n                            stability promises.\n\n \\note                      This function is the only function that clears the\n                            number of ops completed as part of the operation.\n                            Please ensure you copy this value via\n                            \\c psa_verify_hash_get_num_ops() if required\n                            before calling.\n\n \\note                      Aborting an operation frees all associated\n                            resources except for the operation structure\n                            itself. Once aborted, the operation object can be\n                            reused for another operation by calling \\c\n                            psa_verify_hash_start() again.\n\n \\note                      You may call this function any time after the\n                            operation object has been initialized.\n                            In particular, calling \\c psa_verify_hash_abort()\n                            after the operation has already been terminated by\n                            a call to \\c psa_verify_hash_abort() or\n                            psa_verify_hash_complete() is safe.\n\n \\param[in,out] operation   Initialized verify hash operation.\n\n \\retval #PSA_SUCCESS\n         The operation was aborted successfully.\n\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_verify_hash_abort(
		operation: *mut psa_verify_hash_interruptible_operation_t,
	) -> psa_status_t;
}
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_DECRYPT: psa_encrypt_or_decrypt_t = 0;
pub const psa_encrypt_or_decrypt_t_PSA_CRYPTO_DRIVER_ENCRYPT: psa_encrypt_or_decrypt_t = 1;
#[doc = " For encrypt-decrypt functions, whether the operation is an encryption\n or a decryption."]
pub type psa_encrypt_or_decrypt_t = ::std::os::raw::c_uint;
#[doc = " \\brief          RIPEMD-160 context structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ripemd160_context {
	pub private_total: [u32; 2usize],
	pub private_state: [u32; 5usize],
	pub private_buffer: [::std::os::raw::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_mbedtls_ripemd160_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_ripemd160_context> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_ripemd160_context>(),
		92usize,
		concat!("Size of: ", stringify!(mbedtls_ripemd160_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_ripemd160_context>(),
		4usize,
		concat!("Alignment of ", stringify!(mbedtls_ripemd160_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_total) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ripemd160_context),
			"::",
			stringify!(private_total)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ripemd160_context),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer) as usize - ptr as usize },
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ripemd160_context),
			"::",
			stringify!(private_buffer)
		)
	);
}
extern "C" {
	#[doc = " \\brief          Initialize RIPEMD-160 context\n\n \\param ctx      RIPEMD-160 context to be initialized"]
	pub fn mbedtls_ripemd160_init(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
	#[doc = " \\brief          Clear RIPEMD-160 context\n\n \\param ctx      RIPEMD-160 context to be cleared"]
	pub fn mbedtls_ripemd160_free(ctx: *mut mbedtls_ripemd160_context);
}
extern "C" {
	#[doc = " \\brief          Clone (the state of) a RIPEMD-160 context\n\n \\param dst      The destination context\n \\param src      The context to be cloned"]
	pub fn mbedtls_ripemd160_clone(
		dst: *mut mbedtls_ripemd160_context,
		src: *const mbedtls_ripemd160_context,
	);
}
extern "C" {
	#[doc = " \\brief          RIPEMD-160 context setup\n\n \\param ctx      context to be initialized\n\n \\return         0 if successful"]
	pub fn mbedtls_ripemd160_starts(ctx: *mut mbedtls_ripemd160_context) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          RIPEMD-160 process buffer\n\n \\param ctx      RIPEMD-160 context\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n\n \\return         0 if successful"]
	pub fn mbedtls_ripemd160_update(
		ctx: *mut mbedtls_ripemd160_context,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          RIPEMD-160 final digest\n\n \\param ctx      RIPEMD-160 context\n \\param output   RIPEMD-160 checksum result\n\n \\return         0 if successful"]
	pub fn mbedtls_ripemd160_finish(
		ctx: *mut mbedtls_ripemd160_context,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          RIPEMD-160 process data block (internal use only)\n\n \\param ctx      RIPEMD-160 context\n \\param data     buffer holding one block of data\n\n \\return         0 if successful"]
	pub fn mbedtls_internal_ripemd160_process(
		ctx: *mut mbedtls_ripemd160_context,
		data: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Output = RIPEMD-160( input buffer )\n\n \\param input    buffer holding the data\n \\param ilen     length of the input data\n \\param output   RIPEMD-160 checksum result\n\n \\return         0 if successful"]
	pub fn mbedtls_ripemd160(
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed"]
	pub fn mbedtls_ripemd160_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " \\brief          The SHA-256 context structure.\n\n                 The structure is used both for SHA-256 and for SHA-224\n                 checksum calculations. The choice between these two is\n                 made in the call to mbedtls_sha256_starts()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha256_context {
	pub private_total: [u32; 2usize],
	pub private_state: [u32; 8usize],
	pub private_buffer: [::std::os::raw::c_uchar; 64usize],
	pub private_is224: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mbedtls_sha256_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_sha256_context> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_sha256_context>(),
		108usize,
		concat!("Size of: ", stringify!(mbedtls_sha256_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_sha256_context>(),
		4usize,
		concat!("Alignment of ", stringify!(mbedtls_sha256_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_total) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha256_context),
			"::",
			stringify!(private_total)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha256_context),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha256_context),
			"::",
			stringify!(private_buffer)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_is224) as usize - ptr as usize },
		104usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha256_context),
			"::",
			stringify!(private_is224)
		)
	);
}
extern "C" {
	#[doc = " \\brief          This function initializes a SHA-256 context.\n\n \\param ctx      The SHA-256 context to initialize. This must not be \\c NULL."]
	pub fn mbedtls_sha256_init(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
	#[doc = " \\brief          This function clears a SHA-256 context.\n\n \\param ctx      The SHA-256 context to clear. This may be \\c NULL, in which\n                 case this function returns immediately. If it is not \\c NULL,\n                 it must point to an initialized SHA-256 context."]
	pub fn mbedtls_sha256_free(ctx: *mut mbedtls_sha256_context);
}
extern "C" {
	#[doc = " \\brief          This function clones the state of a SHA-256 context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The context to clone. This must be initialized."]
	pub fn mbedtls_sha256_clone(
		dst: *mut mbedtls_sha256_context,
		src: *const mbedtls_sha256_context,
	);
}
extern "C" {
	#[doc = " \\brief          This function starts a SHA-224 or SHA-256 checksum\n                 calculation.\n\n \\param ctx      The context to use. This must be initialized.\n \\param is224    This determines which function to use. This must be\n                 either \\c 0 for SHA-256, or \\c 1 for SHA-224.\n\n \\note           is224 must be defined accordingly to the enabled\n                 MBEDTLS_SHA224_C/MBEDTLS_SHA256_C symbols otherwise the\n                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha256_starts(
		ctx: *mut mbedtls_sha256_context,
		is224: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function feeds an input buffer into an ongoing\n                 SHA-256 checksum calculation.\n\n \\param ctx      The SHA-256 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the data. This must be a readable\n                 buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha256_update(
		ctx: *mut mbedtls_sha256_context,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function finishes the SHA-256 operation, and writes\n                 the result to the output buffer.\n\n \\param ctx      The SHA-256 context. This must be initialized\n                 and have a hash operation started.\n \\param output   The SHA-224 or SHA-256 checksum result.\n                 This must be a writable buffer of length \\c 32 bytes\n                 for SHA-256, \\c 28 bytes for SHA-224.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha256_finish(
		ctx: *mut mbedtls_sha256_context,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function processes a single data block within\n                 the ongoing SHA-256 computation. This function is for\n                 internal use only.\n\n \\param ctx      The SHA-256 context. This must be initialized.\n \\param data     The buffer holding one block of data. This must\n                 be a readable buffer of length \\c 64 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_internal_sha256_process(
		ctx: *mut mbedtls_sha256_context,
		data: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function calculates the SHA-224 or SHA-256\n                 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-256 result is calculated as\n                 output = SHA-256(input buffer).\n\n \\param input    The buffer holding the data. This must be a readable\n                 buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n \\param output   The SHA-224 or SHA-256 checksum result.\n                 This must be a writable buffer of length \\c 32 bytes\n                 for SHA-256, \\c 28 bytes for SHA-224.\n \\param is224    Determines which function to use. This must be\n                 either \\c 0 for SHA-256, or \\c 1 for SHA-224.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha256(
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
		is224: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The SHA-224 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_sha224_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The SHA-256 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_sha256_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " \\brief          The SHA-512 context structure.\n\n                 The structure is used both for SHA-384 and for SHA-512\n                 checksum calculations. The choice between these two is\n                 made in the call to mbedtls_sha512_starts()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_sha512_context {
	pub private_total: [u64; 2usize],
	pub private_state: [u64; 8usize],
	pub private_buffer: [::std::os::raw::c_uchar; 128usize],
	pub private_is384: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mbedtls_sha512_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_sha512_context> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_sha512_context>(),
		216usize,
		concat!("Size of: ", stringify!(mbedtls_sha512_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_sha512_context>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_sha512_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_total) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha512_context),
			"::",
			stringify!(private_total)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha512_context),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer) as usize - ptr as usize },
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha512_context),
			"::",
			stringify!(private_buffer)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_is384) as usize - ptr as usize },
		208usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_sha512_context),
			"::",
			stringify!(private_is384)
		)
	);
}
extern "C" {
	#[doc = " \\brief          This function initializes a SHA-512 context.\n\n \\param ctx      The SHA-512 context to initialize. This must\n                 not be \\c NULL."]
	pub fn mbedtls_sha512_init(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
	#[doc = " \\brief          This function clears a SHA-512 context.\n\n \\param ctx      The SHA-512 context to clear. This may be \\c NULL,\n                 in which case this function does nothing. If it\n                 is not \\c NULL, it must point to an initialized\n                 SHA-512 context."]
	pub fn mbedtls_sha512_free(ctx: *mut mbedtls_sha512_context);
}
extern "C" {
	#[doc = " \\brief          This function clones the state of a SHA-512 context.\n\n \\param dst      The destination context. This must be initialized.\n \\param src      The context to clone. This must be initialized."]
	pub fn mbedtls_sha512_clone(
		dst: *mut mbedtls_sha512_context,
		src: *const mbedtls_sha512_context,
	);
}
extern "C" {
	#[doc = " \\brief          This function starts a SHA-384 or SHA-512 checksum\n                 calculation.\n\n \\param ctx      The SHA-512 context to use. This must be initialized.\n \\param is384    Determines which function to use. This must be\n                 either \\c 0 for SHA-512, or \\c 1 for SHA-384.\n\n \\note           is384 must be defined accordingly to the enabled\n                 MBEDTLS_SHA384_C/MBEDTLS_SHA512_C symbols otherwise the\n                 function will return #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha512_starts(
		ctx: *mut mbedtls_sha512_context,
		is384: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function feeds an input buffer into an ongoing\n                 SHA-512 checksum calculation.\n\n \\param ctx      The SHA-512 context. This must be initialized\n                 and have a hash operation started.\n \\param input    The buffer holding the input data. This must\n                 be a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha512_update(
		ctx: *mut mbedtls_sha512_context,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function finishes the SHA-512 operation, and writes\n                 the result to the output buffer.\n\n \\param ctx      The SHA-512 context. This must be initialized\n                 and have a hash operation started.\n \\param output   The SHA-384 or SHA-512 checksum result.\n                 This must be a writable buffer of length \\c 64 bytes\n                 for SHA-512, \\c 48 bytes for SHA-384.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha512_finish(
		ctx: *mut mbedtls_sha512_context,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function processes a single data block within\n                 the ongoing SHA-512 computation.\n                 This function is for internal use only.\n\n \\param ctx      The SHA-512 context. This must be initialized.\n \\param data     The buffer holding one block of data. This\n                 must be a readable buffer of length \\c 128 Bytes.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_internal_sha512_process(
		ctx: *mut mbedtls_sha512_context,
		data: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function calculates the SHA-512 or SHA-384\n                 checksum of a buffer.\n\n                 The function allocates the context, performs the\n                 calculation, and frees the context.\n\n                 The SHA-512 result is calculated as\n                 output = SHA-512(input buffer).\n\n \\param input    The buffer holding the input data. This must be\n                 a readable buffer of length \\p ilen Bytes.\n \\param ilen     The length of the input data in Bytes.\n \\param output   The SHA-384 or SHA-512 checksum result.\n                 This must be a writable buffer of length \\c 64 bytes\n                 for SHA-512, \\c 48 bytes for SHA-384.\n \\param is384    Determines which function to use. This must be either\n                 \\c 0 for SHA-512, or \\c 1 for SHA-384.\n\n \\note           is384 must be defined accordingly with the supported\n                 symbols in the config file. If:\n                 - is384 is 0, but \\c MBEDTLS_SHA384_C is not defined, or\n                 - is384 is 1, but \\c MBEDTLS_SHA512_C is not defined\n                 then the function will return\n                 #MBEDTLS_ERR_SHA512_BAD_INPUT_DATA.\n\n \\return         \\c 0 on success.\n \\return         A negative error code on failure."]
	pub fn mbedtls_sha512(
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
		is384: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The SHA-384 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_sha384_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The SHA-512 checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_sha512_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hash_operation_t {
	pub private_alg: psa_algorithm_t,
	pub private_ctx: mbedtls_psa_hash_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_hash_operation_t__bindgen_ty_1 {
	pub dummy: ::std::os::raw::c_uint,
	pub md5: mbedtls_md5_context,
	pub ripemd160: mbedtls_ripemd160_context,
	pub sha1: mbedtls_sha1_context,
	pub sha256: mbedtls_sha256_context,
	pub sha512: mbedtls_sha512_context,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_hash_operation_t__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_hash_operation_t__bindgen_ty_1> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_hash_operation_t__bindgen_ty_1>(),
		216usize,
		concat!(
			"Size of: ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_hash_operation_t__bindgen_ty_1>(),
		8usize,
		concat!(
			"Alignment of ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).md5) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1),
			"::",
			stringify!(md5)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).ripemd160) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1),
			"::",
			stringify!(ripemd160)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).sha1) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1),
			"::",
			stringify!(sha1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).sha256) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1),
			"::",
			stringify!(sha256)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).sha512) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t__bindgen_ty_1),
			"::",
			stringify!(sha512)
		)
	);
}
#[test]
fn bindgen_test_layout_mbedtls_psa_hash_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_hash_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_hash_operation_t>(),
		224usize,
		concat!("Size of: ", stringify!(mbedtls_psa_hash_operation_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_hash_operation_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_psa_hash_operation_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hash_operation_t),
			"::",
			stringify!(private_ctx)
		)
	);
}
#[doc = "< Placeholder to mark the end of cipher ID lists."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NONE: mbedtls_cipher_id_t = 0;
#[doc = "< The identity cipher, treated as a stream cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_NULL: mbedtls_cipher_id_t = 1;
#[doc = "< The AES cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_AES: mbedtls_cipher_id_t = 2;
#[doc = "< The DES cipher. \\warning DES is considered weak."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_DES: mbedtls_cipher_id_t = 3;
#[doc = "< The Triple DES cipher. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_3DES: mbedtls_cipher_id_t = 4;
#[doc = "< The Camellia cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CAMELLIA: mbedtls_cipher_id_t = 5;
#[doc = "< The Aria cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_ARIA: mbedtls_cipher_id_t = 6;
#[doc = "< The ChaCha20 cipher."]
pub const mbedtls_cipher_id_t_MBEDTLS_CIPHER_ID_CHACHA20: mbedtls_cipher_id_t = 7;
#[doc = " \\brief     Supported cipher types.\n\n \\warning   DES/3DES are considered weak ciphers and their use\n            constitutes a security risk. We recommend considering stronger\n            ciphers instead."]
pub type mbedtls_cipher_id_t = ::std::os::raw::c_uint;
#[doc = "< Placeholder to mark the end of cipher-pair lists."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NONE: mbedtls_cipher_type_t = 0;
#[doc = "< The identity stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_NULL: mbedtls_cipher_type_t = 1;
#[doc = "< AES cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_ECB: mbedtls_cipher_type_t = 2;
#[doc = "< AES cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_ECB: mbedtls_cipher_type_t = 3;
#[doc = "< AES cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_ECB: mbedtls_cipher_type_t = 4;
#[doc = "< AES cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CBC: mbedtls_cipher_type_t = 5;
#[doc = "< AES cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CBC: mbedtls_cipher_type_t = 6;
#[doc = "< AES cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CBC: mbedtls_cipher_type_t = 7;
#[doc = "< AES cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CFB128: mbedtls_cipher_type_t = 8;
#[doc = "< AES cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CFB128: mbedtls_cipher_type_t = 9;
#[doc = "< AES cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CFB128: mbedtls_cipher_type_t = 10;
#[doc = "< AES cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CTR: mbedtls_cipher_type_t = 11;
#[doc = "< AES cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CTR: mbedtls_cipher_type_t = 12;
#[doc = "< AES cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CTR: mbedtls_cipher_type_t = 13;
#[doc = "< AES cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_GCM: mbedtls_cipher_type_t = 14;
#[doc = "< AES cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_GCM: mbedtls_cipher_type_t = 15;
#[doc = "< AES cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_GCM: mbedtls_cipher_type_t = 16;
#[doc = "< Camellia cipher with 128-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_ECB: mbedtls_cipher_type_t = 17;
#[doc = "< Camellia cipher with 192-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_ECB: mbedtls_cipher_type_t = 18;
#[doc = "< Camellia cipher with 256-bit ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_ECB: mbedtls_cipher_type_t = 19;
#[doc = "< Camellia cipher with 128-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CBC: mbedtls_cipher_type_t = 20;
#[doc = "< Camellia cipher with 192-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CBC: mbedtls_cipher_type_t = 21;
#[doc = "< Camellia cipher with 256-bit CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CBC: mbedtls_cipher_type_t = 22;
#[doc = "< Camellia cipher with 128-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CFB128: mbedtls_cipher_type_t = 23;
#[doc = "< Camellia cipher with 192-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CFB128: mbedtls_cipher_type_t = 24;
#[doc = "< Camellia cipher with 256-bit CFB128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CFB128: mbedtls_cipher_type_t = 25;
#[doc = "< Camellia cipher with 128-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CTR: mbedtls_cipher_type_t = 26;
#[doc = "< Camellia cipher with 192-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CTR: mbedtls_cipher_type_t = 27;
#[doc = "< Camellia cipher with 256-bit CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CTR: mbedtls_cipher_type_t = 28;
#[doc = "< Camellia cipher with 128-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_GCM: mbedtls_cipher_type_t = 29;
#[doc = "< Camellia cipher with 192-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_GCM: mbedtls_cipher_type_t = 30;
#[doc = "< Camellia cipher with 256-bit GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_GCM: mbedtls_cipher_type_t = 31;
#[doc = "< DES cipher with ECB mode. \\warning DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_ECB: mbedtls_cipher_type_t = 32;
#[doc = "< DES cipher with CBC mode. \\warning DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_CBC: mbedtls_cipher_type_t = 33;
#[doc = "< DES cipher with EDE ECB mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_ECB: mbedtls_cipher_type_t = 34;
#[doc = "< DES cipher with EDE CBC mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE_CBC: mbedtls_cipher_type_t = 35;
#[doc = "< DES cipher with EDE3 ECB mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_ECB: mbedtls_cipher_type_t = 36;
#[doc = "< DES cipher with EDE3 CBC mode. \\warning 3DES is considered weak."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_DES_EDE3_CBC: mbedtls_cipher_type_t = 37;
#[doc = "< AES cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM: mbedtls_cipher_type_t = 38;
#[doc = "< AES cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM: mbedtls_cipher_type_t = 39;
#[doc = "< AES cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM: mbedtls_cipher_type_t = 40;
#[doc = "< AES cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 41;
#[doc = "< AES cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 42;
#[doc = "< AES cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 43;
#[doc = "< Camellia cipher with 128-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM: mbedtls_cipher_type_t = 44;
#[doc = "< Camellia cipher with 192-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM: mbedtls_cipher_type_t = 45;
#[doc = "< Camellia cipher with 256-bit CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM: mbedtls_cipher_type_t = 46;
#[doc = "< Camellia cipher with 128-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
	47;
#[doc = "< Camellia cipher with 192-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
	48;
#[doc = "< Camellia cipher with 256-bit CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CAMELLIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t =
	49;
#[doc = "< Aria cipher with 128-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_ECB: mbedtls_cipher_type_t = 50;
#[doc = "< Aria cipher with 192-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_ECB: mbedtls_cipher_type_t = 51;
#[doc = "< Aria cipher with 256-bit key and ECB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_ECB: mbedtls_cipher_type_t = 52;
#[doc = "< Aria cipher with 128-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CBC: mbedtls_cipher_type_t = 53;
#[doc = "< Aria cipher with 192-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CBC: mbedtls_cipher_type_t = 54;
#[doc = "< Aria cipher with 256-bit key and CBC mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CBC: mbedtls_cipher_type_t = 55;
#[doc = "< Aria cipher with 128-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CFB128: mbedtls_cipher_type_t = 56;
#[doc = "< Aria cipher with 192-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CFB128: mbedtls_cipher_type_t = 57;
#[doc = "< Aria cipher with 256-bit key and CFB-128 mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CFB128: mbedtls_cipher_type_t = 58;
#[doc = "< Aria cipher with 128-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CTR: mbedtls_cipher_type_t = 59;
#[doc = "< Aria cipher with 192-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CTR: mbedtls_cipher_type_t = 60;
#[doc = "< Aria cipher with 256-bit key and CTR mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CTR: mbedtls_cipher_type_t = 61;
#[doc = "< Aria cipher with 128-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_GCM: mbedtls_cipher_type_t = 62;
#[doc = "< Aria cipher with 192-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_GCM: mbedtls_cipher_type_t = 63;
#[doc = "< Aria cipher with 256-bit key and GCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_GCM: mbedtls_cipher_type_t = 64;
#[doc = "< Aria cipher with 128-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM: mbedtls_cipher_type_t = 65;
#[doc = "< Aria cipher with 192-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM: mbedtls_cipher_type_t = 66;
#[doc = "< Aria cipher with 256-bit key and CCM mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM: mbedtls_cipher_type_t = 67;
#[doc = "< Aria cipher with 128-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_128_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 68;
#[doc = "< Aria cipher with 192-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_192_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 69;
#[doc = "< Aria cipher with 256-bit key and CCM_STAR_NO_TAG mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_ARIA_256_CCM_STAR_NO_TAG: mbedtls_cipher_type_t = 70;
#[doc = "< AES 128-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_OFB: mbedtls_cipher_type_t = 71;
#[doc = "< AES 192-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_OFB: mbedtls_cipher_type_t = 72;
#[doc = "< AES 256-bit cipher in OFB mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_OFB: mbedtls_cipher_type_t = 73;
#[doc = "< AES 128-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_XTS: mbedtls_cipher_type_t = 74;
#[doc = "< AES 256-bit cipher in XTS block mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_XTS: mbedtls_cipher_type_t = 75;
#[doc = "< ChaCha20 stream cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20: mbedtls_cipher_type_t = 76;
#[doc = "< ChaCha20-Poly1305 AEAD cipher."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_CHACHA20_POLY1305: mbedtls_cipher_type_t = 77;
#[doc = "< AES cipher with 128-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KW: mbedtls_cipher_type_t = 78;
#[doc = "< AES cipher with 192-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KW: mbedtls_cipher_type_t = 79;
#[doc = "< AES cipher with 256-bit NIST KW mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KW: mbedtls_cipher_type_t = 80;
#[doc = "< AES cipher with 128-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_128_KWP: mbedtls_cipher_type_t = 81;
#[doc = "< AES cipher with 192-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_192_KWP: mbedtls_cipher_type_t = 82;
#[doc = "< AES cipher with 256-bit NIST KWP mode."]
pub const mbedtls_cipher_type_t_MBEDTLS_CIPHER_AES_256_KWP: mbedtls_cipher_type_t = 83;
#[doc = " \\brief     Supported {cipher type, cipher mode} pairs.\n\n \\warning   DES/3DES are considered weak ciphers and their use\n            constitutes a security risk. We recommend considering stronger\n            ciphers instead."]
pub type mbedtls_cipher_type_t = ::std::os::raw::c_uint;
#[doc = "< None."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_NONE: mbedtls_cipher_mode_t = 0;
#[doc = "< The ECB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_ECB: mbedtls_cipher_mode_t = 1;
#[doc = "< The CBC cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CBC: mbedtls_cipher_mode_t = 2;
#[doc = "< The CFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CFB: mbedtls_cipher_mode_t = 3;
#[doc = "< The OFB cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_OFB: mbedtls_cipher_mode_t = 4;
#[doc = "< The CTR cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CTR: mbedtls_cipher_mode_t = 5;
#[doc = "< The GCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_GCM: mbedtls_cipher_mode_t = 6;
#[doc = "< The stream cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_STREAM: mbedtls_cipher_mode_t = 7;
#[doc = "< The CCM cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM: mbedtls_cipher_mode_t = 8;
#[doc = "< The CCM*-no-tag cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CCM_STAR_NO_TAG: mbedtls_cipher_mode_t = 9;
#[doc = "< The XTS cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_XTS: mbedtls_cipher_mode_t = 10;
#[doc = "< The ChaCha-Poly cipher mode."]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_CHACHAPOLY: mbedtls_cipher_mode_t = 11;
#[doc = "< The SP800-38F KW mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KW: mbedtls_cipher_mode_t = 12;
#[doc = "< The SP800-38F KWP mode"]
pub const mbedtls_cipher_mode_t_MBEDTLS_MODE_KWP: mbedtls_cipher_mode_t = 13;
#[doc = " Supported cipher modes."]
pub type mbedtls_cipher_mode_t = ::std::os::raw::c_uint;
#[doc = "< PKCS7 padding (default)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_PKCS7: mbedtls_cipher_padding_t = 0;
#[doc = "< ISO/IEC 7816-4 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ONE_AND_ZEROS: mbedtls_cipher_padding_t = 1;
#[doc = "< ANSI X.923 padding."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS_AND_LEN: mbedtls_cipher_padding_t = 2;
#[doc = "< Zero padding (not reversible)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_ZEROS: mbedtls_cipher_padding_t = 3;
#[doc = "< Never pad (full blocks only)."]
pub const mbedtls_cipher_padding_t_MBEDTLS_PADDING_NONE: mbedtls_cipher_padding_t = 4;
#[doc = " Supported cipher padding types."]
pub type mbedtls_cipher_padding_t = ::std::os::raw::c_uint;
pub const mbedtls_operation_t_MBEDTLS_OPERATION_NONE: mbedtls_operation_t = -1;
pub const mbedtls_operation_t_MBEDTLS_DECRYPT: mbedtls_operation_t = 0;
pub const mbedtls_operation_t_MBEDTLS_ENCRYPT: mbedtls_operation_t = 1;
#[doc = " Type of operation."]
pub type mbedtls_operation_t = ::std::os::raw::c_int;
#[doc = " Undefined key length."]
pub const MBEDTLS_KEY_LENGTH_NONE: _bindgen_ty_1 = 0;
#[doc = " Key length, in bits (including parity), for DES keys. \\warning DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES: _bindgen_ty_1 = 64;
#[doc = " Key length in bits, including parity, for DES in two-key EDE. \\warning 3DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE: _bindgen_ty_1 = 128;
#[doc = " Key length in bits, including parity, for DES in three-key EDE. \\warning 3DES is considered weak."]
pub const MBEDTLS_KEY_LENGTH_DES_EDE3: _bindgen_ty_1 = 192;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_base_t {
	_unused: [u8; 0],
}
#[doc = " Cipher information. Allows calling cipher functions\n in a generic way.\n\n \\note        The library does not support custom cipher info structures,\n              only built-in structures returned by the functions\n              mbedtls_cipher_info_from_string(),\n              mbedtls_cipher_info_from_type(),\n              mbedtls_cipher_info_from_values(),\n              mbedtls_cipher_info_from_psa().\n\n \\note        Some fields store a value that has been right-shifted to save\n              code-size, so should not be used directly. The accessor\n              functions adjust for this and return the \"natural\" value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_info_t {
	pub private_name: *const ::std::os::raw::c_char,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
	pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_mbedtls_cipher_info_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_cipher_info_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_cipher_info_t>(),
		16usize,
		concat!("Size of: ", stringify!(mbedtls_cipher_info_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_cipher_info_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_cipher_info_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_name) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_info_t),
			"::",
			stringify!(private_name)
		)
	);
}
impl mbedtls_cipher_info_t {
	#[inline]
	pub fn private_block_size(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
	}
	#[inline]
	pub fn set_private_block_size(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 5u8, val as u64)
		}
	}
	#[inline]
	pub fn private_iv_size(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
	}
	#[inline]
	pub fn set_private_iv_size(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(5usize, 3u8, val as u64)
		}
	}
	#[inline]
	pub fn private_key_bitlen(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
	}
	#[inline]
	pub fn set_private_key_bitlen(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(8usize, 4u8, val as u64)
		}
	}
	#[inline]
	pub fn private_mode(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
	}
	#[inline]
	pub fn set_private_mode(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(12usize, 4u8, val as u64)
		}
	}
	#[inline]
	pub fn private_type(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
	}
	#[inline]
	pub fn set_private_type(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(16usize, 8u8, val as u64)
		}
	}
	#[inline]
	pub fn private_flags(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
	}
	#[inline]
	pub fn set_private_flags(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(24usize, 2u8, val as u64)
		}
	}
	#[inline]
	pub fn private_base_idx(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 5u8) as u32) }
	}
	#[inline]
	pub fn set_private_base_idx(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(26usize, 5u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_block_size: ::std::os::raw::c_uint,
		private_iv_size: ::std::os::raw::c_uint,
		private_key_bitlen: ::std::os::raw::c_uint,
		private_mode: ::std::os::raw::c_uint,
		private_type: ::std::os::raw::c_uint,
		private_flags: ::std::os::raw::c_uint,
		private_base_idx: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 4usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 5u8, {
			let private_block_size: u32 = unsafe { ::std::mem::transmute(private_block_size) };
			private_block_size as u64
		});
		__bindgen_bitfield_unit.set(5usize, 3u8, {
			let private_iv_size: u32 = unsafe { ::std::mem::transmute(private_iv_size) };
			private_iv_size as u64
		});
		__bindgen_bitfield_unit.set(8usize, 4u8, {
			let private_key_bitlen: u32 = unsafe { ::std::mem::transmute(private_key_bitlen) };
			private_key_bitlen as u64
		});
		__bindgen_bitfield_unit.set(12usize, 4u8, {
			let private_mode: u32 = unsafe { ::std::mem::transmute(private_mode) };
			private_mode as u64
		});
		__bindgen_bitfield_unit.set(16usize, 8u8, {
			let private_type: u32 = unsafe { ::std::mem::transmute(private_type) };
			private_type as u64
		});
		__bindgen_bitfield_unit.set(24usize, 2u8, {
			let private_flags: u32 = unsafe { ::std::mem::transmute(private_flags) };
			private_flags as u64
		});
		__bindgen_bitfield_unit.set(26usize, 5u8, {
			let private_base_idx: u32 = unsafe { ::std::mem::transmute(private_base_idx) };
			private_base_idx as u64
		});
		__bindgen_bitfield_unit
	}
}
#[doc = " Generic cipher context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cipher_context_t {
	pub private_cipher_info: *const mbedtls_cipher_info_t,
	pub private_key_bitlen: ::std::os::raw::c_int,
	pub private_operation: mbedtls_operation_t,
	pub private_add_padding: ::std::option::Option<
		unsafe extern "C" fn(output: *mut ::std::os::raw::c_uchar, olen: usize, data_len: usize),
	>,
	pub private_get_padding: ::std::option::Option<
		unsafe extern "C" fn(
			input: *mut ::std::os::raw::c_uchar,
			ilen: usize,
			data_len: *mut usize,
		) -> ::std::os::raw::c_int,
	>,
	pub private_unprocessed_data: [::std::os::raw::c_uchar; 16usize],
	pub private_unprocessed_len: usize,
	pub private_iv: [::std::os::raw::c_uchar; 16usize],
	pub private_iv_size: usize,
	pub private_cipher_ctx: *mut ::std::os::raw::c_void,
	pub private_cmac_ctx: *mut mbedtls_cmac_context_t,
}
#[test]
fn bindgen_test_layout_mbedtls_cipher_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_cipher_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_cipher_context_t>(),
		96usize,
		concat!("Size of: ", stringify!(mbedtls_cipher_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_cipher_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_cipher_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cipher_info) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_cipher_info)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_key_bitlen) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_key_bitlen)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_operation) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_operation)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_add_padding) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_add_padding)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_get_padding) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_get_padding)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_unprocessed_data) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_unprocessed_data)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_unprocessed_len) as usize - ptr as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_unprocessed_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_iv) as usize - ptr as usize },
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_iv)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_iv_size) as usize - ptr as usize },
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_iv_size)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cipher_ctx) as usize - ptr as usize },
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_cipher_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cmac_ctx) as usize - ptr as usize },
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cipher_context_t),
			"::",
			stringify!(private_cmac_ctx)
		)
	);
}
extern "C" {
	#[doc = " \\brief This function retrieves the list of ciphers supported\n        by the generic cipher module.\n\n        For any cipher identifier in the returned list, you can\n        obtain the corresponding generic cipher information structure\n        via mbedtls_cipher_info_from_type(), which can then be used\n        to prepare a cipher context via mbedtls_cipher_setup().\n\n\n \\return      A statically-allocated array of cipher identifiers\n              of type cipher_type_t. The last entry is zero."]
	pub fn mbedtls_cipher_list() -> *const ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher name.\n\n \\param cipher_name   Name of the cipher to search for. This must not be\n                      \\c NULL.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_name.\n \\return              \\c NULL if the associated cipher information is not found."]
	pub fn mbedtls_cipher_info_from_string(
		cipher_name: *const ::std::os::raw::c_char,
	) -> *const mbedtls_cipher_info_t;
}
extern "C" {
	#[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher type.\n\n \\param cipher_type   Type of the cipher to search for.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_type.\n \\return              \\c NULL if the associated cipher information is not found."]
	pub fn mbedtls_cipher_info_from_type(
		cipher_type: mbedtls_cipher_type_t,
	) -> *const mbedtls_cipher_info_t;
}
extern "C" {
	#[doc = " \\brief               This function retrieves the cipher-information\n                      structure associated with the given cipher ID,\n                      key size and mode.\n\n \\param cipher_id     The ID of the cipher to search for. For example,\n                      #MBEDTLS_CIPHER_ID_AES.\n \\param key_bitlen    The length of the key in bits.\n \\param mode          The cipher mode. For example, #MBEDTLS_MODE_CBC.\n\n \\return              The cipher information structure associated with the\n                      given \\p cipher_id.\n \\return              \\c NULL if the associated cipher information is not found."]
	pub fn mbedtls_cipher_info_from_values(
		cipher_id: mbedtls_cipher_id_t,
		key_bitlen: ::std::os::raw::c_int,
		mode: mbedtls_cipher_mode_t,
	) -> *const mbedtls_cipher_info_t;
}
extern "C" {
	#[doc = " \\brief               This function initializes a \\p ctx as NONE.\n\n \\param ctx           The context to be initialized. This must not be \\c NULL."]
	pub fn mbedtls_cipher_init(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
	#[doc = " \\brief               This function frees and clears the cipher-specific\n                      context of \\p ctx. Freeing \\p ctx itself remains the\n                      responsibility of the caller.\n\n \\param ctx           The context to be freed. If this is \\c NULL, the\n                      function has no effect, otherwise this must point to an\n                      initialized context."]
	pub fn mbedtls_cipher_free(ctx: *mut mbedtls_cipher_context_t);
}
extern "C" {
	#[doc = " \\brief               This function prepares a cipher context for\n                      use with the given cipher primitive.\n\n \\note                After calling this function, you should call\n                      mbedtls_cipher_setkey() and, if the mode uses padding,\n                      mbedtls_cipher_set_padding_mode(), then for each\n                      message to encrypt or decrypt with this key, either:\n                      - mbedtls_cipher_crypt() for one-shot processing with\n                      non-AEAD modes;\n                      - mbedtls_cipher_auth_encrypt_ext() or\n                      mbedtls_cipher_auth_decrypt_ext() for one-shot\n                      processing with AEAD modes or NIST_KW;\n                      - for multi-part processing, see the documentation of\n                      mbedtls_cipher_reset().\n\n \\param ctx           The context to prepare. This must be initialized by\n                      a call to mbedtls_cipher_init() first.\n \\param cipher_info   The cipher to use.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_ALLOC_FAILED if allocation of the\n                      cipher-specific context fails."]
	pub fn mbedtls_cipher_setup(
		ctx: *mut mbedtls_cipher_context_t,
		cipher_info: *const mbedtls_cipher_info_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function sets the key to use with the given context.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a cipher information structure.\n \\param key           The key to use. This must be a readable buffer of at\n                      least \\p key_bitlen Bits.\n \\param key_bitlen    The key length to use, in Bits.\n \\param operation     The operation that the key will be used for:\n                      #MBEDTLS_ENCRYPT or #MBEDTLS_DECRYPT.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              A cipher-specific error code on failure."]
	pub fn mbedtls_cipher_setkey(
		ctx: *mut mbedtls_cipher_context_t,
		key: *const ::std::os::raw::c_uchar,
		key_bitlen: ::std::os::raw::c_int,
		operation: mbedtls_operation_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function sets the padding mode, for cipher modes\n                      that use padding.\n\n                      The default passing mode is PKCS7 padding.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a cipher information structure.\n \\param mode          The padding mode.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE\n                      if the selected padding mode is not supported.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA if the cipher mode\n                      does not support padding."]
	pub fn mbedtls_cipher_set_padding_mode(
		ctx: *mut mbedtls_cipher_context_t,
		mode: mbedtls_cipher_padding_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function sets the initialization vector (IV)\n                  or nonce.\n\n \\note            Some ciphers do not use IVs nor nonce. For these\n                  ciphers, this function has no effect.\n\n \\note            For #MBEDTLS_CIPHER_CHACHA20, the nonce length must\n                  be 12, and the initial counter value is 0.\n\n \\note            For #MBEDTLS_CIPHER_CHACHA20_POLY1305, the nonce length\n                  must be 12.\n\n \\param ctx       The generic cipher context. This must be initialized and\n                  bound to a cipher information structure.\n \\param iv        The IV to use, or NONCE_COUNTER for CTR-mode ciphers. This\n                  must be a readable buffer of at least \\p iv_len Bytes.\n \\param iv_len    The IV length for ciphers with variable-size IV.\n                  This parameter is discarded by ciphers with fixed-size IV.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                  parameter-verification failure."]
	pub fn mbedtls_cipher_set_iv(
		ctx: *mut mbedtls_cipher_context_t,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief         This function resets the cipher state.\n\n \\note          With non-AEAD ciphers, the order of calls for each message\n                is as follows:\n                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.\n                2. mbedtls_cipher_reset()\n                3. mbedtls_cipher_update() one or more times\n                4. mbedtls_cipher_finish()\n                .\n                This sequence can be repeated to encrypt or decrypt multiple\n                messages with the same key.\n\n \\note          With AEAD ciphers, the order of calls for each message\n                is as follows:\n                1. mbedtls_cipher_set_iv() if the mode uses an IV/nonce.\n                2. mbedtls_cipher_reset()\n                3. mbedtls_cipher_update_ad()\n                4. mbedtls_cipher_update() one or more times\n                5. mbedtls_cipher_finish()\n                6. mbedtls_cipher_check_tag() (for decryption) or\n                mbedtls_cipher_write_tag() (for encryption).\n                .\n                This sequence can be repeated to encrypt or decrypt multiple\n                messages with the same key.\n\n \\param ctx     The generic cipher context. This must be bound to a key.\n\n \\return        \\c 0 on success.\n \\return        #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                parameter-verification failure."]
	pub fn mbedtls_cipher_reset(ctx: *mut mbedtls_cipher_context_t) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function adds additional data for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param ad            The additional data to use. This must be a readable\n                      buffer of at least \\p ad_len Bytes.\n \\param ad_len        The length of \\p ad in Bytes.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
	pub fn mbedtls_cipher_update_ad(
		ctx: *mut mbedtls_cipher_context_t,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               The generic cipher update function. It encrypts or\n                      decrypts using the given cipher context. Writes as\n                      many block-sized blocks of data as possible to output.\n                      Any data that cannot be written immediately is either\n                      added to the next block, or flushed when\n                      mbedtls_cipher_finish() is called.\n                      Exception: For MBEDTLS_MODE_ECB, expects a single block\n                      in size. For example, 16 Bytes for AES.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the output data. This must be able to\n                      hold at least `ilen + block_size`. This must not be the\n                      same buffer as \\p input.\n \\param olen          The length of the output data, to be updated with the\n                      actual number of Bytes written. This must not be\n                      \\c NULL.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE on an\n                      unsupported mode for a cipher.\n \\return              A cipher-specific error code on failure."]
	pub fn mbedtls_cipher_update(
		ctx: *mut mbedtls_cipher_context_t,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
		olen: *mut usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               The generic cipher finalization function. If data still\n                      needs to be flushed from an incomplete block, the data\n                      contained in it is padded to the size of\n                      the last block, and written to the \\p output buffer.\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key.\n \\param output        The buffer to write data to. This needs to be a writable\n                      buffer of at least block_size Bytes.\n \\param olen          The length of the data written to the \\p output buffer.\n                      This may not be \\c NULL.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n                      expecting a full block but not receiving one.\n \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n                      while decrypting.\n \\return              A cipher-specific error code on failure."]
	pub fn mbedtls_cipher_finish(
		ctx: *mut mbedtls_cipher_context_t,
		output: *mut ::std::os::raw::c_uchar,
		olen: *mut usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function writes a tag for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n                      This must be called after mbedtls_cipher_finish().\n\n \\param ctx           The generic cipher context. This must be initialized,\n                      bound to a key, and have just completed a cipher\n                      operation through mbedtls_cipher_finish() the tag for\n                      which should be written.\n \\param tag           The buffer to write the tag to. This must be a writable\n                      buffer of at least \\p tag_len Bytes.\n \\param tag_len       The length of the tag to write.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
	pub fn mbedtls_cipher_write_tag(
		ctx: *mut mbedtls_cipher_context_t,
		tag: *mut ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function checks the tag for AEAD ciphers.\n                      Currently supported with GCM and ChaCha20+Poly1305.\n                      This must be called after mbedtls_cipher_finish().\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param tag           The buffer holding the tag. This must be a readable\n                      buffer of at least \\p tag_len Bytes.\n \\param tag_len       The length of the tag to check.\n\n \\return              \\c 0 on success.\n \\return              A specific error code on failure."]
	pub fn mbedtls_cipher_check_tag(
		ctx: *mut mbedtls_cipher_context_t,
		tag: *const ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               The generic all-in-one encryption/decryption function,\n                      for all ciphers except AEAD constructs.\n\n \\param ctx           The generic cipher context. This must be initialized.\n \\param iv            The IV to use, or NONCE_COUNTER for CTR-mode ciphers.\n                      This must be a readable buffer of at least \\p iv_len\n                      Bytes.\n \\param iv_len        The IV length for ciphers with variable-size IV.\n                      This parameter is discarded by ciphers with fixed-size\n                      IV.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes.\n \\param ilen          The length of the input data in Bytes.\n \\param output        The buffer for the output data. This must be able to\n                      hold at least `ilen + block_size`. This must not be the\n                      same buffer as \\p input.\n \\param olen          The length of the output data, to be updated with the\n                      actual number of Bytes written. This must not be\n                      \\c NULL.\n\n \\note                Some ciphers do not use IVs nor nonce. For these\n                      ciphers, use \\p iv = NULL and \\p iv_len = 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED on decryption\n                      expecting a full block but not receiving one.\n \\return              #MBEDTLS_ERR_CIPHER_INVALID_PADDING on invalid padding\n                      while decrypting.\n \\return              A cipher-specific error code on failure."]
	pub fn mbedtls_cipher_crypt(
		ctx: *mut mbedtls_cipher_context_t,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
		olen: *mut usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function.\n\n \\note                For AEAD modes, the tag will be appended to the\n                      ciphertext, as recommended by RFC 5116.\n                      (NIST_KW doesn't have a separate tag.)\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key, with an AEAD algorithm or NIST_KW.\n \\param iv            The nonce to use. This must be a readable buffer of\n                      at least \\p iv_len Bytes and may be \\c NULL if \\p\n                      iv_len is \\c 0.\n \\param iv_len        The length of the nonce. For AEAD ciphers, this must\n                      satisfy the constraints imposed by the cipher used.\n                      For NIST_KW, this must be \\c 0.\n \\param ad            The additional data to authenticate. This must be a\n                      readable buffer of at least \\p ad_len Bytes, and may\n                      be \\c NULL is \\p ad_len is \\c 0.\n \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes, and may be\n                      \\c NULL if \\p ilen is \\c 0.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the output data. This must be a\n                      writable buffer of at least \\p output_len Bytes, and\n                      must not be \\c NULL.\n \\param output_len    The length of the \\p output buffer in Bytes. For AEAD\n                      ciphers, this must be at least \\p ilen + \\p tag_len.\n                      For NIST_KW, this must be at least \\p ilen + 8\n                      (rounded up to a multiple of 8 if KWP is used);\n                      \\p ilen + 15 is always a safe value.\n \\param olen          This will be filled with the actual number of Bytes\n                      written to the \\p output buffer. This must point to a\n                      writable object of type \\c size_t.\n \\param tag_len       The desired length of the authentication tag. For AEAD\n                      ciphers, this must match the constraints imposed by\n                      the cipher used, and in particular must not be \\c 0.\n                      For NIST_KW, this must be \\c 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              A cipher-specific error code on failure."]
	pub fn mbedtls_cipher_auth_encrypt_ext(
		ctx: *mut mbedtls_cipher_context_t,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
		output_len: usize,
		olen: *mut usize,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               The authenticated encryption (AEAD/NIST_KW) function.\n\n \\note                If the data is not authentic, then the output buffer\n                      is zeroed out to prevent the unauthentic plaintext being\n                      used, making this interface safer.\n\n \\note                For AEAD modes, the tag must be appended to the\n                      ciphertext, as recommended by RFC 5116.\n                      (NIST_KW doesn't have a separate tag.)\n\n \\param ctx           The generic cipher context. This must be initialized and\n                      bound to a key, with an AEAD algorithm or NIST_KW.\n \\param iv            The nonce to use. This must be a readable buffer of\n                      at least \\p iv_len Bytes and may be \\c NULL if \\p\n                      iv_len is \\c 0.\n \\param iv_len        The length of the nonce. For AEAD ciphers, this must\n                      satisfy the constraints imposed by the cipher used.\n                      For NIST_KW, this must be \\c 0.\n \\param ad            The additional data to authenticate. This must be a\n                      readable buffer of at least \\p ad_len Bytes, and may\n                      be \\c NULL is \\p ad_len is \\c 0.\n \\param ad_len        The length of \\p ad. For NIST_KW, this must be \\c 0.\n \\param input         The buffer holding the input data. This must be a\n                      readable buffer of at least \\p ilen Bytes, and may be\n                      \\c NULL if \\p ilen is \\c 0.\n \\param ilen          The length of the input data. For AEAD ciphers this\n                      must be at least \\p tag_len. For NIST_KW this must be\n                      at least \\c 8.\n \\param output        The buffer for the output data. This must be a\n                      writable buffer of at least \\p output_len Bytes, and\n                      may be \\c NULL if \\p output_len is \\c 0.\n \\param output_len    The length of the \\p output buffer in Bytes. For AEAD\n                      ciphers, this must be at least \\p ilen - \\p tag_len.\n                      For NIST_KW, this must be at least \\p ilen - 8.\n \\param olen          This will be filled with the actual number of Bytes\n                      written to the \\p output buffer. This must point to a\n                      writable object of type \\c size_t.\n \\param tag_len       The actual length of the authentication tag. For AEAD\n                      ciphers, this must match the constraints imposed by\n                      the cipher used, and in particular must not be \\c 0.\n                      For NIST_KW, this must be \\c 0.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA on\n                      parameter-verification failure.\n \\return              #MBEDTLS_ERR_CIPHER_AUTH_FAILED if data is not authentic.\n \\return              A cipher-specific error code on failure."]
	pub fn mbedtls_cipher_auth_decrypt_ext(
		ctx: *mut mbedtls_cipher_context_t,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
		output_len: usize,
		olen: *mut usize,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_cipher_operation_t {
	pub private_alg: psa_algorithm_t,
	pub private_iv_length: u8,
	pub private_block_length: u8,
	pub private_ctx: mbedtls_psa_cipher_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_cipher_operation_t__bindgen_ty_1 {
	pub private_dummy: ::std::os::raw::c_uint,
	pub private_cipher: mbedtls_cipher_context_t,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_cipher_operation_t__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_cipher_operation_t__bindgen_ty_1> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_cipher_operation_t__bindgen_ty_1>(),
		96usize,
		concat!(
			"Size of: ",
			stringify!(mbedtls_psa_cipher_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_cipher_operation_t__bindgen_ty_1>(),
		8usize,
		concat!(
			"Alignment of ",
			stringify!(mbedtls_psa_cipher_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_cipher_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cipher) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_cipher_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_cipher)
		)
	);
}
#[test]
fn bindgen_test_layout_mbedtls_psa_cipher_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_cipher_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_cipher_operation_t>(),
		104usize,
		concat!("Size of: ", stringify!(mbedtls_psa_cipher_operation_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_cipher_operation_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_psa_cipher_operation_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_cipher_operation_t),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_iv_length) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_cipher_operation_t),
			"::",
			stringify!(private_iv_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_block_length) as usize - ptr as usize },
		5usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_cipher_operation_t),
			"::",
			stringify!(private_block_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_cipher_operation_t),
			"::",
			stringify!(private_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_hash_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub mbedtls_ctx: mbedtls_psa_hash_operation_t,
}
#[test]
fn bindgen_test_layout_psa_driver_hash_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_hash_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_hash_context_t>(),
		224usize,
		concat!("Size of: ", stringify!(psa_driver_hash_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_hash_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_driver_hash_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_hash_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbedtls_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_hash_context_t),
			"::",
			stringify!(mbedtls_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_cipher_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub mbedtls_ctx: mbedtls_psa_cipher_operation_t,
}
#[test]
fn bindgen_test_layout_psa_driver_cipher_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_cipher_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_cipher_context_t>(),
		104usize,
		concat!("Size of: ", stringify!(psa_driver_cipher_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_cipher_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_driver_cipher_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_cipher_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbedtls_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_cipher_context_t),
			"::",
			stringify!(mbedtls_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hash_operation_s {
	pub private_id: ::std::os::raw::c_uint,
	pub private_ctx: psa_driver_hash_context_t,
}
#[test]
fn bindgen_test_layout_psa_hash_operation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_hash_operation_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_hash_operation_s>(),
		232usize,
		concat!("Size of: ", stringify!(psa_hash_operation_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_hash_operation_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_hash_operation_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hash_operation_s),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hash_operation_s),
			"::",
			stringify!(private_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_cipher_operation_s {
	pub private_id: ::std::os::raw::c_uint,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_default_iv_length: u8,
	pub private_ctx: psa_driver_cipher_context_t,
}
#[test]
fn bindgen_test_layout_psa_cipher_operation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_cipher_operation_s> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_cipher_operation_s>(),
		112usize,
		concat!("Size of: ", stringify!(psa_cipher_operation_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_cipher_operation_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_cipher_operation_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_cipher_operation_s),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_default_iv_length) as usize - ptr as usize },
		5usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_cipher_operation_s),
			"::",
			stringify!(private_default_iv_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_cipher_operation_s),
			"::",
			stringify!(private_ctx)
		)
	);
}
impl psa_cipher_operation_s {
	#[inline]
	pub fn private_iv_required(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_iv_required(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn private_iv_set(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_iv_set(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(1usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_iv_required: ::std::os::raw::c_uint,
		private_iv_set: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			let private_iv_required: u32 = unsafe { ::std::mem::transmute(private_iv_required) };
			private_iv_required as u64
		});
		__bindgen_bitfield_unit.set(1usize, 1u8, {
			let private_iv_set: u32 = unsafe { ::std::mem::transmute(private_iv_set) };
			private_iv_set as u64
		});
		__bindgen_bitfield_unit
	}
}
#[doc = " The CMAC context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_cmac_context_t {
	pub private_state: [::std::os::raw::c_uchar; 16usize],
	pub private_unprocessed_block: [::std::os::raw::c_uchar; 16usize],
	pub private_unprocessed_len: usize,
}
#[test]
fn bindgen_test_layout_mbedtls_cmac_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_cmac_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_cmac_context_t>(),
		40usize,
		concat!("Size of: ", stringify!(mbedtls_cmac_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_cmac_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_cmac_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cmac_context_t),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_unprocessed_block) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cmac_context_t),
			"::",
			stringify!(private_unprocessed_block)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_unprocessed_len) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_cmac_context_t),
			"::",
			stringify!(private_unprocessed_len)
		)
	);
}
extern "C" {
	#[doc = " \\brief               This function starts a new CMAC computation\n                      by setting the CMAC key, and preparing to authenticate\n                      the input data.\n                      It must be called with an initialized cipher context.\n\n                      Once this function has completed, data can be supplied\n                      to the CMAC computation by calling\n                      mbedtls_cipher_cmac_update().\n\n                      To start a CMAC computation using the same key as a previous\n                      CMAC computation, use mbedtls_cipher_cmac_finish().\n\n \\note                When the CMAC implementation is supplied by an alternate\n                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers\n                      may not be supported by that implementation, and thus\n                      return an error. Alternate implementations must support\n                      AES-128 and AES-256, and may support AES-192 and 3DES.\n\n \\param ctx           The cipher context used for the CMAC operation, initialized\n                      as one of the following types: MBEDTLS_CIPHER_AES_128_ECB,\n                      MBEDTLS_CIPHER_AES_192_ECB, MBEDTLS_CIPHER_AES_256_ECB,\n                      or MBEDTLS_CIPHER_DES_EDE3_ECB.\n \\param key           The CMAC key.\n \\param keybits       The length of the CMAC key in bits.\n                      Must be supported by the cipher.\n\n \\return              \\c 0 on success.\n \\return              A cipher-specific error code on failure."]
	pub fn mbedtls_cipher_cmac_starts(
		ctx: *mut mbedtls_cipher_context_t,
		key: *const ::std::os::raw::c_uchar,
		keybits: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function feeds an input buffer into an ongoing CMAC\n                      computation.\n\n                      The CMAC computation must have previously been started\n                      by calling mbedtls_cipher_cmac_starts() or\n                      mbedtls_cipher_cmac_reset().\n\n                      Call this function as many times as needed to input the\n                      data to be authenticated.\n                      Once all of the required data has been input,\n                      call mbedtls_cipher_cmac_finish() to obtain the result\n                      of the CMAC operation.\n\n \\param ctx           The cipher context used for the CMAC operation.\n \\param input         The buffer holding the input data.\n \\param ilen          The length of the input data.\n\n \\return             \\c 0 on success.\n \\return             #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                     if parameter verification fails."]
	pub fn mbedtls_cipher_cmac_update(
		ctx: *mut mbedtls_cipher_context_t,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function finishes an ongoing CMAC operation, and\n                      writes the result to the output buffer.\n\n                      It should be followed either by\n                      mbedtls_cipher_cmac_reset(), which starts another CMAC\n                      operation with the same key, or mbedtls_cipher_free(),\n                      which clears the cipher context.\n\n \\param ctx           The cipher context used for the CMAC operation.\n \\param output        The output buffer for the CMAC checksum result.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
	pub fn mbedtls_cipher_cmac_finish(
		ctx: *mut mbedtls_cipher_context_t,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function starts a new CMAC operation with the same\n                      key as the previous one.\n\n                      It should be called after finishing the previous CMAC\n                      operation with mbedtls_cipher_cmac_finish().\n                      After calling this function,\n                      call mbedtls_cipher_cmac_update() to supply the new\n                      CMAC operation with data.\n\n \\param ctx           The cipher context used for the CMAC operation.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
	pub fn mbedtls_cipher_cmac_reset(ctx: *mut mbedtls_cipher_context_t) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function calculates the full generic CMAC\n                      on the input buffer with the provided key.\n\n                      The function allocates the context, performs the\n                      calculation, and frees the context.\n\n                      The CMAC result is calculated as\n                      output = generic CMAC(cmac key, input buffer).\n\n \\note                When the CMAC implementation is supplied by an alternate\n                      implementation (through #MBEDTLS_CMAC_ALT), some ciphers\n                      may not be supported by that implementation, and thus\n                      return an error. Alternate implementations must support\n                      AES-128 and AES-256, and may support AES-192 and 3DES.\n\n \\param cipher_info   The cipher information.\n \\param key           The CMAC key.\n \\param keylen        The length of the CMAC key in bits.\n \\param input         The buffer holding the input data.\n \\param ilen          The length of the input data.\n \\param output        The buffer for the generic CMAC result.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_MD_BAD_INPUT_DATA\n                      if parameter verification fails."]
	pub fn mbedtls_cipher_cmac(
		cipher_info: *const mbedtls_cipher_info_t,
		key: *const ::std::os::raw::c_uchar,
		keylen: usize,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function implements the AES-CMAC-PRF-128 pseudorandom\n                  function, as defined in\n                  <em>RFC-4615: The Advanced Encryption Standard-Cipher-based\n                  Message Authentication Code-Pseudo-Random Function-128\n                  (AES-CMAC-PRF-128) Algorithm for the Internet Key\n                  Exchange Protocol (IKE).</em>\n\n \\param key       The key to use.\n \\param key_len   The key length in Bytes.\n \\param input     The buffer holding the input data.\n \\param in_len    The length of the input data in Bytes.\n \\param output    The buffer holding the generated 16 Bytes of\n                  pseudorandom output.\n\n \\return          \\c 0 on success."]
	pub fn mbedtls_aes_cmac_prf_128(
		key: *const ::std::os::raw::c_uchar,
		key_len: usize,
		input: *const ::std::os::raw::c_uchar,
		in_len: usize,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The CMAC checkup routine.\n\n \\note           In case the CMAC routines are provided by an alternative\n                 implementation (i.e. #MBEDTLS_CMAC_ALT is defined), the\n                 checkup routine will succeed even if the implementation does\n                 not support the less widely used AES-192 or 3DES primitives.\n                 The self-test requires at least AES-128 and AES-256 to be\n                 supported by the underlying implementation.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_cmac_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " \\brief          The GCM context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_gcm_context {
	pub private_cipher_ctx: mbedtls_cipher_context_t,
	pub private_HL: [u64; 16usize],
	pub private_HH: [u64; 16usize],
	pub private_len: u64,
	pub private_add_len: u64,
	pub private_base_ectr: [::std::os::raw::c_uchar; 16usize],
	pub private_y: [::std::os::raw::c_uchar; 16usize],
	pub private_buf: [::std::os::raw::c_uchar; 16usize],
	pub private_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mbedtls_gcm_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_gcm_context> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_gcm_context>(),
		424usize,
		concat!("Size of: ", stringify!(mbedtls_gcm_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_gcm_context>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_gcm_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cipher_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_cipher_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_HL) as usize - ptr as usize },
		96usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_HL)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_HH) as usize - ptr as usize },
		224usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_HH)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_len) as usize - ptr as usize },
		352usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_add_len) as usize - ptr as usize },
		360usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_add_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_base_ectr) as usize - ptr as usize },
		368usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_base_ectr)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_y) as usize - ptr as usize },
		384usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_y)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buf) as usize - ptr as usize },
		400usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_buf)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_mode) as usize - ptr as usize },
		416usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_gcm_context),
			"::",
			stringify!(private_mode)
		)
	);
}
extern "C" {
	#[doc = " \\brief           This function initializes the specified GCM context,\n                  to make references valid, and prepares the context\n                  for mbedtls_gcm_setkey() or mbedtls_gcm_free().\n\n                  The function does not bind the GCM context to a particular\n                  cipher, nor set the key. For this purpose, use\n                  mbedtls_gcm_setkey().\n\n \\param ctx       The GCM context to initialize. This must not be \\c NULL."]
	pub fn mbedtls_gcm_init(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
	#[doc = " \\brief           This function associates a GCM context with a\n                  cipher algorithm and a key.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param cipher    The 128-bit block cipher to use.\n \\param key       The encryption key. This must be a readable buffer of at\n                  least \\p keybits bits.\n \\param keybits   The key size in bits. Valid options are:\n                  <ul><li>128 bits</li>\n                  <li>192 bits</li>\n                  <li>256 bits</li></ul>\n\n \\return          \\c 0 on success.\n \\return          A cipher-specific error code on failure."]
	pub fn mbedtls_gcm_setkey(
		ctx: *mut mbedtls_gcm_context,
		cipher: mbedtls_cipher_id_t,
		key: *const ::std::os::raw::c_uchar,
		keybits: ::std::os::raw::c_uint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs GCM encryption or decryption of a buffer.\n\n \\note            For encryption, the output buffer can be the same as the\n                  input buffer. For decryption, the output buffer cannot be\n                  the same as input buffer. If the buffers overlap, the output\n                  buffer must trail at least 8 Bytes behind the input buffer.\n\n \\warning         When this function performs a decryption, it outputs the\n                  authentication tag and does not verify that the data is\n                  authentic. You should use this function to perform encryption\n                  only. For decryption, use mbedtls_gcm_auth_decrypt() instead.\n\n \\param ctx       The GCM context to use for encryption or decryption. This\n                  must be initialized.\n \\param mode      The operation to perform:\n                  - #MBEDTLS_GCM_ENCRYPT to perform authenticated encryption.\n                    The ciphertext is written to \\p output and the\n                    authentication tag is written to \\p tag.\n                  - #MBEDTLS_GCM_DECRYPT to perform decryption.\n                    The plaintext is written to \\p output and the\n                    authentication tag is written to \\p tag.\n                    Note that this mode is not recommended, because it does\n                    not verify the authenticity of the data. For this reason,\n                    you should use mbedtls_gcm_auth_decrypt() instead of\n                    calling this function in decryption mode.\n \\param length    The length of the input data, which is equal to the length\n                  of the output data.\n \\param iv        The initialization vector. This must be a readable buffer of\n                  at least \\p iv_len Bytes.\n \\param iv_len    The length of the IV.\n \\param add       The buffer holding the additional data. This must be of at\n                  least that size in Bytes.\n \\param add_len   The length of the additional data.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, this must be a readable buffer of at least that\n                  size in Bytes.\n \\param output    The buffer for holding the output data. If \\p length is greater\n                  than zero, this must be a writable buffer of at least that\n                  size in Bytes.\n \\param tag_len   The length of the tag to generate.\n \\param tag       The buffer for holding the tag. This must be a writable\n                  buffer of at least \\p tag_len Bytes.\n\n \\return          \\c 0 if the encryption or decryption was performed\n                  successfully. Note that in #MBEDTLS_GCM_DECRYPT mode,\n                  this does not indicate that the data is authentic.\n \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are\n                  not valid or a cipher-specific error code if the encryption\n                  or decryption failed."]
	pub fn mbedtls_gcm_crypt_and_tag(
		ctx: *mut mbedtls_gcm_context,
		mode: ::std::os::raw::c_int,
		length: usize,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		add: *const ::std::os::raw::c_uchar,
		add_len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
		tag_len: usize,
		tag: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs a GCM authenticated decryption of a\n                  buffer.\n\n \\note            For decryption, the output buffer cannot be the same as\n                  input buffer. If the buffers overlap, the output buffer\n                  must trail at least 8 Bytes behind the input buffer.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param length    The length of the ciphertext to decrypt, which is also\n                  the length of the decrypted plaintext.\n \\param iv        The initialization vector. This must be a readable buffer\n                  of at least \\p iv_len Bytes.\n \\param iv_len    The length of the IV.\n \\param add       The buffer holding the additional data. This must be of at\n                  least that size in Bytes.\n \\param add_len   The length of the additional data.\n \\param tag       The buffer holding the tag to verify. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the tag to verify.\n \\param input     The buffer holding the ciphertext. If \\p length is greater\n                  than zero, this must be a readable buffer of at least that\n                  size.\n \\param output    The buffer for holding the decrypted plaintext. If \\p length\n                  is greater than zero, this must be a writable buffer of at\n                  least that size.\n\n \\return          \\c 0 if successful and authenticated.\n \\return          #MBEDTLS_ERR_GCM_AUTH_FAILED if the tag does not match.\n \\return          #MBEDTLS_ERR_GCM_BAD_INPUT if the lengths or pointers are\n                  not valid or a cipher-specific error code if the decryption\n                  failed."]
	pub fn mbedtls_gcm_auth_decrypt(
		ctx: *mut mbedtls_gcm_context,
		length: usize,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		add: *const ::std::os::raw::c_uchar,
		add_len: usize,
		tag: *const ::std::os::raw::c_uchar,
		tag_len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function starts a GCM encryption or decryption\n                  operation.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param mode      The operation to perform: #MBEDTLS_GCM_ENCRYPT or\n                  #MBEDTLS_GCM_DECRYPT.\n \\param iv        The initialization vector. This must be a readable buffer of\n                  at least \\p iv_len Bytes.\n \\param iv_len    The length of the IV.\n\n \\return          \\c 0 on success."]
	pub fn mbedtls_gcm_starts(
		ctx: *mut mbedtls_gcm_context,
		mode: ::std::os::raw::c_int,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function feeds an input buffer as associated data\n                  (authenticated but not encrypted data) in a GCM\n                  encryption or decryption operation.\n\n                  Call this function after mbedtls_gcm_starts() to pass\n                  the associated data. If the associated data is empty,\n                  you do not need to call this function. You may not\n                  call this function after calling mbedtls_cipher_update().\n\n \\param ctx       The GCM context. This must have been started with\n                  mbedtls_gcm_starts() and must not have yet received\n                  any input with mbedtls_gcm_update().\n \\param add       The buffer holding the additional data, or \\c NULL\n                  if \\p add_len is \\c 0.\n \\param add_len   The length of the additional data. If \\c 0,\n                  \\p add may be \\c NULL.\n\n \\return          \\c 0 on success."]
	pub fn mbedtls_gcm_update_ad(
		ctx: *mut mbedtls_gcm_context,
		add: *const ::std::os::raw::c_uchar,
		add_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function feeds an input buffer into an ongoing GCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the input: the plaintext to\n                  encrypt, or the ciphertext (not including the tag) to\n                  decrypt. After the last part of the input, call\n                  mbedtls_gcm_finish().\n\n                  This function may produce output in one of the following\n                  ways:\n                  - Immediate output: the output length is always equal\n                    to the input length.\n                  - Buffered output: the output consists of a whole number\n                    of 16-byte blocks. If the total input length so far\n                    (not including associated data) is 16 \\* *B* + *A*\n                    with *A* < 16 then the total output length is 16 \\* *B*.\n\n                  In particular:\n                  - It is always correct to call this function with\n                    \\p output_size >= \\p input_length + 15.\n                  - If \\p input_length is a multiple of 16 for all the calls\n                    to this function during an operation, then it is\n                    correct to use \\p output_size = \\p input_length.\n\n \\note            For decryption, the output buffer cannot be the same as\n                  input buffer. If the buffers overlap, the output buffer\n                  must trail at least 8 Bytes behind the input buffer.\n\n \\param ctx           The GCM context. This must be initialized.\n \\param input         The buffer holding the input data. If \\p input_length\n                      is greater than zero, this must be a readable buffer\n                      of at least \\p input_length bytes.\n \\param input_length  The length of the input data in bytes.\n \\param output        The buffer for the output data. If \\p output_size\n                      is greater than zero, this must be a writable buffer of\n                      of at least \\p output_size bytes.\n \\param output_size   The size of the output buffer in bytes.\n                      See the function description regarding the output size.\n \\param output_length On success, \\p *output_length contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_length is\n                      unspecified.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_GCM_BAD_INPUT on failure:\n                 total input length too long,\n                 unsupported input/output buffer overlap detected,\n                 or \\p output_size too small."]
	pub fn mbedtls_gcm_update(
		ctx: *mut mbedtls_gcm_context,
		input: *const ::std::os::raw::c_uchar,
		input_length: usize,
		output: *mut ::std::os::raw::c_uchar,
		output_size: usize,
		output_length: *mut usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function finishes the GCM operation and generates\n                  the authentication tag.\n\n                  It wraps up the GCM stream, and generates the\n                  tag. The tag can have a maximum length of 16 Bytes.\n\n \\param ctx       The GCM context. This must be initialized.\n \\param tag       The buffer for holding the tag. This must be a writable\n                  buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the tag to generate. This must be at least\n                  four.\n \\param output    The buffer for the final output.\n                  If \\p output_size is nonzero, this must be a writable\n                  buffer of at least \\p output_size bytes.\n \\param output_size  The size of the \\p output buffer in bytes.\n                  This must be large enough for the output that\n                  mbedtls_gcm_update() has not produced. In particular:\n                  - If mbedtls_gcm_update() produces immediate output,\n                    or if the total input size is a multiple of \\c 16,\n                    then mbedtls_gcm_finish() never produces any output,\n                    so \\p output_size can be \\c 0.\n                  - \\p output_size never needs to be more than \\c 15.\n \\param output_length On success, \\p *output_length contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_length is\n                      unspecified.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_GCM_BAD_INPUT on failure:\n                  invalid value of \\p tag_len,\n                  or \\p output_size too small."]
	pub fn mbedtls_gcm_finish(
		ctx: *mut mbedtls_gcm_context,
		output: *mut ::std::os::raw::c_uchar,
		output_size: usize,
		output_length: *mut usize,
		tag: *mut ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function clears a GCM context and the underlying\n                  cipher sub-context.\n\n \\param ctx       The GCM context to clear. If this is \\c NULL, the call has\n                  no effect. Otherwise, this must be initialized."]
	pub fn mbedtls_gcm_free(ctx: *mut mbedtls_gcm_context);
}
extern "C" {
	#[doc = " \\brief          The GCM checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_gcm_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " \\brief    The CCM context-type definition. The CCM context is passed\n           to the APIs called."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ccm_context {
	pub private_y: [::std::os::raw::c_uchar; 16usize],
	pub private_ctr: [::std::os::raw::c_uchar; 16usize],
	pub private_cipher_ctx: mbedtls_cipher_context_t,
	pub private_plaintext_len: usize,
	pub private_add_len: usize,
	pub private_tag_len: usize,
	pub private_processed: usize,
	pub private_q: ::std::os::raw::c_uchar,
	pub private_mode: ::std::os::raw::c_uchar,
	pub private_state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mbedtls_ccm_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_ccm_context> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_ccm_context>(),
		168usize,
		concat!("Size of: ", stringify!(mbedtls_ccm_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_ccm_context>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_ccm_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_y) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_y)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctr) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_ctr)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cipher_ctx) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_cipher_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_plaintext_len) as usize - ptr as usize },
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_plaintext_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_add_len) as usize - ptr as usize },
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_add_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_tag_len) as usize - ptr as usize },
		144usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_tag_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_processed) as usize - ptr as usize },
		152usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_processed)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_q) as usize - ptr as usize },
		160usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_q)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_mode) as usize - ptr as usize },
		161usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_mode)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		164usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ccm_context),
			"::",
			stringify!(private_state)
		)
	);
}
extern "C" {
	#[doc = " \\brief           This function initializes the specified CCM context,\n                  to make references valid, and prepare the context\n                  for mbedtls_ccm_setkey() or mbedtls_ccm_free().\n\n \\param ctx       The CCM context to initialize. This must not be \\c NULL."]
	pub fn mbedtls_ccm_init(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
	#[doc = " \\brief           This function initializes the CCM context set in the\n                  \\p ctx parameter and sets the encryption key.\n\n \\param ctx       The CCM context to initialize. This must be an initialized\n                  context.\n \\param cipher    The 128-bit block cipher to use.\n \\param key       The encryption key. This must not be \\c NULL.\n \\param keybits   The key size in bits. This must be acceptable by the cipher.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
	pub fn mbedtls_ccm_setkey(
		ctx: *mut mbedtls_ccm_context,
		cipher: mbedtls_cipher_id_t,
		key: *const ::std::os::raw::c_uchar,
		keybits: ::std::os::raw::c_uint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief   This function releases and clears the specified CCM context\n          and underlying cipher sub-context.\n\n \\param ctx       The CCM context to clear. If this is \\c NULL, the function\n                  has no effect. Otherwise, this must be initialized."]
	pub fn mbedtls_ccm_free(ctx: *mut mbedtls_ccm_context);
}
extern "C" {
	#[doc = " \\brief           This function encrypts a buffer using CCM.\n\n \\note            The tag is written to a separate buffer. To concatenate\n                  the \\p tag with the \\p output, as done in <em>RFC-3610:\n                  Counter with CBC-MAC (CCM)</em>, use\n                  \\p tag = \\p output + \\p length, and make sure that the\n                  output buffer is at least \\p length + \\p tag_len wide.\n\n \\param ctx       The CCM context to use for encryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. If \\p ad_len is greater than\n                  zero, \\p ad must be a readable buffer of at least that\n                  length.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than `2^16 - 2^8`.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  writable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
	pub fn mbedtls_ccm_encrypt_and_tag(
		ctx: *mut mbedtls_ccm_context,
		length: usize,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
		tag: *mut ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function encrypts a buffer using CCM*.\n\n \\note            The tag is written to a separate buffer. To concatenate\n                  the \\p tag with the \\p output, as done in <em>RFC-3610:\n                  Counter with CBC-MAC (CCM)</em>, use\n                  \\p tag = \\p output + \\p length, and make sure that the\n                  output buffer is at least \\p length + \\p tag_len wide.\n\n \\note            When using this function in a variable tag length context,\n                  the tag length has to be encoded into the \\p iv passed to\n                  this function.\n\n \\param ctx       The CCM context to use for encryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n                  For tag length = 0, input length is ignored.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer of\n                  at least \\p ad_len Bytes.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  writable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  0, 4, 6, 8, 10, 12, 14 or 16.\n\n \\warning         Passing \\c 0 as \\p tag_len means that the message is no\n                  longer authenticated.\n\n \\return          \\c 0 on success.\n \\return          A CCM or cipher-specific error code on failure."]
	pub fn mbedtls_ccm_star_encrypt_and_tag(
		ctx: *mut mbedtls_ccm_context,
		length: usize,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
		tag: *mut ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs a CCM authenticated decryption of a\n                  buffer.\n\n \\param ctx       The CCM context to use for decryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer\n                  of at least that \\p ad_len Bytes..\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n\n \\return          \\c 0 on success. This indicates that the message is authentic.\n \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.\n \\return          A cipher-specific error code on calculation failure."]
	pub fn mbedtls_ccm_auth_decrypt(
		ctx: *mut mbedtls_ccm_context,
		length: usize,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
		tag: *const ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs a CCM* authenticated decryption of a\n                  buffer.\n\n \\note            When using this function in a variable tag length context,\n                  the tag length has to be decoded from \\p iv and passed to\n                  this function as \\p tag_len. (\\p tag needs to be adjusted\n                  accordingly.)\n\n \\param ctx       The CCM context to use for decryption. This must be\n                  initialized and bound to a key.\n \\param length    The length of the input data in Bytes.\n                  For tag length = 0, input length is ignored.\n \\param iv        The initialization vector (nonce). This must be a readable\n                  buffer of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n \\param ad        The additional data field. This must be a readable buffer of\n                  at least that \\p ad_len Bytes.\n \\param ad_len    The length of additional data in Bytes.\n                  This must be less than 2^16 - 2^8.\n \\param input     The buffer holding the input data. If \\p length is greater\n                  than zero, \\p input must be a readable buffer of at least\n                  that length.\n \\param output    The buffer holding the output data. If \\p length is greater\n                  than zero, \\p output must be a writable buffer of at least\n                  that length.\n \\param tag       The buffer holding the authentication field. This must be a\n                  readable buffer of at least \\p tag_len Bytes.\n \\param tag_len   The length of the authentication field in Bytes.\n                  0, 4, 6, 8, 10, 12, 14 or 16.\n\n \\warning         Passing \\c 0 as \\p tag_len means that the message is nos\n                  longer authenticated.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_AUTH_FAILED if the tag does not match.\n \\return          A cipher-specific error code on calculation failure."]
	pub fn mbedtls_ccm_star_auth_decrypt(
		ctx: *mut mbedtls_ccm_context,
		length: usize,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
		tag: *const ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function starts a CCM encryption or decryption\n                  operation.\n\n                  This function and mbedtls_ccm_set_lengths() must be called\n                  before calling mbedtls_ccm_update_ad() or\n                  mbedtls_ccm_update(). This function can be called before\n                  or after mbedtls_ccm_set_lengths().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must be initialized.\n \\param mode      The operation to perform: #MBEDTLS_CCM_ENCRYPT or\n                  #MBEDTLS_CCM_DECRYPT or #MBEDTLS_CCM_STAR_ENCRYPT or\n                  #MBEDTLS_CCM_STAR_DECRYPT.\n \\param iv        The initialization vector. This must be a readable buffer\n                  of at least \\p iv_len Bytes.\n \\param iv_len    The length of the nonce in Bytes: 7, 8, 9, 10, 11, 12,\n                  or 13. The length L of the message length field is\n                  15 - \\p iv_len.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  \\p mode is invalid,\n                  \\p iv_len is invalid (lower than \\c 7 or greater than\n                  \\c 13)."]
	pub fn mbedtls_ccm_starts(
		ctx: *mut mbedtls_ccm_context,
		mode: ::std::os::raw::c_int,
		iv: *const ::std::os::raw::c_uchar,
		iv_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function declares the lengths of the message\n                  and additional data for a CCM encryption or decryption\n                  operation.\n\n                  This function and mbedtls_ccm_starts() must be called\n                  before calling mbedtls_ccm_update_ad() or\n                  mbedtls_ccm_update(). This function can be called before\n                  or after mbedtls_ccm_starts().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must be initialized.\n \\param total_ad_len   The total length of additional data in bytes.\n                       This must be less than `2^16 - 2^8`.\n \\param plaintext_len  The length in bytes of the plaintext to encrypt or\n                       result of the decryption (thus not encompassing the\n                       additional data that are not encrypted).\n \\param tag_len   The length of the tag to generate in Bytes:\n                  4, 6, 8, 10, 12, 14 or 16.\n                  For CCM*, zero is also valid.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  \\p total_ad_len is greater than \\c 0xFF00."]
	pub fn mbedtls_ccm_set_lengths(
		ctx: *mut mbedtls_ccm_context,
		total_ad_len: usize,
		plaintext_len: usize,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function feeds an input buffer as associated data\n                  (authenticated but not encrypted data) in a CCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the additional data. The\n                  lengths \\p ad_len of the data parts should eventually add\n                  up exactly to the total length of additional data\n                  \\c total_ad_len passed to mbedtls_ccm_set_lengths(). You\n                  may not call this function after calling\n                  mbedtls_ccm_update().\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must have been started with\n                  mbedtls_ccm_starts(), the lengths of the message and\n                  additional data must have been declared with\n                  mbedtls_ccm_set_lengths() and this must not have yet\n                  received any input with mbedtls_ccm_update().\n \\param ad        The buffer holding the additional data, or \\c NULL\n                  if \\p ad_len is \\c 0.\n \\param ad_len    The length of the additional data. If \\c 0,\n                  \\p ad may be \\c NULL.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  total input length too long."]
	pub fn mbedtls_ccm_update_ad(
		ctx: *mut mbedtls_ccm_context,
		ad: *const ::std::os::raw::c_uchar,
		ad_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function feeds an input buffer into an ongoing CCM\n                  encryption or decryption operation.\n\n                  You may call this function zero, one or more times\n                  to pass successive parts of the input: the plaintext to\n                  encrypt, or the ciphertext (not including the tag) to\n                  decrypt. After the last part of the input, call\n                  mbedtls_ccm_finish(). The lengths \\p input_len of the\n                  data parts should eventually add up exactly to the\n                  plaintext length \\c plaintext_len passed to\n                  mbedtls_ccm_set_lengths().\n\n                  This function may produce output in one of the following\n                  ways:\n                  - Immediate output: the output length is always equal\n                    to the input length.\n                  - Buffered output: except for the last part of input data,\n                    the output consists of a whole number of 16-byte blocks.\n                    If the total input length so far (not including\n                    associated data) is 16 \\* *B* + *A* with *A* < 16 then\n                    the total output length is 16 \\* *B*.\n                    For the last part of input data, the output length is\n                    equal to the input length plus the number of bytes (*A*)\n                    buffered in the previous call to the function (if any).\n                    The function uses the plaintext length\n                    \\c plaintext_len passed to mbedtls_ccm_set_lengths()\n                    to detect the last part of input data.\n\n                  In particular:\n                  - It is always correct to call this function with\n                    \\p output_size >= \\p input_len + 15.\n                  - If \\p input_len is a multiple of 16 for all the calls\n                    to this function during an operation (not necessary for\n                    the last one) then it is correct to use \\p output_size\n                    =\\p input_len.\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx           The CCM context. This must have been started with\n                      mbedtls_ccm_starts() and the lengths of the message and\n                      additional data must have been declared with\n                      mbedtls_ccm_set_lengths().\n \\param input         The buffer holding the input data. If \\p input_len\n                      is greater than zero, this must be a readable buffer\n                      of at least \\p input_len bytes.\n \\param input_len     The length of the input data in bytes.\n \\param output        The buffer for the output data. If \\p output_size\n                      is greater than zero, this must be a writable buffer of\n                      at least \\p output_size bytes.\n \\param output_size   The size of the output buffer in bytes.\n                      See the function description regarding the output size.\n \\param output_len    On success, \\p *output_len contains the actual\n                      length of the output written in \\p output.\n                      On failure, the content of \\p *output_len is\n                      unspecified.\n\n \\return         \\c 0 on success.\n \\return         #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                 \\p ctx is in an invalid state,\n                 total input length too long,\n                 or \\p output_size too small."]
	pub fn mbedtls_ccm_update(
		ctx: *mut mbedtls_ccm_context,
		input: *const ::std::os::raw::c_uchar,
		input_len: usize,
		output: *mut ::std::os::raw::c_uchar,
		output_size: usize,
		output_len: *mut usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function finishes the CCM operation and generates\n                  the authentication tag.\n\n                  It wraps up the CCM stream, and generates the\n                  tag. The tag can have a maximum length of 16 Bytes.\n\n \\note            This function is not implemented in Mbed TLS yet.\n\n \\param ctx       The CCM context. This must have been started with\n                  mbedtls_ccm_starts() and the lengths of the message and\n                  additional data must have been declared with\n                  mbedtls_ccm_set_lengths().\n \\param tag       The buffer for holding the tag. If \\p tag_len is greater\n                  than zero, this must be a writable buffer of at least \\p\n                  tag_len Bytes.\n \\param tag_len   The length of the tag. Must match the tag length passed to\n                  mbedtls_ccm_set_lengths() function.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CCM_BAD_INPUT on failure:\n                  \\p ctx is in an invalid state,\n                  invalid value of \\p tag_len,\n                  the total amount of additional data passed to\n                  mbedtls_ccm_update_ad() was lower than the total length of\n                  additional data \\c total_ad_len passed to\n                  mbedtls_ccm_set_lengths(),\n                  the total amount of input data passed to\n                  mbedtls_ccm_update() was lower than the plaintext length\n                  \\c plaintext_len passed to mbedtls_ccm_set_lengths()."]
	pub fn mbedtls_ccm_finish(
		ctx: *mut mbedtls_ccm_context,
		tag: *mut ::std::os::raw::c_uchar,
		tag_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The CCM checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_ccm_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_poly1305_context {
	pub private_r: [u32; 4usize],
	pub private_s: [u32; 4usize],
	pub private_acc: [u32; 5usize],
	pub private_queue: [u8; 16usize],
	pub private_queue_len: usize,
}
#[test]
fn bindgen_test_layout_mbedtls_poly1305_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_poly1305_context> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_poly1305_context>(),
		80usize,
		concat!("Size of: ", stringify!(mbedtls_poly1305_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_poly1305_context>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_poly1305_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_r) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_poly1305_context),
			"::",
			stringify!(private_r)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_s) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_poly1305_context),
			"::",
			stringify!(private_s)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_acc) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_poly1305_context),
			"::",
			stringify!(private_acc)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_queue) as usize - ptr as usize },
		52usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_poly1305_context),
			"::",
			stringify!(private_queue)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_queue_len) as usize - ptr as usize },
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_poly1305_context),
			"::",
			stringify!(private_queue_len)
		)
	);
}
extern "C" {
	#[doc = " \\brief           This function initializes the specified Poly1305 context.\n\n                  It must be the first API called before using\n                  the context.\n\n                  It is usually followed by a call to\n                  \\c mbedtls_poly1305_starts(), then one or more calls to\n                  \\c mbedtls_poly1305_update(), then one call to\n                  \\c mbedtls_poly1305_finish(), then finally\n                  \\c mbedtls_poly1305_free().\n\n \\param ctx       The Poly1305 context to initialize. This must\n                  not be \\c NULL."]
	pub fn mbedtls_poly1305_init(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
	#[doc = " \\brief           This function releases and clears the specified\n                  Poly1305 context.\n\n \\param ctx       The Poly1305 context to clear. This may be \\c NULL, in which\n                  case this function is a no-op. If it is not \\c NULL, it must\n                  point to an initialized Poly1305 context."]
	pub fn mbedtls_poly1305_free(ctx: *mut mbedtls_poly1305_context);
}
extern "C" {
	#[doc = " \\brief           This function sets the one-time authentication key.\n\n \\warning         The key must be unique and unpredictable for each\n                  invocation of Poly1305.\n\n \\param ctx       The Poly1305 context to which the key should be bound.\n                  This must be initialized.\n \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_poly1305_starts(
		ctx: *mut mbedtls_poly1305_context,
		key: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This functions feeds an input buffer into an ongoing\n                  Poly1305 computation.\n\n                  It is called between \\c mbedtls_cipher_poly1305_starts() and\n                  \\c mbedtls_cipher_poly1305_finish().\n                  It can be called repeatedly to process a stream of data.\n\n \\param ctx       The Poly1305 context to use for the Poly1305 operation.\n                  This must be initialized and bound to a key.\n \\param ilen      The length of the input data in Bytes.\n                  Any value is accepted.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `ilen == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_poly1305_update(
		ctx: *mut mbedtls_poly1305_context,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function generates the Poly1305 Message\n                  Authentication Code (MAC).\n\n \\param ctx       The Poly1305 context to use for the Poly1305 operation.\n                  This must be initialized and bound to a key.\n \\param mac       The buffer to where the MAC is written. This must\n                  be a writable buffer of length \\c 16 Bytes.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_poly1305_finish(
		ctx: *mut mbedtls_poly1305_context,
		mac: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function calculates the Poly1305 MAC of the input\n                  buffer with the provided key.\n\n \\warning         The key must be unique and unpredictable for each\n                  invocation of Poly1305.\n\n \\param key       The buffer containing the \\c 32 Byte (\\c 256 Bit) key.\n \\param ilen      The length of the input data in Bytes.\n                  Any value is accepted.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param mac       The buffer to where the MAC is written. This must be\n                  a writable buffer of length \\c 16 Bytes.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_poly1305_mac(
		key: *const ::std::os::raw::c_uchar,
		input: *const ::std::os::raw::c_uchar,
		ilen: usize,
		mac: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           The Poly1305 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
	pub fn mbedtls_poly1305_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = "< The mode value for performing encryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_ENCRYPT: mbedtls_chachapoly_mode_t = 0;
#[doc = "< The mode value for performing decryption."]
pub const mbedtls_chachapoly_mode_t_MBEDTLS_CHACHAPOLY_DECRYPT: mbedtls_chachapoly_mode_t = 1;
pub type mbedtls_chachapoly_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_chacha20_context {
	pub private_state: [u32; 16usize],
	pub private_keystream8: [u8; 64usize],
	pub private_keystream_bytes_used: usize,
}
#[test]
fn bindgen_test_layout_mbedtls_chacha20_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_chacha20_context> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_chacha20_context>(),
		136usize,
		concat!("Size of: ", stringify!(mbedtls_chacha20_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_chacha20_context>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_chacha20_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chacha20_context),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_keystream8) as usize - ptr as usize },
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chacha20_context),
			"::",
			stringify!(private_keystream8)
		)
	);
	assert_eq!(
		unsafe {
			::std::ptr::addr_of!((*ptr).private_keystream_bytes_used) as usize - ptr as usize
		},
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chacha20_context),
			"::",
			stringify!(private_keystream_bytes_used)
		)
	);
}
extern "C" {
	#[doc = " \\brief           This function initializes the specified ChaCha20 context.\n\n                  It must be the first API called before using\n                  the context.\n\n                  It is usually followed by calls to\n                  \\c mbedtls_chacha20_setkey() and\n                  \\c mbedtls_chacha20_starts(), then one or more calls to\n                  to \\c mbedtls_chacha20_update(), and finally to\n                  \\c mbedtls_chacha20_free().\n\n \\param ctx       The ChaCha20 context to initialize.\n                  This must not be \\c NULL."]
	pub fn mbedtls_chacha20_init(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
	#[doc = " \\brief           This function releases and clears the specified\n                  ChaCha20 context.\n\n \\param ctx       The ChaCha20 context to clear. This may be \\c NULL,\n                  in which case this function is a no-op. If it is not\n                  \\c NULL, it must point to an initialized context.\n"]
	pub fn mbedtls_chacha20_free(ctx: *mut mbedtls_chacha20_context);
}
extern "C" {
	#[doc = " \\brief           This function sets the encryption/decryption key.\n\n \\note            After using this function, you must also call\n                  \\c mbedtls_chacha20_starts() to set a nonce before you\n                  start encrypting/decrypting data with\n                  \\c mbedtls_chacha_update().\n\n \\param ctx       The ChaCha20 context to which the key should be bound.\n                  It must be initialized.\n \\param key       The encryption/decryption key. This must be \\c 32 Bytes\n                  in length.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or key is NULL."]
	pub fn mbedtls_chacha20_setkey(
		ctx: *mut mbedtls_chacha20_context,
		key: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function sets the nonce and initial counter value.\n\n \\note            A ChaCha20 context can be re-used with the same key by\n                  calling this function to change the nonce.\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality guarantees for the\n                  messages encrypted with the same nonce and key.\n\n \\param ctx       The ChaCha20 context to which the nonce should be bound.\n                  It must be initialized and bound to a key.\n \\param nonce     The nonce. This must be \\c 12 Bytes in size.\n \\param counter   The initial counter value. This is usually \\c 0.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHA20_BAD_INPUT_DATA if ctx or nonce is\n                  NULL."]
	pub fn mbedtls_chacha20_starts(
		ctx: *mut mbedtls_chacha20_context,
		nonce: *const ::std::os::raw::c_uchar,
		counter: u32,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function encrypts or decrypts data.\n\n                  Since ChaCha20 is a stream cipher, the same operation is\n                  used for encrypting and decrypting data.\n\n \\note            The \\p input and \\p output pointers must either be equal or\n                  point to non-overlapping buffers.\n\n \\note            \\c mbedtls_chacha20_setkey() and\n                  \\c mbedtls_chacha20_starts() must be called at least once\n                  to setup the context before this function can be called.\n\n \\note            This function can be called multiple times in a row in\n                  order to encrypt of decrypt data piecewise with the same\n                  key and nonce.\n\n \\param ctx       The ChaCha20 context to use for encryption or decryption.\n                  It must be initialized and bound to a key and nonce.\n \\param size      The length of the input data in Bytes.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `size == 0`.\n \\param output    The buffer holding the output data.\n                  This must be able to hold \\p size Bytes.\n                  This pointer can be \\c NULL if `size == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_chacha20_update(
		ctx: *mut mbedtls_chacha20_context,
		size: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function encrypts or decrypts data with ChaCha20 and\n                  the given key and nonce.\n\n                  Since ChaCha20 is a stream cipher, the same operation is\n                  used for encrypting and decrypting data.\n\n \\warning         You must never use the same (key, nonce) pair more than\n                  once. This would void any confidentiality guarantees for\n                  the messages encrypted with the same nonce and key.\n\n \\note            The \\p input and \\p output pointers must either be equal or\n                  point to non-overlapping buffers.\n\n \\param key       The encryption/decryption key.\n                  This must be \\c 32 Bytes in length.\n \\param nonce     The nonce. This must be \\c 12 Bytes in size.\n \\param counter   The initial counter value. This is usually \\c 0.\n \\param size      The length of the input data in Bytes.\n \\param input     The buffer holding the input data.\n                  This pointer can be \\c NULL if `size == 0`.\n \\param output    The buffer holding the output data.\n                  This must be able to hold \\p size Bytes.\n                  This pointer can be \\c NULL if `size == 0`.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_chacha20_crypt(
		key: *const ::std::os::raw::c_uchar,
		nonce: *const ::std::os::raw::c_uchar,
		counter: u32,
		size: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           The ChaCha20 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
	pub fn mbedtls_chacha20_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_chachapoly_context {
	pub private_chacha20_ctx: mbedtls_chacha20_context,
	pub private_poly1305_ctx: mbedtls_poly1305_context,
	pub private_aad_len: u64,
	pub private_ciphertext_len: u64,
	pub private_state: ::std::os::raw::c_int,
	pub private_mode: mbedtls_chachapoly_mode_t,
}
#[test]
fn bindgen_test_layout_mbedtls_chachapoly_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_chachapoly_context> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_chachapoly_context>(),
		240usize,
		concat!("Size of: ", stringify!(mbedtls_chachapoly_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_chachapoly_context>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_chachapoly_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_chacha20_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chachapoly_context),
			"::",
			stringify!(private_chacha20_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_poly1305_ctx) as usize - ptr as usize },
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chachapoly_context),
			"::",
			stringify!(private_poly1305_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_aad_len) as usize - ptr as usize },
		216usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chachapoly_context),
			"::",
			stringify!(private_aad_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ciphertext_len) as usize - ptr as usize },
		224usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chachapoly_context),
			"::",
			stringify!(private_ciphertext_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		232usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chachapoly_context),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_mode) as usize - ptr as usize },
		236usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_chachapoly_context),
			"::",
			stringify!(private_mode)
		)
	);
}
extern "C" {
	#[doc = " \\brief           This function initializes the specified ChaCha20-Poly1305 context.\n\n                  It must be the first API called before using\n                  the context. It must be followed by a call to\n                  \\c mbedtls_chachapoly_setkey() before any operation can be\n                  done, and to \\c mbedtls_chachapoly_free() once all\n                  operations with that context have been finished.\n\n                  In order to encrypt or decrypt full messages at once, for\n                  each message you should make a single call to\n                  \\c mbedtls_chachapoly_crypt_and_tag() or\n                  \\c mbedtls_chachapoly_auth_decrypt().\n\n                  In order to encrypt messages piecewise, for each\n                  message you should make a call to\n                  \\c mbedtls_chachapoly_starts(), then 0 or more calls to\n                  \\c mbedtls_chachapoly_update_aad(), then 0 or more calls to\n                  \\c mbedtls_chachapoly_update(), then one call to\n                  \\c mbedtls_chachapoly_finish().\n\n \\warning         Decryption with the piecewise API is discouraged! Always\n                  use \\c mbedtls_chachapoly_auth_decrypt() when possible!\n\n                  If however this is not possible because the data is too\n                  large to fit in memory, you need to:\n\n                  - call \\c mbedtls_chachapoly_starts() and (if needed)\n                  \\c mbedtls_chachapoly_update_aad() as above,\n                  - call \\c mbedtls_chachapoly_update() multiple times and\n                  ensure its output (the plaintext) is NOT used in any other\n                  way than placing it in temporary storage at this point,\n                  - call \\c mbedtls_chachapoly_finish() to compute the\n                  authentication tag and compared it in constant time to the\n                  tag received with the ciphertext.\n\n                  If the tags are not equal, you must immediately discard\n                  all previous outputs of \\c mbedtls_chachapoly_update(),\n                  otherwise you can now safely use the plaintext.\n\n \\param ctx       The ChachaPoly context to initialize. Must not be \\c NULL."]
	pub fn mbedtls_chachapoly_init(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
	#[doc = " \\brief           This function releases and clears the specified\n                  ChaCha20-Poly1305 context.\n\n \\param ctx       The ChachaPoly context to clear. This may be \\c NULL, in which\n                  case this function is a no-op."]
	pub fn mbedtls_chachapoly_free(ctx: *mut mbedtls_chachapoly_context);
}
extern "C" {
	#[doc = " \\brief           This function sets the ChaCha20-Poly1305\n                  symmetric encryption key.\n\n \\param ctx       The ChaCha20-Poly1305 context to which the key should be\n                  bound. This must be initialized.\n \\param key       The \\c 256 Bit (\\c 32 Bytes) key.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_chachapoly_setkey(
		ctx: *mut mbedtls_chachapoly_context,
		key: *const ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function starts a ChaCha20-Poly1305 encryption or\n                  decryption operation.\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality and authenticity\n                  guarantees for the messages encrypted with the same nonce\n                  and key.\n\n \\note            If the context is being used for AAD only (no data to\n                  encrypt or decrypt) then \\p mode can be set to any value.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context. This must be initialized\n                  and bound to a key.\n \\param nonce     The nonce/IV to use for the message.\n                  This must be a readable buffer of length \\c 12 Bytes.\n \\param mode      The operation to perform: #MBEDTLS_CHACHAPOLY_ENCRYPT or\n                  #MBEDTLS_CHACHAPOLY_DECRYPT (discouraged, see warning).\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_chachapoly_starts(
		ctx: *mut mbedtls_chachapoly_context,
		nonce: *const ::std::os::raw::c_uchar,
		mode: mbedtls_chachapoly_mode_t,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function feeds additional data to be authenticated\n                  into an ongoing ChaCha20-Poly1305 operation.\n\n                  The Additional Authenticated Data (AAD), also called\n                  Associated Data (AD) is only authenticated but not\n                  encrypted nor included in the encrypted output. It is\n                  usually transmitted separately from the ciphertext or\n                  computed locally by each party.\n\n \\note            This function is called before data is encrypted/decrypted.\n                  I.e. call this function to process the AAD before calling\n                  \\c mbedtls_chachapoly_update().\n\n                  You may call this function multiple times to process\n                  an arbitrary amount of AAD. It is permitted to call\n                  this function 0 times, if no AAD is used.\n\n                  This function cannot be called any more if data has\n                  been processed by \\c mbedtls_chachapoly_update(),\n                  or if the context has been finished.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context. This must be initialized\n                  and bound to a key.\n \\param aad_len   The length in Bytes of the AAD. The length has no\n                  restrictions.\n \\param aad       Buffer containing the AAD.\n                  This pointer can be \\c NULL if `aad_len == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_POLY1305_BAD_INPUT_DATA\n                  if \\p ctx or \\p aad are NULL.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operations has not been started or has been\n                  finished, or if the AAD has been finished."]
	pub fn mbedtls_chachapoly_update_aad(
		ctx: *mut mbedtls_chachapoly_context,
		aad: *const ::std::os::raw::c_uchar,
		aad_len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Thus function feeds data to be encrypted or decrypted\n                  into an on-going ChaCha20-Poly1305\n                  operation.\n\n                  The direction (encryption or decryption) depends on the\n                  mode that was given when calling\n                  \\c mbedtls_chachapoly_starts().\n\n                  You may call this function multiple times to process\n                  an arbitrary amount of data. It is permitted to call\n                  this function 0 times, if no data is to be encrypted\n                  or decrypted.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.\n \\param len       The length (in bytes) of the data to encrypt or decrypt.\n \\param input     The buffer containing the data to encrypt or decrypt.\n                  This pointer can be \\c NULL if `len == 0`.\n \\param output    The buffer to where the encrypted or decrypted data is\n                  written. This must be able to hold \\p len bytes.\n                  This pointer can be \\c NULL if `len == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operation has not been started or has been\n                  finished.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_chachapoly_update(
		ctx: *mut mbedtls_chachapoly_context,
		len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function finished the ChaCha20-Poly1305 operation and\n                  generates the MAC (authentication tag).\n\n \\param ctx       The ChaCha20-Poly1305 context to use. This must be initialized.\n \\param mac       The buffer to where the 128-bit (16 bytes) MAC is written.\n\n \\warning         Decryption with the piecewise API is discouraged, see the\n                  warning on \\c mbedtls_chachapoly_init().\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_BAD_STATE\n                  if the operation has not been started or has been\n                  finished.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_chachapoly_finish(
		ctx: *mut mbedtls_chachapoly_context,
		mac: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs a complete ChaCha20-Poly1305\n                  authenticated encryption with the previously-set key.\n\n \\note            Before using this function, you must set the key with\n                  \\c mbedtls_chachapoly_setkey().\n\n \\warning         You must never use the same nonce twice with the same key.\n                  This would void any confidentiality and authenticity\n                  guarantees for the messages encrypted with the same nonce\n                  and key.\n\n \\param ctx       The ChaCha20-Poly1305 context to use (holds the key).\n                  This must be initialized.\n \\param length    The length (in bytes) of the data to encrypt or decrypt.\n \\param nonce     The 96-bit (12 bytes) nonce/IV to use.\n \\param aad       The buffer containing the additional authenticated\n                  data (AAD). This pointer can be \\c NULL if `aad_len == 0`.\n \\param aad_len   The length (in bytes) of the AAD data to process.\n \\param input     The buffer containing the data to encrypt or decrypt.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param output    The buffer to where the encrypted or decrypted data\n                  is written. This pointer can be \\c NULL if `ilen == 0`.\n \\param tag       The buffer to where the computed 128-bit (16 bytes) MAC\n                  is written. This must not be \\c NULL.\n\n \\return          \\c 0 on success.\n \\return          A negative error code on failure."]
	pub fn mbedtls_chachapoly_encrypt_and_tag(
		ctx: *mut mbedtls_chachapoly_context,
		length: usize,
		nonce: *const ::std::os::raw::c_uchar,
		aad: *const ::std::os::raw::c_uchar,
		aad_len: usize,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
		tag: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs a complete ChaCha20-Poly1305\n                  authenticated decryption with the previously-set key.\n\n \\note            Before using this function, you must set the key with\n                  \\c mbedtls_chachapoly_setkey().\n\n \\param ctx       The ChaCha20-Poly1305 context to use (holds the key).\n \\param length    The length (in Bytes) of the data to decrypt.\n \\param nonce     The \\c 96 Bit (\\c 12 bytes) nonce/IV to use.\n \\param aad       The buffer containing the additional authenticated data (AAD).\n                  This pointer can be \\c NULL if `aad_len == 0`.\n \\param aad_len   The length (in bytes) of the AAD data to process.\n \\param tag       The buffer holding the authentication tag.\n                  This must be a readable buffer of length \\c 16 Bytes.\n \\param input     The buffer containing the data to decrypt.\n                  This pointer can be \\c NULL if `ilen == 0`.\n \\param output    The buffer to where the decrypted data is written.\n                  This pointer can be \\c NULL if `ilen == 0`.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_CHACHAPOLY_AUTH_FAILED\n                  if the data was not authentic.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_chachapoly_auth_decrypt(
		ctx: *mut mbedtls_chachapoly_context,
		length: usize,
		nonce: *const ::std::os::raw::c_uchar,
		aad: *const ::std::os::raw::c_uchar,
		aad_len: usize,
		tag: *const ::std::os::raw::c_uchar,
		input: *const ::std::os::raw::c_uchar,
		output: *mut ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           The ChaCha20-Poly1305 checkup routine.\n\n \\return          \\c 0 on success.\n \\return          \\c 1 on failure."]
	pub fn mbedtls_chachapoly_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_hmac_operation_t {
	pub private_alg: psa_algorithm_t,
	#[doc = " The hash context."]
	pub hash_ctx: psa_hash_operation_s,
	pub private_opad: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_mbedtls_psa_hmac_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_hmac_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_hmac_operation_t>(),
		368usize,
		concat!("Size of: ", stringify!(mbedtls_psa_hmac_operation_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_hmac_operation_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_psa_hmac_operation_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hmac_operation_t),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hmac_operation_t),
			"::",
			stringify!(hash_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_opad) as usize - ptr as usize },
		240usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_hmac_operation_t),
			"::",
			stringify!(private_opad)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_mac_operation_t {
	pub private_alg: psa_algorithm_t,
	pub private_ctx: mbedtls_psa_mac_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_mac_operation_t__bindgen_ty_1 {
	pub private_dummy: ::std::os::raw::c_uint,
	pub private_hmac: mbedtls_psa_hmac_operation_t,
	pub private_cmac: mbedtls_cipher_context_t,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_mac_operation_t__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_mac_operation_t__bindgen_ty_1> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_mac_operation_t__bindgen_ty_1>(),
		368usize,
		concat!(
			"Size of: ",
			stringify!(mbedtls_psa_mac_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_mac_operation_t__bindgen_ty_1>(),
		8usize,
		concat!(
			"Alignment of ",
			stringify!(mbedtls_psa_mac_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_mac_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_hmac) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_mac_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_hmac)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cmac) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_mac_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_cmac)
		)
	);
}
#[test]
fn bindgen_test_layout_mbedtls_psa_mac_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_mac_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_mac_operation_t>(),
		376usize,
		concat!("Size of: ", stringify!(mbedtls_psa_mac_operation_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_mac_operation_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_psa_mac_operation_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_mac_operation_t),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_mac_operation_t),
			"::",
			stringify!(private_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_aead_operation_t {
	pub private_alg: psa_algorithm_t,
	pub private_key_type: psa_key_type_t,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_tag_length: u8,
	pub ctx: mbedtls_psa_aead_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_aead_operation_t__bindgen_ty_1 {
	pub dummy: ::std::os::raw::c_uint,
	pub private_ccm: mbedtls_ccm_context,
	pub private_gcm: mbedtls_gcm_context,
	pub private_chachapoly: mbedtls_chachapoly_context,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_aead_operation_t__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_aead_operation_t__bindgen_ty_1> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_aead_operation_t__bindgen_ty_1>(),
		424usize,
		concat!(
			"Size of: ",
			stringify!(mbedtls_psa_aead_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_aead_operation_t__bindgen_ty_1>(),
		8usize,
		concat!(
			"Alignment of ",
			stringify!(mbedtls_psa_aead_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t__bindgen_ty_1),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ccm) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_ccm)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_gcm) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_gcm)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_chachapoly) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_chachapoly)
		)
	);
}
#[test]
fn bindgen_test_layout_mbedtls_psa_aead_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_aead_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_aead_operation_t>(),
		432usize,
		concat!("Size of: ", stringify!(mbedtls_psa_aead_operation_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_aead_operation_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_psa_aead_operation_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_key_type) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t),
			"::",
			stringify!(private_key_type)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_tag_length) as usize - ptr as usize },
		7usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t),
			"::",
			stringify!(private_tag_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_aead_operation_t),
			"::",
			stringify!(ctx)
		)
	);
}
impl mbedtls_psa_aead_operation_t {
	#[inline]
	pub fn private_is_encrypt(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_is_encrypt(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_is_encrypt: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			let private_is_encrypt: u32 = unsafe { ::std::mem::transmute(private_is_encrypt) };
			private_is_encrypt as u64
		});
		__bindgen_bitfield_unit
	}
}
pub type va_list = __darwin_va_list;
extern "C" {
	pub fn renameat(
		arg1: ::std::os::raw::c_int,
		arg2: *const ::std::os::raw::c_char,
		arg3: ::std::os::raw::c_int,
		arg4: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn renamex_np(
		arg1: *const ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: ::std::os::raw::c_uint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn renameatx_np(
		arg1: ::std::os::raw::c_int,
		arg2: *const ::std::os::raw::c_char,
		arg3: ::std::os::raw::c_int,
		arg4: *const ::std::os::raw::c_char,
		arg5: ::std::os::raw::c_uint,
	) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
	pub _base: *mut ::std::os::raw::c_uchar,
	pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
	const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__sbuf>(),
		16usize,
		concat!("Size of: ", stringify!(__sbuf))
	);
	assert_eq!(
		::std::mem::align_of::<__sbuf>(),
		8usize,
		concat!("Alignment of ", stringify!(__sbuf))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__sbuf),
			"::",
			stringify!(_base)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__sbuf),
			"::",
			stringify!(_size)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
	_unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
	pub _p: *mut ::std::os::raw::c_uchar,
	pub _r: ::std::os::raw::c_int,
	pub _w: ::std::os::raw::c_int,
	pub _flags: ::std::os::raw::c_short,
	pub _file: ::std::os::raw::c_short,
	pub _bf: __sbuf,
	pub _lbfsize: ::std::os::raw::c_int,
	pub _cookie: *mut ::std::os::raw::c_void,
	pub _close: ::std::option::Option<
		unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
	>,
	pub _read: ::std::option::Option<
		unsafe extern "C" fn(
			arg1: *mut ::std::os::raw::c_void,
			arg2: *mut ::std::os::raw::c_char,
			arg3: ::std::os::raw::c_int,
		) -> ::std::os::raw::c_int,
	>,
	pub _seek: ::std::option::Option<
		unsafe extern "C" fn(
			arg1: *mut ::std::os::raw::c_void,
			arg2: fpos_t,
			arg3: ::std::os::raw::c_int,
		) -> fpos_t,
	>,
	pub _write: ::std::option::Option<
		unsafe extern "C" fn(
			arg1: *mut ::std::os::raw::c_void,
			arg2: *const ::std::os::raw::c_char,
			arg3: ::std::os::raw::c_int,
		) -> ::std::os::raw::c_int,
	>,
	pub _ub: __sbuf,
	pub _extra: *mut __sFILEX,
	pub _ur: ::std::os::raw::c_int,
	pub _ubuf: [::std::os::raw::c_uchar; 3usize],
	pub _nbuf: [::std::os::raw::c_uchar; 1usize],
	pub _lb: __sbuf,
	pub _blksize: ::std::os::raw::c_int,
	pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
	const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<__sFILE>(),
		152usize,
		concat!("Size of: ", stringify!(__sFILE))
	);
	assert_eq!(
		::std::mem::align_of::<__sFILE>(),
		8usize,
		concat!("Alignment of ", stringify!(__sFILE))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_p)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_r)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_w)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_flags)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
		18usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_file)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_bf)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_lbfsize)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_cookie)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_close)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_read)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_seek)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
		80usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_write)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
		88usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_ub)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
		104usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_extra)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
		112usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_ur)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
		116usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_ubuf)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
		119usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_nbuf)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
		120usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_lb)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_blksize)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
		144usize,
		concat!(
			"Offset of field: ",
			stringify!(__sFILE),
			"::",
			stringify!(_offset)
		)
	);
}
pub type FILE = __sFILE;
extern "C" {
	pub static mut __stdinp: *mut FILE;
}
extern "C" {
	pub static mut __stdoutp: *mut FILE;
}
extern "C" {
	pub static mut __stderrp: *mut FILE;
}
extern "C" {
	pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
	pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fgets(
		arg1: *mut ::std::os::raw::c_char,
		arg2: ::std::os::raw::c_int,
		arg3: *mut FILE,
	) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn fopen(
		__filename: *const ::std::os::raw::c_char,
		__mode: *const ::std::os::raw::c_char,
	) -> *mut FILE;
}
extern "C" {
	pub fn fprintf(
		arg1: *mut FILE,
		arg2: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fread(
		__ptr: *mut ::std::os::raw::c_void,
		__size: ::std::os::raw::c_ulong,
		__nitems: ::std::os::raw::c_ulong,
		__stream: *mut FILE,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn freopen(
		arg1: *const ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: *mut FILE,
	) -> *mut FILE;
}
extern "C" {
	pub fn fscanf(
		arg1: *mut FILE,
		arg2: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fseek(
		arg1: *mut FILE,
		arg2: ::std::os::raw::c_long,
		arg3: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
	pub fn fwrite(
		__ptr: *const ::std::os::raw::c_void,
		__size: ::std::os::raw::c_ulong,
		__nitems: ::std::os::raw::c_ulong,
		__stream: *mut FILE,
	) -> ::std::os::raw::c_ulong;
}
extern "C" {
	pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
	pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn rename(
		__old: *const ::std::os::raw::c_char,
		__new: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn rewind(arg1: *mut FILE);
}
extern "C" {
	pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
	pub fn setvbuf(
		arg1: *mut FILE,
		arg2: *mut ::std::os::raw::c_char,
		arg3: ::std::os::raw::c_int,
		arg4: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn sprintf(
		arg1: *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn sscanf(
		arg1: *const ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tmpfile() -> *mut FILE;
}
extern "C" {
	pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vfprintf(
		arg1: *mut FILE,
		arg2: *const ::std::os::raw::c_char,
		arg3: __builtin_va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vprintf(
		arg1: *const ::std::os::raw::c_char,
		arg2: __builtin_va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vsprintf(
		arg1: *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: __builtin_va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
	pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn popen(
		arg1: *const ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
	) -> *mut FILE;
}
extern "C" {
	pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn __svfscanf(
		arg1: *mut FILE,
		arg2: *const ::std::os::raw::c_char,
		arg3: va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
	pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
	pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn tempnam(
		__dir: *const ::std::os::raw::c_char,
		__prefix: *const ::std::os::raw::c_char,
	) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
	pub fn fseeko(
		__stream: *mut FILE,
		__offset: off_t,
		__whence: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
	pub fn snprintf(
		__str: *mut ::std::os::raw::c_char,
		__size: ::std::os::raw::c_ulong,
		__format: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vfscanf(
		__stream: *mut FILE,
		__format: *const ::std::os::raw::c_char,
		arg1: __builtin_va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vscanf(
		__format: *const ::std::os::raw::c_char,
		arg1: __builtin_va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vsnprintf(
		__str: *mut ::std::os::raw::c_char,
		__size: ::std::os::raw::c_ulong,
		__format: *const ::std::os::raw::c_char,
		arg1: __builtin_va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vsscanf(
		__str: *const ::std::os::raw::c_char,
		__format: *const ::std::os::raw::c_char,
		arg1: __builtin_va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn dprintf(
		arg1: ::std::os::raw::c_int,
		arg2: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vdprintf(
		arg1: ::std::os::raw::c_int,
		arg2: *const ::std::os::raw::c_char,
		arg3: va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn getdelim(
		__linep: *mut *mut ::std::os::raw::c_char,
		__linecapp: *mut usize,
		__delimiter: ::std::os::raw::c_int,
		__stream: *mut FILE,
	) -> isize;
}
extern "C" {
	pub fn getline(
		__linep: *mut *mut ::std::os::raw::c_char,
		__linecapp: *mut usize,
		__stream: *mut FILE,
	) -> isize;
}
extern "C" {
	pub fn fmemopen(
		__buf: *mut ::std::os::raw::c_void,
		__size: usize,
		__mode: *const ::std::os::raw::c_char,
	) -> *mut FILE;
}
extern "C" {
	pub fn open_memstream(
		__bufp: *mut *mut ::std::os::raw::c_char,
		__sizep: *mut usize,
	) -> *mut FILE;
}
extern "C" {
	pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
	pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
	pub fn asprintf(
		arg1: *mut *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
	pub fn fmtcheck(
		arg1: *const ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
	) -> *const ::std::os::raw::c_char;
}
extern "C" {
	pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn setbuffer(
		arg1: *mut FILE,
		arg2: *mut ::std::os::raw::c_char,
		arg3: ::std::os::raw::c_int,
	);
}
extern "C" {
	pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn vasprintf(
		arg1: *mut *mut ::std::os::raw::c_char,
		arg2: *const ::std::os::raw::c_char,
		arg3: va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn funopen(
		arg1: *const ::std::os::raw::c_void,
		arg2: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_char,
				arg3: ::std::os::raw::c_int,
			) -> ::std::os::raw::c_int,
		>,
		arg3: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *const ::std::os::raw::c_char,
				arg3: ::std::os::raw::c_int,
			) -> ::std::os::raw::c_int,
		>,
		arg4: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: fpos_t,
				arg3: ::std::os::raw::c_int,
			) -> fpos_t,
		>,
		arg5: ::std::option::Option<
			unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
		>,
	) -> *mut FILE;
}
extern "C" {
	pub fn __sprintf_chk(
		arg1: *mut ::std::os::raw::c_char,
		arg2: ::std::os::raw::c_int,
		arg3: usize,
		arg4: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn __snprintf_chk(
		arg1: *mut ::std::os::raw::c_char,
		arg2: usize,
		arg3: ::std::os::raw::c_int,
		arg4: usize,
		arg5: *const ::std::os::raw::c_char,
		...
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn __vsprintf_chk(
		arg1: *mut ::std::os::raw::c_char,
		arg2: ::std::os::raw::c_int,
		arg3: usize,
		arg4: *const ::std::os::raw::c_char,
		arg5: va_list,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	pub fn __vsnprintf_chk(
		arg1: *mut ::std::os::raw::c_char,
		arg2: usize,
		arg3: ::std::os::raw::c_int,
		arg4: usize,
		arg5: *const ::std::os::raw::c_char,
		arg6: va_list,
	) -> ::std::os::raw::c_int;
}
pub type mbedtls_mpi_sint = i64;
pub type mbedtls_mpi_uint = u64;
pub type mbedtls_t_udbl = u128;
#[doc = " \\brief          MPI structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_mpi {
	pub private_p: *mut mbedtls_mpi_uint,
	pub private_s: ::std::os::raw::c_short,
	pub private_n: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_mbedtls_mpi() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_mpi> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_mpi>(),
		16usize,
		concat!("Size of: ", stringify!(mbedtls_mpi))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_mpi>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_mpi))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_p) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_mpi),
			"::",
			stringify!(private_p)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_s) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_mpi),
			"::",
			stringify!(private_s)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_n) as usize - ptr as usize },
		10usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_mpi),
			"::",
			stringify!(private_n)
		)
	);
}
extern "C" {
	#[doc = " \\brief           Initialize an MPI context.\n\n                  This makes the MPI ready to be set or freed,\n                  but does not define a value for the MPI.\n\n \\param X         The MPI context to initialize. This must not be \\c NULL."]
	pub fn mbedtls_mpi_init(X: *mut mbedtls_mpi);
}
extern "C" {
	#[doc = " \\brief          This function frees the components of an MPI context.\n\n \\param X        The MPI context to be cleared. This may be \\c NULL,\n                 in which case this function is a no-op. If it is\n                 not \\c NULL, it must point to an initialized MPI."]
	pub fn mbedtls_mpi_free(X: *mut mbedtls_mpi);
}
extern "C" {
	#[doc = " \\brief          Enlarge an MPI to the specified number of limbs.\n\n \\note           This function does nothing if the MPI is\n                 already large enough.\n\n \\param X        The MPI to grow. It must be initialized.\n \\param nblimbs  The target number of limbs.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
	pub fn mbedtls_mpi_grow(X: *mut mbedtls_mpi, nblimbs: usize) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function resizes an MPI downwards, keeping at least the\n                 specified number of limbs.\n\n                 If \\c X is smaller than \\c nblimbs, it is resized up\n                 instead.\n\n \\param X        The MPI to shrink. This must point to an initialized MPI.\n \\param nblimbs  The minimum number of limbs to keep.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed\n                 (this can only happen when resizing up).\n \\return         Another negative error code on other kinds of failure."]
	pub fn mbedtls_mpi_shrink(X: *mut mbedtls_mpi, nblimbs: usize) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Make a copy of an MPI.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param Y        The source MPI. This must point to an initialized MPI.\n\n \\note           The limb-buffer in the destination MPI is enlarged\n                 if necessary to hold the value in the source MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
	pub fn mbedtls_mpi_copy(X: *mut mbedtls_mpi, Y: *const mbedtls_mpi) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Swap the contents of two MPIs.\n\n \\param X        The first MPI. It must be initialized.\n \\param Y        The second MPI. It must be initialized."]
	pub fn mbedtls_mpi_swap(X: *mut mbedtls_mpi, Y: *mut mbedtls_mpi);
}
extern "C" {
	#[doc = " \\brief          Perform a safe conditional copy of MPI which doesn't\n                 reveal whether the condition was true or not.\n\n \\param X        The MPI to conditionally assign to. This must point\n                 to an initialized MPI.\n \\param Y        The MPI to be assigned from. This must point to an\n                 initialized MPI.\n \\param assign   The condition deciding whether to perform the\n                 assignment or not. Must be either 0 or 1:\n                 * \\c 1: Perform the assignment `X = Y`.\n                 * \\c 0: Keep the original value of \\p X.\n\n \\note           This function is equivalent to\n                      `if( assign ) mbedtls_mpi_copy( X, Y );`\n                 except that it avoids leaking any information about whether\n                 the assignment was done or not (the above code may leak\n                 information through branch prediction and/or memory access\n                 patterns analysis).\n\n \\warning        If \\p assign is neither 0 nor 1, the result of this function\n                 is indeterminate, and the resulting value in \\p X might be\n                 neither its original value nor the value in \\p Y.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
	pub fn mbedtls_mpi_safe_cond_assign(
		X: *mut mbedtls_mpi,
		Y: *const mbedtls_mpi,
		assign: ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a safe conditional swap which doesn't\n                 reveal whether the condition was true or not.\n\n \\param X        The first MPI. This must be initialized.\n \\param Y        The second MPI. This must be initialized.\n \\param swap     The condition deciding whether to perform\n                 the swap or not. Must be either 0 or 1:\n                 * \\c 1: Swap the values of \\p X and \\p Y.\n                 * \\c 0: Keep the original values of \\p X and \\p Y.\n\n \\note           This function is equivalent to\n                      if( swap ) mbedtls_mpi_swap( X, Y );\n                 except that it avoids leaking any information about whether\n                 the swap was done or not (the above code may leak\n                 information through branch prediction and/or memory access\n                 patterns analysis).\n\n \\warning        If \\p swap is neither 0 nor 1, the result of this function\n                 is indeterminate, and both \\p X and \\p Y might end up with\n                 values different to either of the original ones.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure.\n"]
	pub fn mbedtls_mpi_safe_cond_swap(
		X: *mut mbedtls_mpi,
		Y: *mut mbedtls_mpi,
		swap: ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Store integer value in MPI.\n\n \\param X        The MPI to set. This must be initialized.\n \\param z        The value to use.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
	pub fn mbedtls_mpi_lset(X: *mut mbedtls_mpi, z: mbedtls_mpi_sint) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Get a specific bit from an MPI.\n\n \\param X        The MPI to query. This must be initialized.\n \\param pos      Zero-based index of the bit to query.\n\n \\return         \\c 0 or \\c 1 on success, depending on whether bit \\c pos\n                 of \\c X is unset or set.\n \\return         A negative error code on failure."]
	pub fn mbedtls_mpi_get_bit(X: *const mbedtls_mpi, pos: usize) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Modify a specific bit in an MPI.\n\n \\note           This function will grow the target MPI if necessary to set a\n                 bit to \\c 1 in a not yet existing limb. It will not grow if\n                 the bit should be set to \\c 0.\n\n \\param X        The MPI to modify. This must be initialized.\n \\param pos      Zero-based index of the bit to modify.\n \\param val      The desired value of bit \\c pos: \\c 0 or \\c 1.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on other kinds of failure."]
	pub fn mbedtls_mpi_set_bit(
		X: *mut mbedtls_mpi,
		pos: usize,
		val: ::std::os::raw::c_uchar,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Return the number of bits of value \\c 0 before the\n                 least significant bit of value \\c 1.\n\n \\note           This is the same as the zero-based index of\n                 the least significant bit of value \\c 1.\n\n \\param X        The MPI to query.\n\n \\return         The number of bits of value \\c 0 before the least significant\n                 bit of value \\c 1 in \\p X."]
	pub fn mbedtls_mpi_lsb(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
	#[doc = " \\brief          Return the number of bits up to and including the most\n                 significant bit of value \\c 1.\n\n * \\note         This is same as the one-based index of the most\n                 significant bit of value \\c 1.\n\n \\param X        The MPI to query. This must point to an initialized MPI.\n\n \\return         The number of bits up to and including the most\n                 significant bit of value \\c 1."]
	pub fn mbedtls_mpi_bitlen(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
	#[doc = " \\brief          Return the total size of an MPI value in bytes.\n\n \\param X        The MPI to use. This must point to an initialized MPI.\n\n \\note           The value returned by this function may be less than\n                 the number of bytes used to store \\p X internally.\n                 This happens if and only if there are trailing bytes\n                 of value zero.\n\n \\return         The least number of bytes capable of storing\n                 the absolute value of \\p X."]
	pub fn mbedtls_mpi_size(X: *const mbedtls_mpi) -> usize;
}
extern "C" {
	#[doc = " \\brief          Import an MPI from an ASCII string.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the input string.\n \\param s        Null-terminated string buffer.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
	pub fn mbedtls_mpi_read_string(
		X: *mut mbedtls_mpi,
		radix: ::std::os::raw::c_int,
		s: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Export an MPI to an ASCII string.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the output string.\n \\param buf      The buffer to write the string to. This must be writable\n                 buffer of length \\p buflen Bytes.\n \\param buflen   The available size in Bytes of \\p buf.\n \\param olen     The address at which to store the length of the string\n                 written, including the  final \\c NULL byte. This must\n                 not be \\c NULL.\n\n \\note           You can call this function with `buflen == 0` to obtain the\n                 minimum required buffer size in `*olen`.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the target buffer \\p buf\n                 is too small to hold the value of \\p X in the desired base.\n                 In this case, `*olen` is nonetheless updated to contain the\n                 size of \\p buf required for a successful call.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_write_string(
		X: *const mbedtls_mpi,
		radix: ::std::os::raw::c_int,
		buf: *mut ::std::os::raw::c_char,
		buflen: usize,
		olen: *mut usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Read an MPI from a line in an opened file.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param radix    The numeric base of the string representation used\n                 in the source line.\n \\param fin      The input file handle to use. This must not be \\c NULL.\n\n \\note           On success, this function advances the file stream\n                 to the end of the current line or to EOF.\n\n                 The function returns \\c 0 on an empty line.\n\n                 Leading whitespaces are ignored, as is a\n                 '0x' prefix for radix \\c 16.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if the file read buffer\n                 is too small.\n \\return         Another negative error code on failure."]
	pub fn mbedtls_mpi_read_file(
		X: *mut mbedtls_mpi,
		radix: ::std::os::raw::c_int,
		fin: *mut FILE,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Export an MPI into an opened file.\n\n \\param p        A string prefix to emit prior to the MPI data.\n                 For example, this might be a label, or \"0x\" when\n                 printing in base \\c 16. This may be \\c NULL if no prefix\n                 is needed.\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param radix    The numeric base to be used in the emitted string.\n \\param fout     The output file handle. This may be \\c NULL, in which case\n                 the output is written to \\c stdout.\n\n \\return         \\c 0 if successful.\n \\return         A negative error code on failure."]
	pub fn mbedtls_mpi_write_file(
		p: *const ::std::os::raw::c_char,
		X: *const mbedtls_mpi,
		radix: ::std::os::raw::c_int,
		fout: *mut FILE,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Import an MPI from unsigned big endian binary data.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param buf      The input buffer. This must be a readable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The length of the input buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_read_binary(
		X: *mut mbedtls_mpi,
		buf: *const ::std::os::raw::c_uchar,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Import X from unsigned binary data, little endian\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param buf      The input buffer. This must be a readable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The length of the input buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_read_binary_le(
		X: *mut mbedtls_mpi,
		buf: *const ::std::os::raw::c_uchar,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Export X into unsigned binary data, big endian.\n                 Always fills the whole buffer, which will start with zeros\n                 if the number is smaller.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param buf      The output buffer. This must be a writable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The size of the output buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't\n                 large enough to hold the value of \\p X.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_write_binary(
		X: *const mbedtls_mpi,
		buf: *mut ::std::os::raw::c_uchar,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Export X into unsigned binary data, little endian.\n                 Always fills the whole buffer, which will end with zeros\n                 if the number is smaller.\n\n \\param X        The source MPI. This must point to an initialized MPI.\n \\param buf      The output buffer. This must be a writable buffer of length\n                 \\p buflen Bytes.\n \\param buflen   The size of the output buffer \\p buf in Bytes.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL if \\p buf isn't\n                 large enough to hold the value of \\p X.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_write_binary_le(
		X: *const mbedtls_mpi,
		buf: *mut ::std::os::raw::c_uchar,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a left-shift on an MPI: X <<= count\n\n \\param X        The MPI to shift. This must point to an initialized MPI.\n                 The MPI pointed by \\p X may be resized to fit\n                 the resulting number.\n \\param count    The number of bits to shift by.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_shift_l(X: *mut mbedtls_mpi, count: usize) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a right-shift on an MPI: X >>= count\n\n \\param X        The MPI to shift. This must point to an initialized MPI.\n \\param count    The number of bits to shift by.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_shift_r(X: *mut mbedtls_mpi, count: usize) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Compare the absolute values of two MPIs.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param Y        The right-hand MPI. This must point to an initialized MPI.\n\n \\return         \\c 1 if `|X|` is greater than `|Y|`.\n \\return         \\c -1 if `|X|` is lesser than `|Y|`.\n \\return         \\c 0 if `|X|` is equal to `|Y|`."]
	pub fn mbedtls_mpi_cmp_abs(
		X: *const mbedtls_mpi,
		Y: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Compare two MPIs.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param Y        The right-hand MPI. This must point to an initialized MPI.\n\n \\return         \\c 1 if \\p X is greater than \\p Y.\n \\return         \\c -1 if \\p X is lesser than \\p Y.\n \\return         \\c 0 if \\p X is equal to \\p Y."]
	pub fn mbedtls_mpi_cmp_mpi(
		X: *const mbedtls_mpi,
		Y: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Check if an MPI is less than the other in constant time.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI\n                 with the same allocated length as Y.\n \\param Y        The right-hand MPI. This must point to an initialized MPI\n                 with the same allocated length as X.\n \\param ret      The result of the comparison:\n                 \\c 1 if \\p X is less than \\p Y.\n                 \\c 0 if \\p X is greater than or equal to \\p Y.\n\n \\return         0 on success.\n \\return         MBEDTLS_ERR_MPI_BAD_INPUT_DATA if the allocated length of\n                 the two input MPIs is not the same."]
	pub fn mbedtls_mpi_lt_mpi_ct(
		X: *const mbedtls_mpi,
		Y: *const mbedtls_mpi,
		ret: *mut ::std::os::raw::c_uint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Compare an MPI with an integer.\n\n \\param X        The left-hand MPI. This must point to an initialized MPI.\n \\param z        The integer value to compare \\p X to.\n\n \\return         \\c 1 if \\p X is greater than \\p z.\n \\return         \\c -1 if \\p X is lesser than \\p z.\n \\return         \\c 0 if \\p X is equal to \\p z."]
	pub fn mbedtls_mpi_cmp_int(X: *const mbedtls_mpi, z: mbedtls_mpi_sint)
		-> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform an unsigned addition of MPIs: X = |A| + |B|\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param B        The second summand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_add_abs(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform an unsigned subtraction of MPIs: X = |A| - |B|\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param B        The subtrahend. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is greater than \\p A.\n \\return         Another negative error code on different kinds of failure.\n"]
	pub fn mbedtls_mpi_sub_abs(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a signed addition of MPIs: X = A + B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param B        The second summand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_add_mpi(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a signed subtraction of MPIs: X = A - B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param B        The subtrahend. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_sub_mpi(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a signed addition of an MPI and an integer: X = A + b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first summand. This must point to an initialized MPI.\n \\param b        The second summand.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_add_int(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		b: mbedtls_mpi_sint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a signed subtraction of an MPI and an integer:\n                 X = A - b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The minuend. This must point to an initialized MPI.\n \\param b        The subtrahend.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_sub_int(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		b: mbedtls_mpi_sint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a multiplication of two MPIs: X = A * B\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first factor. This must point to an initialized MPI.\n \\param B        The second factor. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure.\n"]
	pub fn mbedtls_mpi_mul_mpi(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a multiplication of an MPI with an unsigned integer:\n                 X = A * b\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The first factor. This must point to an initialized MPI.\n \\param b        The second factor.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure.\n"]
	pub fn mbedtls_mpi_mul_int(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		b: mbedtls_mpi_uint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a division with remainder of two MPIs:\n                 A = Q * B + R\n\n \\param Q        The destination MPI for the quotient.\n                 This may be \\c NULL if the value of the\n                 quotient is not needed. This must not alias A or B.\n \\param R        The destination MPI for the remainder value.\n                 This may be \\c NULL if the value of the\n                 remainder is not needed. This must not alias A or B.\n \\param A        The dividend. This must point to an initialized MPI.\n \\param B        The divisor. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_div_mpi(
		Q: *mut mbedtls_mpi,
		R: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a division with remainder of an MPI by an integer:\n                 A = Q * b + R\n\n \\param Q        The destination MPI for the quotient.\n                 This may be \\c NULL if the value of the\n                 quotient is not needed.  This must not alias A.\n \\param R        The destination MPI for the remainder value.\n                 This may be \\c NULL if the value of the\n                 remainder is not needed.  This must not alias A.\n \\param A        The dividend. This must point to an initialized MPi.\n \\param b        The divisor.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_div_int(
		Q: *mut mbedtls_mpi,
		R: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		b: mbedtls_mpi_sint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a modular reduction. R = A mod B\n\n \\param R        The destination MPI for the residue value.\n                 This must point to an initialized MPI.\n \\param A        The MPI to compute the residue of.\n                 This must point to an initialized MPI.\n \\param B        The base of the modular reduction.\n                 This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p B equals zero.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p B is negative.\n \\return         Another negative error code on different kinds of failure.\n"]
	pub fn mbedtls_mpi_mod_mpi(
		R: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a modular reduction with respect to an integer.\n                 r = A mod b\n\n \\param r        The address at which to store the residue.\n                 This must not be \\c NULL.\n \\param A        The MPI to compute the residue of.\n                 This must point to an initialized MPi.\n \\param b        The integer base of the modular reduction.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_DIVISION_BY_ZERO if \\p b equals zero.\n \\return         #MBEDTLS_ERR_MPI_NEGATIVE_VALUE if \\p b is negative.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_mod_int(
		r: *mut mbedtls_mpi_uint,
		A: *const mbedtls_mpi,
		b: mbedtls_mpi_sint,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Perform a sliding-window exponentiation: X = A^E mod N\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n                 This must not alias E or N.\n \\param A        The base of the exponentiation.\n                 This must point to an initialized MPI.\n \\param E        The exponent MPI. This must point to an initialized MPI.\n \\param N        The base for the modular reduction. This must point to an\n                 initialized MPI.\n \\param prec_RR  A helper MPI depending solely on \\p N which can be used to\n                 speed-up multiple modular exponentiations for the same value\n                 of \\p N. This may be \\c NULL. If it is not \\c NULL, it must\n                 point to an initialized MPI. If it hasn't been used after\n                 the call to mbedtls_mpi_init(), this function will compute\n                 the helper value and store it in \\p prec_RR for reuse on\n                 subsequent calls to this function. Otherwise, the function\n                 will assume that \\p prec_RR holds the helper value set by a\n                 previous call to mbedtls_mpi_exp_mod(), and reuse it.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\c N is negative or\n                 even, or if \\c E is negative.\n \\return         Another negative error code on different kinds of failures.\n"]
	pub fn mbedtls_mpi_exp_mod(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		E: *const mbedtls_mpi,
		N: *const mbedtls_mpi,
		prec_RR: *mut mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Fill an MPI with a number of random bytes.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param size     The number of random bytes to generate.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on failure.\n\n \\note           The bytes obtained from the RNG are interpreted\n                 as a big-endian representation of an MPI; this can\n                 be relevant in applications like deterministic ECDSA."]
	pub fn mbedtls_mpi_fill_random(
		X: *mut mbedtls_mpi,
		size: usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " Generate a random number uniformly in a range.\n\n This function generates a random number between \\p min inclusive and\n \\p N exclusive.\n\n The procedure complies with RFC 6979 3.3 (deterministic ECDSA)\n when the RNG is a suitably parametrized instance of HMAC_DRBG\n and \\p min is \\c 1.\n\n \\note           There are `N - min` possible outputs. The lower bound\n                 \\p min can be reached, but the upper bound \\p N cannot.\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param min      The minimum value to return.\n                 It must be nonnegative.\n \\param N        The upper bound of the range, exclusive.\n                 In other words, this is one plus the maximum value to return.\n                 \\p N must be strictly larger than \\p min.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p min or \\p N is invalid\n                 or if they are incompatible.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if the implementation was\n                 unable to find a suitable value within a limited number\n                 of attempts. This has a negligible probability if \\p N\n                 is significantly larger than \\p min, which is the case\n                 for all usual cryptographic applications.\n \\return         Another negative error code on failure."]
	pub fn mbedtls_mpi_random(
		X: *mut mbedtls_mpi,
		min: mbedtls_mpi_sint,
		N: *const mbedtls_mpi,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Compute the greatest common divisor: G = gcd(A, B)\n\n \\param G        The destination MPI. This must point to an initialized MPI.\n \\param A        The first operand. This must point to an initialized MPI.\n \\param B        The second operand. This must point to an initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         Another negative error code on different kinds of failure."]
	pub fn mbedtls_mpi_gcd(
		G: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		B: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Compute the modular inverse: X = A^-1 mod N\n\n \\param X        The destination MPI. This must point to an initialized MPI.\n \\param A        The MPI to calculate the modular inverse of. This must point\n                 to an initialized MPI.\n \\param N        The base of the modular inversion. This must point to an\n                 initialized MPI.\n\n \\return         \\c 0 if successful.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if \\p N is less than\n                 or equal to one.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p A has no modular\n                 inverse with respect to \\p N."]
	pub fn mbedtls_mpi_inv_mod(
		X: *mut mbedtls_mpi,
		A: *const mbedtls_mpi,
		N: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Miller-Rabin primality test.\n\n \\warning        If \\p X is potentially generated by an adversary, for example\n                 when validating cryptographic parameters that you didn't\n                 generate yourself and that are supposed to be prime, then\n                 \\p rounds should be at least the half of the security\n                 strength of the cryptographic algorithm. On the other hand,\n                 if \\p X is chosen uniformly or non-adversarially (as is the\n                 case when mbedtls_mpi_gen_prime calls this function), then\n                 \\p rounds can be much lower.\n\n \\param X        The MPI to check for primality.\n                 This must point to an initialized MPI.\n \\param rounds   The number of bases to perform the Miller-Rabin primality\n                 test for. The probability of returning 0 on a composite is\n                 at most 2<sup>-2*\\p rounds </sup>.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't use\n                 a context parameter.\n\n \\return         \\c 0 if successful, i.e. \\p X is probably prime.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_NOT_ACCEPTABLE if \\p X is not prime.\n \\return         Another negative error code on other kinds of failure."]
	pub fn mbedtls_mpi_is_prime_ext(
		X: *const mbedtls_mpi,
		rounds: ::std::os::raw::c_int,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
#[doc = "< (X-1)/2 is prime too"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_DH: mbedtls_mpi_gen_prime_flag_t =
	1;
#[doc = "< lower error rate from 2<sup>-80</sup> to 2<sup>-128</sup>"]
pub const mbedtls_mpi_gen_prime_flag_t_MBEDTLS_MPI_GEN_PRIME_FLAG_LOW_ERR:
	mbedtls_mpi_gen_prime_flag_t = 2;
#[doc = " \\brief Flags for mbedtls_mpi_gen_prime()\n\n Each of these flags is a constraint on the result X returned by\n mbedtls_mpi_gen_prime()."]
pub type mbedtls_mpi_gen_prime_flag_t = ::std::os::raw::c_uint;
extern "C" {
	#[doc = " \\brief          Generate a prime number.\n\n \\param X        The destination MPI to store the generated prime in.\n                 This must point to an initialized MPi.\n \\param nbits    The required size of the destination MPI in bits.\n                 This must be between \\c 3 and #MBEDTLS_MPI_MAX_BITS.\n \\param flags    A mask of flags of type #mbedtls_mpi_gen_prime_flag_t.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG parameter to be passed to \\p f_rng.\n                 This may be \\c NULL if \\p f_rng doesn't use\n                 a context parameter.\n\n \\return         \\c 0 if successful, in which case \\p X holds a\n                 probably prime number.\n \\return         #MBEDTLS_ERR_MPI_ALLOC_FAILED if a memory allocation failed.\n \\return         #MBEDTLS_ERR_MPI_BAD_INPUT_DATA if `nbits` is not between\n                 \\c 3 and #MBEDTLS_MPI_MAX_BITS."]
	pub fn mbedtls_mpi_gen_prime(
		X: *mut mbedtls_mpi,
		nbits: usize,
		flags: ::std::os::raw::c_int,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if the test failed"]
	pub fn mbedtls_mpi_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = "< Curve not defined."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_NONE: mbedtls_ecp_group_id = 0;
#[doc = "< Domain parameters for the 192-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192R1: mbedtls_ecp_group_id = 1;
#[doc = "< Domain parameters for the 224-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224R1: mbedtls_ecp_group_id = 2;
#[doc = "< Domain parameters for the 256-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256R1: mbedtls_ecp_group_id = 3;
#[doc = "< Domain parameters for the 384-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP384R1: mbedtls_ecp_group_id = 4;
#[doc = "< Domain parameters for the 521-bit curve defined by FIPS 186-4 and SEC1."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP521R1: mbedtls_ecp_group_id = 5;
#[doc = "< Domain parameters for 256-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP256R1: mbedtls_ecp_group_id = 6;
#[doc = "< Domain parameters for 384-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP384R1: mbedtls_ecp_group_id = 7;
#[doc = "< Domain parameters for 512-bit Brainpool curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_BP512R1: mbedtls_ecp_group_id = 8;
#[doc = "< Domain parameters for Curve25519."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE25519: mbedtls_ecp_group_id = 9;
#[doc = "< Domain parameters for 192-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP192K1: mbedtls_ecp_group_id = 10;
#[doc = "< Domain parameters for 224-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP224K1: mbedtls_ecp_group_id = 11;
#[doc = "< Domain parameters for 256-bit \"Koblitz\" curve."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_SECP256K1: mbedtls_ecp_group_id = 12;
#[doc = "< Domain parameters for Curve448."]
pub const mbedtls_ecp_group_id_MBEDTLS_ECP_DP_CURVE448: mbedtls_ecp_group_id = 13;
#[doc = " Domain-parameter identifiers: curve, subgroup, and generator.\n\n \\note Only curves over prime fields are supported.\n\n \\warning This library does not support validation of arbitrary domain\n parameters. Therefore, only standardized domain parameters from trusted\n sources should be used. See mbedtls_ecp_group_load()."]
pub type mbedtls_ecp_group_id = ::std::os::raw::c_uint;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_NONE: mbedtls_ecp_curve_type = 0;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_SHORT_WEIERSTRASS: mbedtls_ecp_curve_type = 1;
pub const mbedtls_ecp_curve_type_MBEDTLS_ECP_TYPE_MONTGOMERY: mbedtls_ecp_curve_type = 2;
pub type mbedtls_ecp_curve_type = ::std::os::raw::c_uint;
#[doc = " Curve information, for use by other modules.\n\n The fields of this structure are part of the public API and can be\n accessed directly by applications. Future versions of the library may\n add extra fields or reorder existing fields."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_curve_info {
	#[doc = "< An internal identifier."]
	pub grp_id: mbedtls_ecp_group_id,
	#[doc = "< The TLS NamedCurve identifier."]
	pub tls_id: u16,
	#[doc = "< The curve size in bits."]
	pub bit_size: u16,
	#[doc = "< A human-friendly name."]
	pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_mbedtls_ecp_curve_info() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_ecp_curve_info> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_ecp_curve_info>(),
		16usize,
		concat!("Size of: ", stringify!(mbedtls_ecp_curve_info))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_ecp_curve_info>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_ecp_curve_info))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).grp_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_curve_info),
			"::",
			stringify!(grp_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).tls_id) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_curve_info),
			"::",
			stringify!(tls_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
		6usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_curve_info),
			"::",
			stringify!(bit_size)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_curve_info),
			"::",
			stringify!(name)
		)
	);
}
#[doc = " \\brief           The ECP point structure, in Jacobian coordinates.\n\n \\note            All functions expect and return points satisfying\n                  the following condition: <code>Z == 0</code> or\n                  <code>Z == 1</code>. Other values of \\p Z are\n                  used only by internal functions.\n                  The point is zero, or \"at infinity\", if <code>Z == 0</code>.\n                  Otherwise, \\p X and \\p Y are its standard (affine)\n                  coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_point {
	pub private_X: mbedtls_mpi,
	pub private_Y: mbedtls_mpi,
	pub private_Z: mbedtls_mpi,
}
#[test]
fn bindgen_test_layout_mbedtls_ecp_point() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_ecp_point> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_ecp_point>(),
		48usize,
		concat!("Size of: ", stringify!(mbedtls_ecp_point))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_ecp_point>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_ecp_point))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_X) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_point),
			"::",
			stringify!(private_X)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Y) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_point),
			"::",
			stringify!(private_Y)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Z) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_point),
			"::",
			stringify!(private_Z)
		)
	);
}
#[doc = " \\brief           The ECP group structure.\n\n We consider two types of curve equations:\n <ul><li>Short Weierstrass: <code>y^2 = x^3 + A x + B mod P</code>\n (SEC1 + RFC-4492)</li>\n <li>Montgomery: <code>y^2 = x^3 + A x^2 + x mod P</code> (Curve25519,\n Curve448)</li></ul>\n In both cases, the generator (\\p G) for a prime-order subgroup is fixed.\n\n For Short Weierstrass, this subgroup is the whole curve, and its\n cardinality is denoted by \\p N. Our code requires that \\p N is an\n odd prime as mbedtls_ecp_mul() requires an odd number, and\n mbedtls_ecdsa_sign() requires that it is prime for blinding purposes.\n\n For Montgomery curves, we do not store \\p A, but <code>(A + 2) / 4</code>,\n which is the quantity used in the formulas. Additionally, \\p nbits is\n not the size of \\p N but the required size for private keys.\n\n If \\p modp is NULL, reduction modulo \\p P is done using a generic algorithm.\n Otherwise, \\p modp must point to a function that takes an \\p mbedtls_mpi in the\n range of <code>0..2^(2*pbits)-1</code>, and transforms it in-place to an integer\n which is congruent mod \\p P to the given MPI, and is close enough to \\p pbits\n in size, so that it may be efficiently brought in the 0..P-1 range by a few\n additions or subtractions. Therefore, it is only an approximative modular\n reduction. It must return 0 on success and non-zero on failure.\n\n \\note        Alternative implementations of the ECP module must obey the\n              following constraints.\n              * Group IDs must be distinct: if two group structures have\n                the same ID, then they must be identical.\n              * The fields \\c id, \\c P, \\c A, \\c B, \\c G, \\c N,\n                \\c pbits and \\c nbits must have the same type and semantics\n                as in the built-in implementation.\n                They must be available for reading, but direct modification\n                of these fields does not need to be supported.\n                They do not need to be at the same offset in the structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_group {
	#[doc = "< An internal group identifier."]
	pub id: mbedtls_ecp_group_id,
	#[doc = "< The prime modulus of the base field."]
	pub P: mbedtls_mpi,
	#[doc = "< For Short Weierstrass: \\p A in the equation. For\nMontgomery curves: <code>(A + 2) / 4</code>."]
	pub A: mbedtls_mpi,
	#[doc = "< For Short Weierstrass: \\p B in the equation.\nFor Montgomery curves: unused."]
	pub B: mbedtls_mpi,
	#[doc = "< The generator of the subgroup used."]
	pub G: mbedtls_ecp_point,
	#[doc = "< The order of \\p G."]
	pub N: mbedtls_mpi,
	#[doc = "< The number of bits in \\p P."]
	pub pbits: usize,
	#[doc = "< For Short Weierstrass: The number of bits in \\p P.\nFor Montgomery curves: the number of bits in the\nprivate keys."]
	pub nbits: usize,
	pub private_h: ::std::os::raw::c_uint,
	pub private_modp: ::std::option::Option<
		unsafe extern "C" fn(arg1: *mut mbedtls_mpi) -> ::std::os::raw::c_int,
	>,
	pub private_t_pre: ::std::option::Option<
		unsafe extern "C" fn(
			arg1: *mut mbedtls_ecp_point,
			arg2: *mut ::std::os::raw::c_void,
		) -> ::std::os::raw::c_int,
	>,
	pub private_t_post: ::std::option::Option<
		unsafe extern "C" fn(
			arg1: *mut mbedtls_ecp_point,
			arg2: *mut ::std::os::raw::c_void,
		) -> ::std::os::raw::c_int,
	>,
	pub private_t_data: *mut ::std::os::raw::c_void,
	pub private_T: *mut mbedtls_ecp_point,
	pub private_T_size: usize,
}
#[test]
fn bindgen_test_layout_mbedtls_ecp_group() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_ecp_group> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_ecp_group>(),
		192usize,
		concat!("Size of: ", stringify!(mbedtls_ecp_group))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_ecp_group>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_ecp_group))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).P) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(P)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(A)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(B)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(G)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).N) as usize - ptr as usize },
		104usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(N)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).pbits) as usize - ptr as usize },
		120usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(pbits)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).nbits) as usize - ptr as usize },
		128usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(nbits)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_h) as usize - ptr as usize },
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(private_h)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_modp) as usize - ptr as usize },
		144usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(private_modp)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_t_pre) as usize - ptr as usize },
		152usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(private_t_pre)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_t_post) as usize - ptr as usize },
		160usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(private_t_post)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_t_data) as usize - ptr as usize },
		168usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(private_t_data)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_T) as usize - ptr as usize },
		176usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(private_T)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_T_size) as usize - ptr as usize },
		184usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_group),
			"::",
			stringify!(private_T_size)
		)
	);
}
pub type mbedtls_ecp_restart_ctx = ::std::os::raw::c_void;
#[doc = " \\brief    The ECP key-pair structure.\n\n A generic key-pair that may be used for ECDSA and fixed ECDH, for example.\n\n \\note    Members are deliberately in the same order as in the\n          ::mbedtls_ecdsa_context structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecp_keypair {
	pub private_grp: mbedtls_ecp_group,
	pub private_d: mbedtls_mpi,
	pub private_Q: mbedtls_ecp_point,
}
#[test]
fn bindgen_test_layout_mbedtls_ecp_keypair() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_ecp_keypair> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_ecp_keypair>(),
		256usize,
		concat!("Size of: ", stringify!(mbedtls_ecp_keypair))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_ecp_keypair>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_ecp_keypair))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_grp) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_keypair),
			"::",
			stringify!(private_grp)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_d) as usize - ptr as usize },
		192usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_keypair),
			"::",
			stringify!(private_d)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Q) as usize - ptr as usize },
		208usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecp_keypair),
			"::",
			stringify!(private_Q)
		)
	);
}
extern "C" {
	pub fn mbedtls_ecp_get_type(grp: *const mbedtls_ecp_group) -> mbedtls_ecp_curve_type;
}
extern "C" {
	#[doc = " \\brief           This function retrieves the information defined in\n                  mbedtls_ecp_curve_info() for all supported curves.\n\n \\note            This function returns information about all curves\n                  supported by the library. Some curves may not be\n                  supported for all algorithms. Call mbedtls_ecdh_can_do()\n                  or mbedtls_ecdsa_can_do() to check if a curve is\n                  supported for ECDH or ECDSA.\n\n \\return          A statically allocated array. The last entry is 0."]
	pub fn mbedtls_ecp_curve_list() -> *const mbedtls_ecp_curve_info;
}
extern "C" {
	#[doc = " \\brief           This function retrieves the list of internal group\n                  identifiers of all supported curves in the order of\n                  preference.\n\n \\note            This function returns information about all curves\n                  supported by the library. Some curves may not be\n                  supported for all algorithms. Call mbedtls_ecdh_can_do()\n                  or mbedtls_ecdsa_can_do() to check if a curve is\n                  supported for ECDH or ECDSA.\n\n \\return          A statically allocated array,\n                  terminated with MBEDTLS_ECP_DP_NONE."]
	pub fn mbedtls_ecp_grp_id_list() -> *const mbedtls_ecp_group_id;
}
extern "C" {
	#[doc = " \\brief           This function retrieves curve information from an internal\n                  group identifier.\n\n \\param grp_id    An \\c MBEDTLS_ECP_DP_XXX value.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
	pub fn mbedtls_ecp_curve_info_from_grp_id(
		grp_id: mbedtls_ecp_group_id,
	) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
	#[doc = " \\brief           This function retrieves curve information from a TLS\n                  NamedCurve value.\n\n \\param tls_id    An \\c MBEDTLS_ECP_DP_XXX value.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
	pub fn mbedtls_ecp_curve_info_from_tls_id(tls_id: u16) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
	#[doc = " \\brief           This function retrieves curve information from a\n                  human-readable name.\n\n \\param name      The human-readable name.\n\n \\return          The associated curve information on success.\n \\return          NULL on failure."]
	pub fn mbedtls_ecp_curve_info_from_name(
		name: *const ::std::os::raw::c_char,
	) -> *const mbedtls_ecp_curve_info;
}
extern "C" {
	#[doc = " \\brief           This function initializes a point as zero.\n\n \\param pt        The point to initialize."]
	pub fn mbedtls_ecp_point_init(pt: *mut mbedtls_ecp_point);
}
extern "C" {
	#[doc = " \\brief           This function initializes an ECP group context\n                  without loading any domain parameters.\n\n \\note            After this function is called, domain parameters\n                  for various ECP groups can be loaded through the\n                  mbedtls_ecp_group_load() or mbedtls_ecp_tls_read_group()\n                  functions."]
	pub fn mbedtls_ecp_group_init(grp: *mut mbedtls_ecp_group);
}
extern "C" {
	#[doc = " \\brief           This function initializes a key pair as an invalid one.\n\n \\param key       The key pair to initialize."]
	pub fn mbedtls_ecp_keypair_init(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
	#[doc = " \\brief           This function frees the components of a point.\n\n \\param pt        The point to free."]
	pub fn mbedtls_ecp_point_free(pt: *mut mbedtls_ecp_point);
}
extern "C" {
	#[doc = " \\brief           This function frees the components of an ECP group.\n\n \\param grp       The group to free. This may be \\c NULL, in which\n                  case this function returns immediately. If it is not\n                  \\c NULL, it must point to an initialized ECP group."]
	pub fn mbedtls_ecp_group_free(grp: *mut mbedtls_ecp_group);
}
extern "C" {
	#[doc = " \\brief           This function frees the components of a key pair.\n\n \\param key       The key pair to free. This may be \\c NULL, in which\n                  case this function returns immediately. If it is not\n                  \\c NULL, it must point to an initialized ECP key pair."]
	pub fn mbedtls_ecp_keypair_free(key: *mut mbedtls_ecp_keypair);
}
extern "C" {
	#[doc = " \\brief           This function copies the contents of point \\p Q into\n                  point \\p P.\n\n \\param P         The destination point. This must be initialized.\n \\param Q         The source point. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code for other kinds of failure."]
	pub fn mbedtls_ecp_copy(
		P: *mut mbedtls_ecp_point,
		Q: *const mbedtls_ecp_point,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function copies the contents of group \\p src into\n                  group \\p dst.\n\n \\param dst       The destination group. This must be initialized.\n \\param src       The source group. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_group_copy(
		dst: *mut mbedtls_ecp_group,
		src: *const mbedtls_ecp_group,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function sets a point to the point at infinity.\n\n \\param pt        The point to set. This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_set_zero(pt: *mut mbedtls_ecp_point) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function checks if a point is the point at infinity.\n\n \\param pt        The point to test. This must be initialized.\n\n \\return          \\c 1 if the point is zero.\n \\return          \\c 0 if the point is non-zero.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecp_is_zero(pt: *mut mbedtls_ecp_point) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function compares two points.\n\n \\note            This assumes that the points are normalized. Otherwise,\n                  they may compare as \"not equal\" even if they are.\n\n \\param P         The first point to compare. This must be initialized.\n \\param Q         The second point to compare. This must be initialized.\n\n \\return          \\c 0 if the points are equal.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the points are not equal."]
	pub fn mbedtls_ecp_point_cmp(
		P: *const mbedtls_ecp_point,
		Q: *const mbedtls_ecp_point,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function imports a non-zero point from two ASCII\n                  strings.\n\n \\param P         The destination point. This must be initialized.\n \\param radix     The numeric base of the input.\n \\param x         The first affine coordinate, as a null-terminated string.\n \\param y         The second affine coordinate, as a null-terminated string.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on failure."]
	pub fn mbedtls_ecp_point_read_string(
		P: *mut mbedtls_ecp_point,
		radix: ::std::os::raw::c_int,
		x: *const ::std::os::raw::c_char,
		y: *const ::std::os::raw::c_char,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function exports a point into unsigned binary data.\n\n \\param grp       The group to which the point should belong.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param P         The point to export. This must be initialized.\n \\param format    The point format. This must be either\n                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.\n                  (For groups without these formats, this parameter is\n                  ignored. But it still has to be either of the above\n                  values.)\n \\param olen      The address at which to store the length of\n                  the output in Bytes. This must not be \\c NULL.\n \\param buf       The output buffer. This must be a writable buffer\n                  of length \\p buflen Bytes.\n \\param buflen    The length of the output buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output buffer\n                  is too small to hold the point.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the point format\n                  or the export for the given group is not implemented.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_point_write_binary(
		grp: *const mbedtls_ecp_group,
		P: *const mbedtls_ecp_point,
		format: ::std::os::raw::c_int,
		olen: *mut usize,
		buf: *mut ::std::os::raw::c_uchar,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function imports a point from unsigned binary data.\n\n \\note            This function does not check that the point actually\n                  belongs to the given group, see mbedtls_ecp_check_pubkey()\n                  for that.\n\n \\note            For compressed points, see #MBEDTLS_ECP_PF_COMPRESSED for\n                  limitations.\n\n \\param grp       The group to which the point should belong.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param P         The destination context to import the point to.\n                  This must be initialized.\n \\param buf       The input buffer. This must be a readable buffer\n                  of length \\p ilen Bytes.\n \\param ilen      The length of the input buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the import for the\n                  given group is not implemented."]
	pub fn mbedtls_ecp_point_read_binary(
		grp: *const mbedtls_ecp_group,
		P: *mut mbedtls_ecp_point,
		buf: *const ::std::os::raw::c_uchar,
		ilen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function imports a point from a TLS ECPoint record.\n\n \\note            On function return, \\p *buf is updated to point immediately\n                  after the ECPoint record.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The destination point.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the buffer.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_MPI_XXX error code on initialization\n                  failure.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid."]
	pub fn mbedtls_ecp_tls_read_point(
		grp: *const mbedtls_ecp_group,
		pt: *mut mbedtls_ecp_point,
		buf: *mut *const ::std::os::raw::c_uchar,
		len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function exports a point as a TLS ECPoint record\n                  defined in RFC 4492, Section 5.4.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The point to be exported. This must be initialized.\n \\param format    The point format to use. This must be either\n                  #MBEDTLS_ECP_PF_COMPRESSED or #MBEDTLS_ECP_PF_UNCOMPRESSED.\n \\param olen      The address at which to store the length in Bytes\n                  of the data written.\n \\param buf       The target buffer. This must be a writable buffer of\n                  length \\p blen Bytes.\n \\param blen      The length of the target buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the input is invalid.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the target buffer\n                  is too small to hold the exported point.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_tls_write_point(
		grp: *const mbedtls_ecp_group,
		pt: *const mbedtls_ecp_point,
		format: ::std::os::raw::c_int,
		olen: *mut usize,
		buf: *mut ::std::os::raw::c_uchar,
		blen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function sets up an ECP group context\n                  from a standardized set of domain parameters.\n\n \\note            The index should be a value of the NamedCurve enum,\n                  as defined in <em>RFC-4492: Elliptic Curve Cryptography\n                  (ECC) Cipher Suites for Transport Layer Security (TLS)</em>,\n                  usually in the form of an \\c MBEDTLS_ECP_DP_XXX macro.\n\n \\param grp       The group context to setup. This must be initialized.\n \\param id        The identifier of the domain parameter set to load.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p id doesn't\n                  correspond to a known group.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_group_load(
		grp: *mut mbedtls_ecp_group,
		id: mbedtls_ecp_group_id,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function sets up an ECP group context from a TLS\n                  ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\note            The read pointer \\p buf is updated to point right after\n                  the ECParameters record on exit.\n\n \\param grp       The group context to setup. This must be initialized.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the input buffer \\c *buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not\n                  recognized.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_tls_read_group(
		grp: *mut mbedtls_ecp_group,
		buf: *mut *const ::std::os::raw::c_uchar,
		len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function extracts an elliptic curve group ID from a\n                  TLS ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\note            The read pointer \\p buf is updated to point right after\n                  the ECParameters record on exit.\n\n \\param grp       The address at which to store the group id.\n                  This must not be \\c NULL.\n \\param buf       The address of the pointer to the start of the input buffer.\n \\param len       The length of the input buffer \\c *buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if input is invalid.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the group is not\n                  recognized.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_tls_read_group_id(
		grp: *mut mbedtls_ecp_group_id,
		buf: *mut *const ::std::os::raw::c_uchar,
		len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function exports an elliptic curve as a TLS\n                  ECParameters record as defined in RFC 4492, Section 5.4.\n\n \\param grp       The ECP group to be exported.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param olen      The address at which to store the number of Bytes written.\n                  This must not be \\c NULL.\n \\param buf       The buffer to write to. This must be a writable buffer\n                  of length \\p blen Bytes.\n \\param blen      The length of the output buffer \\p buf in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the output\n                  buffer is too small to hold the exported group.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_tls_write_group(
		grp: *const mbedtls_ecp_group,
		olen: *mut usize,
		buf: *mut ::std::os::raw::c_uchar,
		blen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs a scalar multiplication of a point\n                  by an integer: \\p R = \\p m * \\p P.\n\n                  It is not thread-safe to use same group in multiple threads.\n\n \\note            To prevent timing attacks, this function\n                  executes the exact same sequence of base-field\n                  operations for any valid \\p m. It avoids any if-branch or\n                  array index depending on the value of \\p m. It also uses\n                  \\p f_rng to randomize some intermediate results.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply. This must be initialized.\n \\param P         The point to multiply. This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private\n                  key, or \\p P is not a valid public key.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_mul(
		grp: *mut mbedtls_ecp_group,
		R: *mut mbedtls_ecp_point,
		m: *const mbedtls_mpi,
		P: *const mbedtls_ecp_point,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs multiplication of a point by\n                  an integer: \\p R = \\p m * \\p P in a restartable way.\n\n \\see             mbedtls_ecp_mul()\n\n \\note            This function does the same as \\c mbedtls_ecp_mul(), but\n                  it can return early and restart according to the limit set\n                  with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply. This must be initialized.\n \\param P         The point to multiply. This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n \\param rs_ctx    The restart context (NULL disables restart).\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m is not a valid private\n                  key, or \\p P is not a valid public key.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_mul_restartable(
		grp: *mut mbedtls_ecp_group,
		R: *mut mbedtls_ecp_point,
		m: *const mbedtls_mpi,
		P: *const mbedtls_ecp_point,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
		rs_ctx: *mut mbedtls_ecp_restart_ctx,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs multiplication and addition of two\n                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q\n\n                  It is not thread-safe to use same group in multiple threads.\n\n \\note            In contrast to mbedtls_ecp_mul(), this function does not\n                  guarantee a constant execution flow and timing.\n\n \\note            This function is only defined for short Weierstrass curves.\n                  It may not be included in builds without any short\n                  Weierstrass curve.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply \\p P.\n                  This must be initialized.\n \\param P         The point to multiply by \\p m. This must be initialized.\n \\param n         The integer by which to multiply \\p Q.\n                  This must be initialized.\n \\param Q         The point to be multiplied by \\p n.\n                  This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not\n                  valid private keys, or \\p P or \\p Q are not valid public\n                  keys.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not\n                  designate a short Weierstrass curve.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_muladd(
		grp: *mut mbedtls_ecp_group,
		R: *mut mbedtls_ecp_point,
		m: *const mbedtls_mpi,
		P: *const mbedtls_ecp_point,
		n: *const mbedtls_mpi,
		Q: *const mbedtls_ecp_point,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function performs multiplication and addition of two\n                  points by integers: \\p R = \\p m * \\p P + \\p n * \\p Q in a\n                  restartable way.\n\n \\see             \\c mbedtls_ecp_muladd()\n\n \\note            This function works the same as \\c mbedtls_ecp_muladd(),\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\note            This function is only defined for short Weierstrass curves.\n                  It may not be included in builds without any short\n                  Weierstrass curve.\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param R         The point in which to store the result of the calculation.\n                  This must be initialized.\n \\param m         The integer by which to multiply \\p P.\n                  This must be initialized.\n \\param P         The point to multiply by \\p m. This must be initialized.\n \\param n         The integer by which to multiply \\p Q.\n                  This must be initialized.\n \\param Q         The point to be multiplied by \\p n.\n                  This must be initialized.\n \\param rs_ctx    The restart context (NULL disables restart).\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if \\p m or \\p n are not\n                  valid private keys, or \\p P or \\p Q are not valid public\n                  keys.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if \\p grp does not\n                  designate a short Weierstrass curve.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_muladd_restartable(
		grp: *mut mbedtls_ecp_group,
		R: *mut mbedtls_ecp_point,
		m: *const mbedtls_mpi,
		P: *const mbedtls_ecp_point,
		n: *const mbedtls_mpi,
		Q: *const mbedtls_ecp_point,
		rs_ctx: *mut mbedtls_ecp_restart_ctx,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function checks that a point is a valid public key\n                  on this curve.\n\n                  It only checks that the point is non-zero, has\n                  valid coordinates and lies on the curve. It does not verify\n                  that it is indeed a multiple of \\c G. This additional\n                  check is computationally more expensive, is not required\n                  by standards, and should not be necessary if the group\n                  used has a small cofactor. In particular, it is useless for\n                  the NIST groups which all have a cofactor of 1.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure, to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group the point should belong to.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param pt        The point to check. This must be initialized.\n\n \\return          \\c 0 if the point is a valid public key.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not\n                  a valid public key for the given curve.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_check_pubkey(
		grp: *const mbedtls_ecp_group,
		pt: *const mbedtls_ecp_point,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function checks that an \\c mbedtls_mpi is a\n                  valid private key for this curve.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group the private key should belong to.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The integer to check. This must be initialized.\n\n \\return          \\c 0 if the point is a valid private key.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY if the point is not a valid\n                  private key for the given curve.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_check_privkey(
		grp: *const mbedtls_ecp_group,
		d: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function generates a private key.\n\n \\param grp       The ECP group to generate a private key for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The destination MPI (secret part). This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
	pub fn mbedtls_ecp_gen_privkey(
		grp: *const mbedtls_ecp_group,
		d: *mut mbedtls_mpi,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function generates a keypair with a configurable base\n                  point.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group to generate a key pair for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param G         The base point to use. This must be initialized\n                  and belong to \\p grp. It replaces the default base\n                  point \\c grp->G used by mbedtls_ecp_gen_keypair().\n \\param d         The destination MPI (secret part).\n                  This must be initialized.\n \\param Q         The destination point (public part).\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
	pub fn mbedtls_ecp_gen_keypair_base(
		grp: *mut mbedtls_ecp_group,
		G: *const mbedtls_ecp_point,
		d: *mut mbedtls_mpi,
		Q: *mut mbedtls_ecp_point,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function generates an ECP keypair.\n\n \\note            This function uses bare components rather than an\n                  ::mbedtls_ecp_keypair structure to ease use with other\n                  structures, such as ::mbedtls_ecdh_context or\n                  ::mbedtls_ecdsa_context.\n\n \\param grp       The ECP group to generate a key pair for.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param d         The destination MPI (secret part).\n                  This must be initialized.\n \\param Q         The destination point (public part).\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
	pub fn mbedtls_ecp_gen_keypair(
		grp: *mut mbedtls_ecp_group,
		d: *mut mbedtls_mpi,
		Q: *mut mbedtls_ecp_point,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function generates an ECP key.\n\n \\param grp_id    The ECP group identifier.\n \\param key       The destination key. This must be initialized.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may\n                  be \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX error code\n                  on failure."]
	pub fn mbedtls_ecp_gen_key(
		grp_id: mbedtls_ecp_group_id,
		key: *mut mbedtls_ecp_keypair,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function reads an elliptic curve private key.\n\n \\param grp_id    The ECP group identifier.\n \\param key       The destination key.\n \\param buf       The buffer containing the binary representation of the\n                  key. (Big endian integer for Weierstrass curves, byte\n                  string for Montgomery curves.)\n \\param buflen    The length of the buffer in bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_INVALID_KEY error if the key is\n                  invalid.\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED if memory allocation failed.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for\n                  the group is not implemented.\n \\return          Another negative error code on different kinds of failure."]
	pub fn mbedtls_ecp_read_key(
		grp_id: mbedtls_ecp_group_id,
		key: *mut mbedtls_ecp_keypair,
		buf: *const ::std::os::raw::c_uchar,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function exports an elliptic curve private key.\n\n \\param key       The private key.\n \\param buf       The output buffer for containing the binary representation\n                  of the key. (Big endian integer for Weierstrass curves, byte\n                  string for Montgomery curves.)\n \\param buflen    The total length of the buffer in bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BUFFER_TOO_SMALL if the \\p key\nrepresentation is larger than the available space in \\p buf.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if the operation for\n                  the group is not implemented.\n \\return          Another negative error code on different kinds of failure."]
	pub fn mbedtls_ecp_write_key(
		key: *mut mbedtls_ecp_keypair,
		buf: *mut ::std::os::raw::c_uchar,
		buflen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function checks that the keypair objects\n                  \\p pub and \\p prv have the same group and the\n                  same public point, and that the private key in\n                  \\p prv is consistent with the public key.\n\n \\param pub       The keypair structure holding the public key. This\n                  must be initialized. If it contains a private key, that\n                  part is ignored.\n \\param prv       The keypair structure holding the full keypair.\n                  This must be initialized.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be \\c\n                  NULL if \\p f_rng doesn't need a context.\n\n \\return          \\c 0 on success, meaning that the keys are valid and match.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if the keys are invalid or do not match.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or an \\c MBEDTLS_ERR_MPI_XXX\n                  error code on calculation failure."]
	pub fn mbedtls_ecp_check_pub_priv(
		pub_: *const mbedtls_ecp_keypair,
		prv: *const mbedtls_ecp_keypair,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function exports generic key-pair parameters.\n\n \\param key       The key pair to export from.\n \\param grp       Slot for exported ECP group.\n                  It must point to an initialized ECP group.\n \\param d         Slot for the exported secret value.\n                  It must point to an initialized mpi.\n \\param Q         Slot for the exported public value.\n                  It must point to an initialized ECP point.\n\n \\return          \\c 0 on success,\n \\return          #MBEDTLS_ERR_MPI_ALLOC_FAILED on memory-allocation failure.\n \\return          #MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE if key id doesn't\n                  correspond to a known group.\n \\return          Another negative error code on other kinds of failure."]
	pub fn mbedtls_ecp_export(
		key: *const mbedtls_ecp_keypair,
		grp: *mut mbedtls_ecp_group,
		d: *mut mbedtls_mpi,
		Q: *mut mbedtls_ecp_point,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          The ECP checkup routine.\n\n \\return         \\c 0 on success.\n \\return         \\c 1 on failure."]
	pub fn mbedtls_ecp_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " \\brief           The ECDSA context structure.\n\n \\warning         Performing multiple operations concurrently on the same\n                  ECDSA context is not supported; objects of this type\n                  should not be shared between multiple threads.\n\n \\note            pk_wrap module assumes that \"ecdsa_context\" is identical\n                  to \"ecp_keypair\" (see for example structure\n                  \"mbedtls_eckey_info\" where ECDSA sign/verify functions\n                  are used also for EC key)"]
pub type mbedtls_ecdsa_context = mbedtls_ecp_keypair;
pub type mbedtls_ecdsa_restart_ctx = ::std::os::raw::c_void;
extern "C" {
	#[doc = " \\brief          This function checks whether a given group can be used\n                 for ECDSA.\n\n \\param gid      The ECP group ID to check.\n\n \\return         \\c 1 if the group can be used, \\c 0 otherwise"]
	pub fn mbedtls_ecdsa_can_do(gid: mbedtls_ecp_group_id) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function computes the ECDSA signature of a\n                  previously-hashed message.\n\n \\note            The deterministic version implemented in\n                  mbedtls_ecdsa_sign_det_ext() is usually preferred.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated\n                  as defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param grp       The context for the elliptic curve to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param r         The MPI context in which to store the first part\n                  the signature. This must be initialized.\n \\param s         The MPI context in which to store the second part\n                  the signature. This must be initialized.\n \\param d         The private signing key. This must be initialized.\n \\param buf       The content to be signed. This is usually the hash of\n                  the original data to be signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param f_rng     The RNG function. This must not be \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng doesn't need a context parameter.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX\n                  or \\c MBEDTLS_MPI_XXX error code on failure."]
	pub fn mbedtls_ecdsa_sign(
		grp: *mut mbedtls_ecp_group,
		r: *mut mbedtls_mpi,
		s: *mut mbedtls_mpi,
		d: *const mbedtls_mpi,
		buf: *const ::std::os::raw::c_uchar,
		blen: usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function computes the ECDSA signature of a\n                  previously-hashed message, deterministic version.\n\n                  For more information, see <em>RFC-6979: Deterministic\n                  Usage of the Digital Signature Algorithm (DSA) and Elliptic\n                  Curve Digital Signature Algorithm (ECDSA)</em>.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param grp           The context for the elliptic curve to use.\n                      This must be initialized and have group parameters\n                      set, for example through mbedtls_ecp_group_load().\n \\param r             The MPI context in which to store the first part\n                      the signature. This must be initialized.\n \\param s             The MPI context in which to store the second part\n                      the signature. This must be initialized.\n \\param d             The private signing key. This must be initialized\n                      and setup, for example through mbedtls_ecp_gen_privkey().\n \\param buf           The hashed content to be signed. This must be a readable\n                      buffer of length \\p blen Bytes. It may be \\c NULL if\n                      \\p blen is zero.\n \\param blen          The length of \\p buf in Bytes.\n \\param md_alg        The hash algorithm used to hash the original data.\n \\param f_rng_blind   The RNG function used for blinding. This must not be\n                      \\c NULL.\n \\param p_rng_blind   The RNG context to be passed to \\p f_rng_blind. This\n                      may be \\c NULL if \\p f_rng_blind doesn't need a context\n                      parameter.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
	pub fn mbedtls_ecdsa_sign_det_ext(
		grp: *mut mbedtls_ecp_group,
		r: *mut mbedtls_mpi,
		s: *mut mbedtls_mpi,
		d: *const mbedtls_mpi,
		buf: *const ::std::os::raw::c_uchar,
		blen: usize,
		md_alg: mbedtls_md_type_t,
		f_rng_blind: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng_blind: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function computes the ECDSA signature of a\n                      previously-hashed message, in a restartable way.\n\n \\note                The deterministic version implemented in\n                      mbedtls_ecdsa_sign_det_restartable() is usually\n                      preferred.\n\n \\note                This function is like \\c mbedtls_ecdsa_sign() but\n                      it can return early and restart according to the\n                      limit set with \\c mbedtls_ecp_set_max_ops() to\n                      reduce blocking.\n\n \\note                If the bitlength of the message hash is larger\n                      than the bitlength of the group order, then the\n                      hash is truncated as defined in <em>Standards for\n                      Efficient Cryptography Group (SECG): SEC1 Elliptic\n                      Curve Cryptography</em>, section 4.1.3, step 5.\n\n \\see                 ecp.h\n\n \\param grp           The context for the elliptic curve to use.\n                      This must be initialized and have group parameters\n                      set, for example through mbedtls_ecp_group_load().\n \\param r             The MPI context in which to store the first part\n                      the signature. This must be initialized.\n \\param s             The MPI context in which to store the second part\n                      the signature. This must be initialized.\n \\param d             The private signing key. This must be initialized\n                      and setup, for example through\n                      mbedtls_ecp_gen_privkey().\n \\param buf           The hashed content to be signed. This must be a readable\n                      buffer of length \\p blen Bytes. It may be \\c NULL if\n                      \\p blen is zero.\n \\param blen          The length of \\p buf in Bytes.\n \\param f_rng         The RNG function. This must not be \\c NULL.\n \\param p_rng         The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n \\param f_rng_blind   The RNG function used for blinding. This must not be\n                      \\c NULL.\n \\param p_rng_blind   The RNG context to be passed to \\p f_rng. This may be\n                      \\c NULL if \\p f_rng doesn't need a context parameter.\n \\param rs_ctx        The restart context to use. This may be \\c NULL\n                      to disable restarting. If it is not \\c NULL, it\n                      must point to an initialized restart context.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                      operations was reached: see \\c\n                      mbedtls_ecp_set_max_ops().\n \\return              Another \\c MBEDTLS_ERR_ECP_XXX, \\c\n                      MBEDTLS_ERR_MPI_XXX or \\c MBEDTLS_ERR_ASN1_XXX\n                      error code on failure."]
	pub fn mbedtls_ecdsa_sign_restartable(
		grp: *mut mbedtls_ecp_group,
		r: *mut mbedtls_mpi,
		s: *mut mbedtls_mpi,
		d: *const mbedtls_mpi,
		buf: *const ::std::os::raw::c_uchar,
		blen: usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
		f_rng_blind: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng_blind: *mut ::std::os::raw::c_void,
		rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               This function computes the ECDSA signature of a\n                      previously-hashed message, in a restartable way.\n\n \\note                This function is like \\c\n                      mbedtls_ecdsa_sign_det_ext() but it can return\n                      early and restart according to the limit set with\n                      \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\note                If the bitlength of the message hash is larger\n                      than the bitlength of the group order, then the\n                      hash is truncated as defined in <em>Standards for\n                      Efficient Cryptography Group (SECG): SEC1 Elliptic\n                      Curve Cryptography</em>, section 4.1.3, step 5.\n\n \\see                 ecp.h\n\n \\param grp           The context for the elliptic curve to use.\n                      This must be initialized and have group parameters\n                      set, for example through mbedtls_ecp_group_load().\n \\param r             The MPI context in which to store the first part\n                      the signature. This must be initialized.\n \\param s             The MPI context in which to store the second part\n                      the signature. This must be initialized.\n \\param d             The private signing key. This must be initialized\n                      and setup, for example through\n                      mbedtls_ecp_gen_privkey().\n \\param buf           The hashed content to be signed. This must be a readable\n                      buffer of length \\p blen Bytes. It may be \\c NULL if\n                      \\p blen is zero.\n \\param blen          The length of \\p buf in Bytes.\n \\param md_alg        The hash algorithm used to hash the original data.\n \\param f_rng_blind   The RNG function used for blinding. This must not be\n                      \\c NULL.\n \\param p_rng_blind   The RNG context to be passed to \\p f_rng_blind. This may be\n                      \\c NULL if \\p f_rng_blind doesn't need a context parameter.\n \\param rs_ctx        The restart context to use. This may be \\c NULL\n                      to disable restarting. If it is not \\c NULL, it\n                      must point to an initialized restart context.\n\n \\return              \\c 0 on success.\n \\return              #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                      operations was reached: see \\c\n                      mbedtls_ecp_set_max_ops().\n \\return              Another \\c MBEDTLS_ERR_ECP_XXX, \\c\n                      MBEDTLS_ERR_MPI_XXX or \\c MBEDTLS_ERR_ASN1_XXX\n                      error code on failure."]
	pub fn mbedtls_ecdsa_sign_det_restartable(
		grp: *mut mbedtls_ecp_group,
		r: *mut mbedtls_mpi,
		s: *mut mbedtls_mpi,
		d: *const mbedtls_mpi,
		buf: *const ::std::os::raw::c_uchar,
		blen: usize,
		md_alg: mbedtls_md_type_t,
		f_rng_blind: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng_blind: *mut ::std::os::raw::c_void,
		rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function verifies the ECDSA signature of a\n                  previously-hashed message.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param buf       The hashed content that was signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param Q         The public key to use for verification. This must be\n                  initialized and setup.\n \\param r         The first integer of the signature.\n                  This must be initialized.\n \\param s         The second integer of the signature.\n                  This must be initialized.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
	pub fn mbedtls_ecdsa_verify(
		grp: *mut mbedtls_ecp_group,
		buf: *const ::std::os::raw::c_uchar,
		blen: usize,
		Q: *const mbedtls_ecp_point,
		r: *const mbedtls_mpi,
		s: *const mbedtls_mpi,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function verifies the ECDSA signature of a\n                  previously-hashed message, in a restartable manner\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param grp       The ECP group to use.\n                  This must be initialized and have group parameters\n                  set, for example through mbedtls_ecp_group_load().\n \\param buf       The hashed content that was signed. This must be a readable\n                  buffer of length \\p blen Bytes. It may be \\c NULL if\n                  \\p blen is zero.\n \\param blen      The length of \\p buf in Bytes.\n \\param Q         The public key to use for verification. This must be\n                  initialized and setup.\n \\param r         The first integer of the signature.\n                  This must be initialized.\n \\param s         The second integer of the signature.\n                  This must be initialized.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_MPI_XXX\n                  error code on failure."]
	pub fn mbedtls_ecdsa_verify_restartable(
		grp: *mut mbedtls_ecp_group,
		buf: *const ::std::os::raw::c_uchar,
		blen: usize,
		Q: *const mbedtls_ecp_point,
		r: *const mbedtls_mpi,
		s: *const mbedtls_mpi,
		rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function computes the ECDSA signature and writes it\n                  to a buffer, serialized as defined in <em>RFC-4492:\n                  Elliptic Curve Cryptography (ECC) Cipher Suites for\n                  Transport Layer Security (TLS)</em>.\n\n \\warning         It is not thread-safe to use the same context in\n                  multiple threads.\n\n \\note            The deterministic version is used if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is defined. For more\n                  information, see <em>RFC-6979: Deterministic Usage\n                  of the Digital Signature Algorithm (DSA) and Elliptic\n                  Curve Digital Signature Algorithm (ECDSA)</em>.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.3, step 5.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and private key bound to it, for example\n                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().\n \\param md_alg    The message digest that was used to hash the message.\n \\param hash      The message hash to be signed. This must be a readable\n                  buffer of length \\p hlen Bytes.\n \\param hlen      The length of the hash \\p hash in Bytes.\n \\param sig       The buffer to which to write the signature. This must be a\n                  writable buffer of length at least twice as large as the\n                  size of the curve used, plus 9. For example, 73 Bytes if\n                  a 256-bit curve is used. A buffer length of\n                  #MBEDTLS_ECDSA_MAX_LEN is always safe.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param slen      The address at which to store the actual length of\n                  the signature written. Must not be \\c NULL.\n \\param f_rng     The RNG function. This must not be \\c NULL if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,\n                  it is used only for blinding and may be set to \\c NULL, but\n                  doing so is DEPRECATED.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or\n                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
	pub fn mbedtls_ecdsa_write_signature(
		ctx: *mut mbedtls_ecdsa_context,
		md_alg: mbedtls_md_type_t,
		hash: *const ::std::os::raw::c_uchar,
		hlen: usize,
		sig: *mut ::std::os::raw::c_uchar,
		sig_size: usize,
		slen: *mut usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function computes the ECDSA signature and writes it\n                  to a buffer, in a restartable way.\n\n \\see             \\c mbedtls_ecdsa_write_signature()\n\n \\note            This function is like \\c mbedtls_ecdsa_write_signature()\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and private key bound to it, for example\n                  via mbedtls_ecdsa_genkey() or mbedtls_ecdsa_from_keypair().\n \\param md_alg    The message digest that was used to hash the message.\n \\param hash      The message hash to be signed. This must be a readable\n                  buffer of length \\p hlen Bytes.\n \\param hlen      The length of the hash \\p hash in Bytes.\n \\param sig       The buffer to which to write the signature. This must be a\n                  writable buffer of length at least twice as large as the\n                  size of the curve used, plus 9. For example, 73 Bytes if\n                  a 256-bit curve is used. A buffer length of\n                  #MBEDTLS_ECDSA_MAX_LEN is always safe.\n \\param sig_size  The size of the \\p sig buffer in bytes.\n \\param slen      The address at which to store the actual length of\n                  the signature written. Must not be \\c NULL.\n \\param f_rng     The RNG function. This must not be \\c NULL if\n                  #MBEDTLS_ECDSA_DETERMINISTIC is unset. Otherwise,\n                  it is unused and may be set to \\c NULL.\n \\param p_rng     The RNG context to be passed to \\p f_rng. This may be\n                  \\c NULL if \\p f_rng is \\c NULL or doesn't use a context.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX, \\c MBEDTLS_ERR_MPI_XXX or\n                  \\c MBEDTLS_ERR_ASN1_XXX error code on failure."]
	pub fn mbedtls_ecdsa_write_signature_restartable(
		ctx: *mut mbedtls_ecdsa_context,
		md_alg: mbedtls_md_type_t,
		hash: *const ::std::os::raw::c_uchar,
		hlen: usize,
		sig: *mut ::std::os::raw::c_uchar,
		sig_size: usize,
		slen: *mut usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
		rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function reads and verifies an ECDSA signature.\n\n \\note            If the bitlength of the message hash is larger than the\n                  bitlength of the group order, then the hash is truncated as\n                  defined in <em>Standards for Efficient Cryptography Group\n                  (SECG): SEC1 Elliptic Curve Cryptography</em>, section\n                  4.1.4, step 3.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and public key bound to it.\n \\param hash      The message hash that was signed. This must be a readable\n                  buffer of length \\p hlen Bytes.\n \\param hlen      The size of the hash \\p hash.\n \\param sig       The signature to read and verify. This must be a readable\n                  buffer of length \\p slen Bytes.\n \\param slen      The size of \\p sig in Bytes.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.\n \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid\n                  signature in \\p sig, but its length is less than \\p siglen.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX\n                  error code on failure for any other reason."]
	pub fn mbedtls_ecdsa_read_signature(
		ctx: *mut mbedtls_ecdsa_context,
		hash: *const ::std::os::raw::c_uchar,
		hlen: usize,
		sig: *const ::std::os::raw::c_uchar,
		slen: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function reads and verifies an ECDSA signature,\n                  in a restartable way.\n\n \\see             \\c mbedtls_ecdsa_read_signature()\n\n \\note            This function is like \\c mbedtls_ecdsa_read_signature()\n                  but it can return early and restart according to the limit\n                  set with \\c mbedtls_ecp_set_max_ops() to reduce blocking.\n\n \\param ctx       The ECDSA context to use. This must be initialized\n                  and have a group and public key bound to it.\n \\param hash      The message hash that was signed. This must be a readable\n                  buffer of length \\p hlen Bytes.\n \\param hlen      The size of the hash \\p hash.\n \\param sig       The signature to read and verify. This must be a readable\n                  buffer of length \\p slen Bytes.\n \\param slen      The size of \\p sig in Bytes.\n \\param rs_ctx    The restart context to use. This may be \\c NULL to disable\n                  restarting. If it is not \\c NULL, it must point to an\n                  initialized restart context.\n\n \\return          \\c 0 on success.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if signature is invalid.\n \\return          #MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH if there is a valid\n                  signature in \\p sig, but its length is less than \\p siglen.\n \\return          #MBEDTLS_ERR_ECP_IN_PROGRESS if maximum number of\n                  operations was reached: see \\c mbedtls_ecp_set_max_ops().\n \\return          Another \\c MBEDTLS_ERR_ECP_XXX or \\c MBEDTLS_ERR_MPI_XXX\n                  error code on failure for any other reason."]
	pub fn mbedtls_ecdsa_read_signature_restartable(
		ctx: *mut mbedtls_ecdsa_context,
		hash: *const ::std::os::raw::c_uchar,
		hlen: usize,
		sig: *const ::std::os::raw::c_uchar,
		slen: usize,
		rs_ctx: *mut mbedtls_ecdsa_restart_ctx,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief          This function generates an ECDSA keypair on the given curve.\n\n \\see            ecp.h\n\n \\param ctx      The ECDSA context to store the keypair in.\n                 This must be initialized.\n \\param gid      The elliptic curve to use. One of the various\n                 \\c MBEDTLS_ECP_DP_XXX macros depending on configuration.\n \\param f_rng    The RNG function to use. This must not be \\c NULL.\n \\param p_rng    The RNG context to be passed to \\p f_rng. This may be\n                 \\c NULL if \\p f_rng doesn't need a context argument.\n\n \\return         \\c 0 on success.\n \\return         An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
	pub fn mbedtls_ecdsa_genkey(
		ctx: *mut mbedtls_ecdsa_context,
		gid: mbedtls_ecp_group_id,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function sets up an ECDSA context from an EC key pair.\n\n \\see             ecp.h\n\n \\param ctx       The ECDSA context to setup. This must be initialized.\n \\param key       The EC key to use. This must be initialized and hold\n                  a private-public key pair or a public key. In the former\n                  case, the ECDSA context may be used for signature creation\n                  and verification after this call. In the latter case, it\n                  may be used for signature verification.\n\n \\return          \\c 0 on success.\n \\return          An \\c MBEDTLS_ERR_ECP_XXX code on failure."]
	pub fn mbedtls_ecdsa_from_keypair(
		ctx: *mut mbedtls_ecdsa_context,
		key: *const mbedtls_ecp_keypair,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This function initializes an ECDSA context.\n\n \\param ctx       The ECDSA context to initialize.\n                  This must not be \\c NULL."]
	pub fn mbedtls_ecdsa_init(ctx: *mut mbedtls_ecdsa_context);
}
extern "C" {
	#[doc = " \\brief           This function frees an ECDSA context.\n\n \\param ctx       The ECDSA context to free. This may be \\c NULL,\n                  in which case this function does nothing. If it\n                  is not \\c NULL, it must be initialized."]
	pub fn mbedtls_ecdsa_free(ctx: *mut mbedtls_ecdsa_context);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_psa_sign_hash_interruptible_operation_t {
	pub private_dummy: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_sign_hash_interruptible_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_sign_hash_interruptible_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_sign_hash_interruptible_operation_t>(),
		4usize,
		concat!(
			"Size of: ",
			stringify!(mbedtls_psa_sign_hash_interruptible_operation_t)
		)
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_sign_hash_interruptible_operation_t>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(mbedtls_psa_sign_hash_interruptible_operation_t)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_sign_hash_interruptible_operation_t),
			"::",
			stringify!(private_dummy)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_psa_verify_hash_interruptible_operation_t {
	pub private_dummy: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_verify_hash_interruptible_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_verify_hash_interruptible_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_verify_hash_interruptible_operation_t>(),
		4usize,
		concat!(
			"Size of: ",
			stringify!(mbedtls_psa_verify_hash_interruptible_operation_t)
		)
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_verify_hash_interruptible_operation_t>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(mbedtls_psa_verify_hash_interruptible_operation_t)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_verify_hash_interruptible_operation_t),
			"::",
			stringify!(private_dummy)
		)
	);
}
#[doc = "< Client"]
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_CLIENT: mbedtls_ecjpake_role = 0;
#[doc = "< Server"]
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_SERVER: mbedtls_ecjpake_role = 1;
#[doc = "< Undefined"]
pub const mbedtls_ecjpake_role_MBEDTLS_ECJPAKE_NONE: mbedtls_ecjpake_role = 2;
#[doc = " Roles in the EC J-PAKE exchange"]
pub type mbedtls_ecjpake_role = ::std::os::raw::c_uint;
#[doc = " EC J-PAKE context structure.\n\n J-PAKE is a symmetric protocol, except for the identifiers used in\n Zero-Knowledge Proofs, and the serialization of the second message\n (KeyExchange) as defined by the Thread spec.\n\n In order to benefit from this symmetry, we choose a different naming\n convention from the Thread v1.0 spec. Correspondence is indicated in the\n description as a pair C: client name, S: server name"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_ecjpake_context {
	pub private_md_type: mbedtls_md_type_t,
	pub private_grp: mbedtls_ecp_group,
	pub private_role: mbedtls_ecjpake_role,
	pub private_point_format: ::std::os::raw::c_int,
	pub private_Xm1: mbedtls_ecp_point,
	pub private_Xm2: mbedtls_ecp_point,
	pub private_Xp1: mbedtls_ecp_point,
	pub private_Xp2: mbedtls_ecp_point,
	pub private_Xp: mbedtls_ecp_point,
	pub private_xm1: mbedtls_mpi,
	pub private_xm2: mbedtls_mpi,
	pub private_s: mbedtls_mpi,
}
#[test]
fn bindgen_test_layout_mbedtls_ecjpake_context() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_ecjpake_context> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_ecjpake_context>(),
		496usize,
		concat!("Size of: ", stringify!(mbedtls_ecjpake_context))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_ecjpake_context>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_ecjpake_context))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_md_type) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_md_type)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_grp) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_grp)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_role) as usize - ptr as usize },
		200usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_role)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_point_format) as usize - ptr as usize },
		204usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_point_format)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Xm1) as usize - ptr as usize },
		208usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_Xm1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Xm2) as usize - ptr as usize },
		256usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_Xm2)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Xp1) as usize - ptr as usize },
		304usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_Xp1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Xp2) as usize - ptr as usize },
		352usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_Xp2)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Xp) as usize - ptr as usize },
		400usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_Xp)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_xm1) as usize - ptr as usize },
		448usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_xm1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_xm2) as usize - ptr as usize },
		464usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_xm2)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_s) as usize - ptr as usize },
		480usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_ecjpake_context),
			"::",
			stringify!(private_s)
		)
	);
}
extern "C" {
	#[doc = " \\brief           Initialize an ECJPAKE context.\n\n \\param ctx       The ECJPAKE context to initialize.\n                  This must not be \\c NULL."]
	pub fn mbedtls_ecjpake_init(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
	#[doc = " \\brief           Set up an ECJPAKE context for use.\n\n \\note            Currently the only values for hash/curve allowed by the\n                  standard are #MBEDTLS_MD_SHA256/#MBEDTLS_ECP_DP_SECP256R1.\n\n \\param ctx       The ECJPAKE context to set up. This must be initialized.\n \\param role      The role of the caller. This must be either\n                  #MBEDTLS_ECJPAKE_CLIENT or #MBEDTLS_ECJPAKE_SERVER.\n \\param hash      The identifier of the hash function to use,\n                  for example #MBEDTLS_MD_SHA256.\n \\param curve     The identifier of the elliptic curve to use,\n                  for example #MBEDTLS_ECP_DP_SECP256R1.\n \\param secret    The pre-shared secret (passphrase). This must be\n                  a readable not empty buffer of length \\p len Bytes. It need\n                  only be valid for the duration of this call.\n \\param len       The length of the pre-shared secret \\p secret.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecjpake_setup(
		ctx: *mut mbedtls_ecjpake_context,
		role: mbedtls_ecjpake_role,
		hash: mbedtls_md_type_t,
		curve: mbedtls_ecp_group_id,
		secret: *const ::std::os::raw::c_uchar,
		len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief               Set the point format for future reads and writes.\n\n \\param ctx           The ECJPAKE context to configure.\n \\param point_format  The point format to use:\n                      #MBEDTLS_ECP_PF_UNCOMPRESSED (default)\n                      or #MBEDTLS_ECP_PF_COMPRESSED.\n\n \\return              \\c 0 if successful.\n \\return              #MBEDTLS_ERR_ECP_BAD_INPUT_DATA if \\p point_format\n                      is invalid."]
	pub fn mbedtls_ecjpake_set_point_format(
		ctx: *mut mbedtls_ecjpake_context,
		point_format: ::std::os::raw::c_int,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Check if an ECJPAKE context is ready for use.\n\n \\param ctx       The ECJPAKE context to check. This must be\n                  initialized.\n\n \\return          \\c 0 if the context is ready for use.\n \\return          #MBEDTLS_ERR_ECP_BAD_INPUT_DATA otherwise."]
	pub fn mbedtls_ecjpake_check(ctx: *const mbedtls_ecjpake_context) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Generate and write the first round message\n                  (TLS: contents of the Client/ServerHello extension,\n                  excluding extension type and length bytes).\n\n \\param ctx       The ECJPAKE context to use. This must be\n                  initialized and set up.\n \\param buf       The buffer to write the contents to. This must be a\n                  writable buffer of length \\p len Bytes.\n \\param len       The length of \\p buf in Bytes.\n \\param olen      The address at which to store the total number\n                  of Bytes written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecjpake_write_round_one(
		ctx: *mut mbedtls_ecjpake_context,
		buf: *mut ::std::os::raw::c_uchar,
		len: usize,
		olen: *mut usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Read and process the first round message\n                  (TLS: contents of the Client/ServerHello extension,\n                  excluding extension type and length bytes).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized\n                  and set up.\n \\param buf       The buffer holding the first round message. This must\n                  be a readable buffer of length \\p len Bytes.\n \\param len       The length in Bytes of \\p buf.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecjpake_read_round_one(
		ctx: *mut mbedtls_ecjpake_context,
		buf: *const ::std::os::raw::c_uchar,
		len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Generate and write the second round message\n                  (TLS: contents of the Client/ServerKeyExchange).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized,\n                  set up, and already have performed round one.\n \\param buf       The buffer to write the round two contents to.\n                  This must be a writable buffer of length \\p len Bytes.\n \\param len       The size of \\p buf in Bytes.\n \\param olen      The address at which to store the total number of Bytes\n                  written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecjpake_write_round_two(
		ctx: *mut mbedtls_ecjpake_context,
		buf: *mut ::std::os::raw::c_uchar,
		len: usize,
		olen: *mut usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Read and process the second round message\n                  (TLS: contents of the Client/ServerKeyExchange).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized\n                  and set up and already have performed round one.\n \\param buf       The buffer holding the second round message. This must\n                  be a readable buffer of length \\p len Bytes.\n \\param len       The length in Bytes of \\p buf.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecjpake_read_round_two(
		ctx: *mut mbedtls_ecjpake_context,
		buf: *const ::std::os::raw::c_uchar,
		len: usize,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Derive the shared secret\n                  (TLS: Pre-Master Secret).\n\n \\param ctx       The ECJPAKE context to use. This must be initialized,\n                  set up and have performed both round one and two.\n \\param buf       The buffer to write the derived secret to. This must\n                  be a writable buffer of length \\p len Bytes.\n \\param len       The length of \\p buf in Bytes.\n \\param olen      The address at which to store the total number of Bytes\n                  written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecjpake_derive_secret(
		ctx: *mut mbedtls_ecjpake_context,
		buf: *mut ::std::os::raw::c_uchar,
		len: usize,
		olen: *mut usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           Write the shared key material to be passed to a Key\n                  Derivation Function as described in RFC8236.\n\n \\param ctx       The ECJPAKE context to use. This must be initialized,\n                  set up and have performed both round one and two.\n \\param buf       The buffer to write the derived secret to. This must\n                  be a writable buffer of length \\p len Bytes.\n \\param len       The length of \\p buf in Bytes.\n \\param olen      The address at which to store the total number of bytes\n                  written to \\p buf. This must not be \\c NULL.\n \\param f_rng     The RNG function to use. This must not be \\c NULL.\n \\param p_rng     The RNG parameter to be passed to \\p f_rng. This\n                  may be \\c NULL if \\p f_rng doesn't use a context.\n\n \\return          \\c 0 if successful.\n \\return          A negative error code on failure."]
	pub fn mbedtls_ecjpake_write_shared_key(
		ctx: *mut mbedtls_ecjpake_context,
		buf: *mut ::std::os::raw::c_uchar,
		len: usize,
		olen: *mut usize,
		f_rng: ::std::option::Option<
			unsafe extern "C" fn(
				arg1: *mut ::std::os::raw::c_void,
				arg2: *mut ::std::os::raw::c_uchar,
				arg3: usize,
			) -> ::std::os::raw::c_int,
		>,
		p_rng: *mut ::std::os::raw::c_void,
	) -> ::std::os::raw::c_int;
}
extern "C" {
	#[doc = " \\brief           This clears an ECJPAKE context and frees any\n                  embedded data structure.\n\n \\param ctx       The ECJPAKE context to free. This may be \\c NULL,\n                  in which case this function does nothing. If it is not\n                  \\c NULL, it must point to an initialized ECJPAKE context."]
	pub fn mbedtls_ecjpake_free(ctx: *mut mbedtls_ecjpake_context);
}
extern "C" {
	#[doc = " \\brief          Checkup routine\n\n \\return         0 if successful, or 1 if a test failed"]
	pub fn mbedtls_ecjpake_self_test(verbose: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mbedtls_psa_pake_operation_t {
	pub private_alg: psa_algorithm_t,
	pub private_password: *mut u8,
	pub private_password_len: usize,
	pub private_role: mbedtls_ecjpake_role,
	pub private_buffer: [u8; 336usize],
	pub private_buffer_length: usize,
	pub private_buffer_offset: usize,
	pub private_ctx: mbedtls_psa_pake_operation_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mbedtls_psa_pake_operation_t__bindgen_ty_1 {
	pub private_dummy: ::std::os::raw::c_uint,
	pub private_jpake: mbedtls_ecjpake_context,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_pake_operation_t__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_pake_operation_t__bindgen_ty_1> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_pake_operation_t__bindgen_ty_1>(),
		496usize,
		concat!(
			"Size of: ",
			stringify!(mbedtls_psa_pake_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_pake_operation_t__bindgen_ty_1>(),
		8usize,
		concat!(
			"Alignment of ",
			stringify!(mbedtls_psa_pake_operation_t__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_jpake) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t__bindgen_ty_1),
			"::",
			stringify!(private_jpake)
		)
	);
}
#[test]
fn bindgen_test_layout_mbedtls_psa_pake_operation_t() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_pake_operation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_pake_operation_t>(),
		880usize,
		concat!("Size of: ", stringify!(mbedtls_psa_pake_operation_t))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_pake_operation_t>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_psa_pake_operation_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_password) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_password)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_password_len) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_password_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_role) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_role)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer) as usize - ptr as usize },
		28usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_buffer)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer_length) as usize - ptr as usize },
		368usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_buffer_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_buffer_offset) as usize - ptr as usize },
		376usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_buffer_offset)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		384usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_pake_operation_t),
			"::",
			stringify!(private_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_mac_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub mbedtls_ctx: mbedtls_psa_mac_operation_t,
}
#[test]
fn bindgen_test_layout_psa_driver_mac_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_mac_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_mac_context_t>(),
		376usize,
		concat!("Size of: ", stringify!(psa_driver_mac_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_mac_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_driver_mac_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_mac_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbedtls_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_mac_context_t),
			"::",
			stringify!(mbedtls_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_aead_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub mbedtls_ctx: mbedtls_psa_aead_operation_t,
}
#[test]
fn bindgen_test_layout_psa_driver_aead_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_aead_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_aead_context_t>(),
		432usize,
		concat!("Size of: ", stringify!(psa_driver_aead_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_aead_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_driver_aead_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_aead_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbedtls_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_aead_context_t),
			"::",
			stringify!(mbedtls_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_sign_hash_interruptible_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub mbedtls_ctx: mbedtls_psa_sign_hash_interruptible_operation_t,
}
#[test]
fn bindgen_test_layout_psa_driver_sign_hash_interruptible_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_sign_hash_interruptible_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_sign_hash_interruptible_context_t>(),
		4usize,
		concat!(
			"Size of: ",
			stringify!(psa_driver_sign_hash_interruptible_context_t)
		)
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_sign_hash_interruptible_context_t>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(psa_driver_sign_hash_interruptible_context_t)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_sign_hash_interruptible_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbedtls_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_sign_hash_interruptible_context_t),
			"::",
			stringify!(mbedtls_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_verify_hash_interruptible_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub mbedtls_ctx: mbedtls_psa_verify_hash_interruptible_operation_t,
}
#[test]
fn bindgen_test_layout_psa_driver_verify_hash_interruptible_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_verify_hash_interruptible_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_verify_hash_interruptible_context_t>(),
		4usize,
		concat!(
			"Size of: ",
			stringify!(psa_driver_verify_hash_interruptible_context_t)
		)
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_verify_hash_interruptible_context_t>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(psa_driver_verify_hash_interruptible_context_t)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_verify_hash_interruptible_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbedtls_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_verify_hash_interruptible_context_t),
			"::",
			stringify!(mbedtls_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_pake_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub mbedtls_ctx: mbedtls_psa_pake_operation_t,
}
#[test]
fn bindgen_test_layout_psa_driver_pake_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_pake_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_pake_context_t>(),
		880usize,
		concat!("Size of: ", stringify!(psa_driver_pake_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_pake_context_t>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_driver_pake_context_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_pake_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).mbedtls_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_pake_context_t),
			"::",
			stringify!(mbedtls_ctx)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_mac_operation_s {
	pub private_id: ::std::os::raw::c_uint,
	pub private_mac_size: u8,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_ctx: psa_driver_mac_context_t,
}
#[test]
fn bindgen_test_layout_psa_mac_operation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_mac_operation_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_mac_operation_s>(),
		384usize,
		concat!("Size of: ", stringify!(psa_mac_operation_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_mac_operation_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_mac_operation_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_mac_operation_s),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_mac_size) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_mac_operation_s),
			"::",
			stringify!(private_mac_size)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_mac_operation_s),
			"::",
			stringify!(private_ctx)
		)
	);
}
impl psa_mac_operation_s {
	#[inline]
	pub fn private_is_sign(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_is_sign(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_is_sign: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			let private_is_sign: u32 = unsafe { ::std::mem::transmute(private_is_sign) };
			private_is_sign as u64
		});
		__bindgen_bitfield_unit
	}
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_aead_operation_s {
	pub private_id: ::std::os::raw::c_uint,
	pub private_alg: psa_algorithm_t,
	pub private_key_type: psa_key_type_t,
	pub private_ad_remaining: usize,
	pub private_body_remaining: usize,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_ctx: psa_driver_aead_context_t,
}
#[test]
fn bindgen_test_layout_psa_aead_operation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_aead_operation_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_aead_operation_s>(),
		472usize,
		concat!("Size of: ", stringify!(psa_aead_operation_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_aead_operation_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_aead_operation_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_aead_operation_s),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_aead_operation_s),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_key_type) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_aead_operation_s),
			"::",
			stringify!(private_key_type)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ad_remaining) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_aead_operation_s),
			"::",
			stringify!(private_ad_remaining)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_body_remaining) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_aead_operation_s),
			"::",
			stringify!(private_body_remaining)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_aead_operation_s),
			"::",
			stringify!(private_ctx)
		)
	);
}
impl psa_aead_operation_s {
	#[inline]
	pub fn private_nonce_set(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_nonce_set(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn private_lengths_set(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_lengths_set(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(1usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn private_ad_started(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_ad_started(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(2usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn private_body_started(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_body_started(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(3usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn private_is_encrypt(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_is_encrypt(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(4usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_nonce_set: ::std::os::raw::c_uint,
		private_lengths_set: ::std::os::raw::c_uint,
		private_ad_started: ::std::os::raw::c_uint,
		private_body_started: ::std::os::raw::c_uint,
		private_is_encrypt: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			let private_nonce_set: u32 = unsafe { ::std::mem::transmute(private_nonce_set) };
			private_nonce_set as u64
		});
		__bindgen_bitfield_unit.set(1usize, 1u8, {
			let private_lengths_set: u32 = unsafe { ::std::mem::transmute(private_lengths_set) };
			private_lengths_set as u64
		});
		__bindgen_bitfield_unit.set(2usize, 1u8, {
			let private_ad_started: u32 = unsafe { ::std::mem::transmute(private_ad_started) };
			private_ad_started as u64
		});
		__bindgen_bitfield_unit.set(3usize, 1u8, {
			let private_body_started: u32 = unsafe { ::std::mem::transmute(private_body_started) };
			private_body_started as u64
		});
		__bindgen_bitfield_unit.set(4usize, 1u8, {
			let private_is_encrypt: u32 = unsafe { ::std::mem::transmute(private_is_encrypt) };
			private_is_encrypt as u64
		});
		__bindgen_bitfield_unit
	}
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_hkdf_key_derivation_t {
	pub private_info: *mut u8,
	pub private_info_length: usize,
	pub private_offset_in_block: u8,
	pub private_block_number: u8,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_output_block: [u8; 64usize],
	pub private_prk: [u8; 64usize],
	pub private_hmac: psa_mac_operation_s,
}
#[test]
fn bindgen_test_layout_psa_hkdf_key_derivation_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_hkdf_key_derivation_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_hkdf_key_derivation_t>(),
		536usize,
		concat!("Size of: ", stringify!(psa_hkdf_key_derivation_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_hkdf_key_derivation_t>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_hkdf_key_derivation_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_info) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hkdf_key_derivation_t),
			"::",
			stringify!(private_info)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_info_length) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hkdf_key_derivation_t),
			"::",
			stringify!(private_info_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_offset_in_block) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hkdf_key_derivation_t),
			"::",
			stringify!(private_offset_in_block)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_block_number) as usize - ptr as usize },
		17usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hkdf_key_derivation_t),
			"::",
			stringify!(private_block_number)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_output_block) as usize - ptr as usize },
		19usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hkdf_key_derivation_t),
			"::",
			stringify!(private_output_block)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_prk) as usize - ptr as usize },
		83usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hkdf_key_derivation_t),
			"::",
			stringify!(private_prk)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_hmac) as usize - ptr as usize },
		152usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_hkdf_key_derivation_t),
			"::",
			stringify!(private_hmac)
		)
	);
}
impl psa_hkdf_key_derivation_t {
	#[inline]
	pub fn private_state(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
	}
	#[inline]
	pub fn set_private_state(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 2u8, val as u64)
		}
	}
	#[inline]
	pub fn private_info_set(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_info_set(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(2usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_state: ::std::os::raw::c_uint,
		private_info_set: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 2u8, {
			let private_state: u32 = unsafe { ::std::mem::transmute(private_state) };
			private_state as u64
		});
		__bindgen_bitfield_unit.set(2usize, 1u8, {
			let private_info_set: u32 = unsafe { ::std::mem::transmute(private_info_set) };
			private_info_set as u64
		});
		__bindgen_bitfield_unit
	}
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_tls12_ecjpake_to_pms_t {
	pub private_data: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_psa_tls12_ecjpake_to_pms_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_tls12_ecjpake_to_pms_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_tls12_ecjpake_to_pms_t>(),
		32usize,
		concat!("Size of: ", stringify!(psa_tls12_ecjpake_to_pms_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_tls12_ecjpake_to_pms_t>(),
		1usize,
		concat!("Alignment of ", stringify!(psa_tls12_ecjpake_to_pms_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_ecjpake_to_pms_t),
			"::",
			stringify!(private_data)
		)
	);
}
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_INIT:
	psa_tls12_prf_key_derivation_state_t = 0;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_SEED_SET:
	psa_tls12_prf_key_derivation_state_t = 1;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OTHER_KEY_SET:
	psa_tls12_prf_key_derivation_state_t = 2;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_KEY_SET:
	psa_tls12_prf_key_derivation_state_t = 3;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_LABEL_SET:
	psa_tls12_prf_key_derivation_state_t = 4;
pub const psa_tls12_prf_key_derivation_state_t_PSA_TLS12_PRF_STATE_OUTPUT:
	psa_tls12_prf_key_derivation_state_t = 5;
pub type psa_tls12_prf_key_derivation_state_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_tls12_prf_key_derivation_s {
	pub private_left_in_block: u8,
	pub private_block_number: u8,
	pub private_state: psa_tls12_prf_key_derivation_state_t,
	pub private_secret: *mut u8,
	pub private_secret_length: usize,
	pub private_seed: *mut u8,
	pub private_seed_length: usize,
	pub private_label: *mut u8,
	pub private_label_length: usize,
	pub private_other_secret: *mut u8,
	pub private_other_secret_length: usize,
	pub private_Ai: [u8; 64usize],
	pub private_output_block: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_psa_tls12_prf_key_derivation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_tls12_prf_key_derivation_s> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_tls12_prf_key_derivation_s>(),
		200usize,
		concat!("Size of: ", stringify!(psa_tls12_prf_key_derivation_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_tls12_prf_key_derivation_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_tls12_prf_key_derivation_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_left_in_block) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_left_in_block)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_block_number) as usize - ptr as usize },
		1usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_block_number)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_state) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_state)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_secret) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_secret)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_secret_length) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_secret_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_seed) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_seed)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_seed_length) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_seed_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_label) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_label)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_label_length) as usize - ptr as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_label_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_other_secret) as usize - ptr as usize },
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_other_secret)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_other_secret_length) as usize - ptr as usize },
		64usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_other_secret_length)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_Ai) as usize - ptr as usize },
		72usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_Ai)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_output_block) as usize - ptr as usize },
		136usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_tls12_prf_key_derivation_s),
			"::",
			stringify!(private_output_block)
		)
	);
}
pub type psa_tls12_prf_key_derivation_t = psa_tls12_prf_key_derivation_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_driver_key_derivation_context_t {
	pub dummy: ::std::os::raw::c_uint,
	pub private_hkdf: psa_hkdf_key_derivation_t,
	pub private_tls12_prf: psa_tls12_prf_key_derivation_t,
	pub private_tls12_ecjpake_to_pms: psa_tls12_ecjpake_to_pms_t,
}
#[test]
fn bindgen_test_layout_psa_driver_key_derivation_context_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_driver_key_derivation_context_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_driver_key_derivation_context_t>(),
		536usize,
		concat!("Size of: ", stringify!(psa_driver_key_derivation_context_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_driver_key_derivation_context_t>(),
		8usize,
		concat!(
			"Alignment of ",
			stringify!(psa_driver_key_derivation_context_t)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_key_derivation_context_t),
			"::",
			stringify!(dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_hkdf) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_key_derivation_context_t),
			"::",
			stringify!(private_hkdf)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_tls12_prf) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_key_derivation_context_t),
			"::",
			stringify!(private_tls12_prf)
		)
	);
	assert_eq!(
		unsafe {
			::std::ptr::addr_of!((*ptr).private_tls12_ecjpake_to_pms) as usize - ptr as usize
		},
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_driver_key_derivation_context_t),
			"::",
			stringify!(private_tls12_ecjpake_to_pms)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_key_derivation_s {
	pub private_alg: psa_algorithm_t,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_capacity: usize,
	pub private_ctx: psa_driver_key_derivation_context_t,
}
#[test]
fn bindgen_test_layout_psa_key_derivation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_key_derivation_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_key_derivation_s>(),
		552usize,
		concat!("Size of: ", stringify!(psa_key_derivation_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_key_derivation_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_key_derivation_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_derivation_s),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_capacity) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_derivation_s),
			"::",
			stringify!(private_capacity)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_derivation_s),
			"::",
			stringify!(private_ctx)
		)
	);
}
impl psa_key_derivation_s {
	#[inline]
	pub fn private_can_output_key(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_can_output_key(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_can_output_key: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			let private_can_output_key: u32 =
				unsafe { ::std::mem::transmute(private_can_output_key) };
			private_can_output_key as u64
		});
		__bindgen_bitfield_unit
	}
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_key_policy_s {
	pub private_usage: psa_key_usage_t,
	pub private_alg: psa_algorithm_t,
	pub private_alg2: psa_algorithm_t,
}
#[test]
fn bindgen_test_layout_psa_key_policy_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_key_policy_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_key_policy_s>(),
		12usize,
		concat!("Size of: ", stringify!(psa_key_policy_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_key_policy_s>(),
		4usize,
		concat!("Alignment of ", stringify!(psa_key_policy_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_usage) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_policy_s),
			"::",
			stringify!(private_usage)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_policy_s),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg2) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_policy_s),
			"::",
			stringify!(private_alg2)
		)
	);
}
pub type psa_key_policy_t = psa_key_policy_s;
pub type psa_key_bits_t = u16;
#[doc = " A mask of flags that can be stored in key attributes.\n\n This type is also used internally to store flags in slots. Internal\n flags are defined in library/psa_crypto_core.h. Internal flags may have\n the same value as external flags if they are properly handled during\n key creation and in psa_get_key_attributes."]
pub type psa_key_attributes_flag_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_core_key_attributes_t {
	pub private_type: psa_key_type_t,
	pub private_bits: psa_key_bits_t,
	pub private_lifetime: psa_key_lifetime_t,
	pub private_id: mbedtls_svc_key_id_t,
	pub private_policy: psa_key_policy_t,
	pub private_flags: psa_key_attributes_flag_t,
}
#[test]
fn bindgen_test_layout_psa_core_key_attributes_t() {
	const UNINIT: ::std::mem::MaybeUninit<psa_core_key_attributes_t> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_core_key_attributes_t>(),
		28usize,
		concat!("Size of: ", stringify!(psa_core_key_attributes_t))
	);
	assert_eq!(
		::std::mem::align_of::<psa_core_key_attributes_t>(),
		4usize,
		concat!("Alignment of ", stringify!(psa_core_key_attributes_t))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_type) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_core_key_attributes_t),
			"::",
			stringify!(private_type)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_bits) as usize - ptr as usize },
		2usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_core_key_attributes_t),
			"::",
			stringify!(private_bits)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_lifetime) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_core_key_attributes_t),
			"::",
			stringify!(private_lifetime)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_core_key_attributes_t),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_policy) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_core_key_attributes_t),
			"::",
			stringify!(private_policy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_flags) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_core_key_attributes_t),
			"::",
			stringify!(private_flags)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_key_attributes_s {
	pub private_core: psa_core_key_attributes_t,
	pub private_domain_parameters: *mut ::std::os::raw::c_void,
	pub private_domain_parameters_size: usize,
}
#[test]
fn bindgen_test_layout_psa_key_attributes_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_key_attributes_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_key_attributes_s>(),
		48usize,
		concat!("Size of: ", stringify!(psa_key_attributes_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_key_attributes_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_key_attributes_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_core) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_attributes_s),
			"::",
			stringify!(private_core)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_domain_parameters) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_attributes_s),
			"::",
			stringify!(private_domain_parameters)
		)
	);
	assert_eq!(
		unsafe {
			::std::ptr::addr_of!((*ptr).private_domain_parameters_size) as usize - ptr as usize
		},
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_key_attributes_s),
			"::",
			stringify!(private_domain_parameters_size)
		)
	);
}
extern "C" {
	#[doc = " \\brief Set domain parameters for a key.\n\n Some key types require additional domain parameters in addition to\n the key type identifier and the key size. Use this function instead\n of psa_set_key_type() when you need to specify domain parameters.\n\n The format for the required domain parameters varies based on the key type.\n\n - For RSA keys (#PSA_KEY_TYPE_RSA_PUBLIC_KEY or #PSA_KEY_TYPE_RSA_KEY_PAIR),\n   the domain parameter data consists of the public exponent,\n   represented as a big-endian integer with no leading zeros.\n   This information is used when generating an RSA key pair.\n   When importing a key, the public exponent is read from the imported\n   key data and the exponent recorded in the attribute structure is ignored.\n   As an exception, the public exponent 65537 is represented by an empty\n   byte string.\n - For DSA keys (#PSA_KEY_TYPE_DSA_PUBLIC_KEY or #PSA_KEY_TYPE_DSA_KEY_PAIR),\n   the `Dss-Params` format as defined by RFC 3279 &sect;2.3.2.\n   ```\n   Dss-Params ::= SEQUENCE  {\n      p       INTEGER,\n      q       INTEGER,\n      g       INTEGER\n   }\n   ```\n - For Diffie-Hellman key exchange keys\n   (#PSA_KEY_TYPE_DH_PUBLIC_KEY(#PSA_DH_FAMILY_CUSTOM) or\n   #PSA_KEY_TYPE_DH_KEY_PAIR(#PSA_DH_FAMILY_CUSTOM)), the\n   `DomainParameters` format as defined by RFC 3279 &sect;2.3.3.\n   ```\n   DomainParameters ::= SEQUENCE {\n      p               INTEGER,                    -- odd prime, p=jq +1\n      g               INTEGER,                    -- generator, g\n      q               INTEGER,                    -- factor of p-1\n      j               INTEGER OPTIONAL,           -- subgroup factor\n      validationParams ValidationParams OPTIONAL\n   }\n   ValidationParams ::= SEQUENCE {\n      seed            BIT STRING,\n      pgenCounter     INTEGER\n   }\n   ```\n\n \\note This function may allocate memory or other resources.\n       Once you have called this function on an attribute structure,\n       you must call psa_reset_key_attributes() to free these resources.\n\n \\note This is an experimental extension to the interface. It may change\n       in future versions of the library.\n\n \\param[in,out] attributes    Attribute structure where the specified domain\n                              parameters will be stored.\n                              If this function fails, the content of\n                              \\p attributes is not modified.\n \\param type                  Key type (a \\c PSA_KEY_TYPE_XXX value).\n \\param[in] data              Buffer containing the key domain parameters.\n                              The content of this buffer is interpreted\n                              according to \\p type as described above.\n \\param data_length           Size of the \\p data buffer in bytes.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_INVALID_ARGUMENT \\emptydescription\n \\retval #PSA_ERROR_NOT_SUPPORTED \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription"]
	pub fn psa_set_key_domain_parameters(
		attributes: *mut psa_key_attributes_t,
		type_: psa_key_type_t,
		data: *const u8,
		data_length: usize,
	) -> psa_status_t;
}
#[doc = " \\brief The context for PSA interruptible hash signing."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_sign_hash_interruptible_operation_s {
	pub private_id: ::std::os::raw::c_uint,
	pub private_ctx: psa_driver_sign_hash_interruptible_context_t,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_num_ops: u32,
}
#[test]
fn bindgen_test_layout_psa_sign_hash_interruptible_operation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_sign_hash_interruptible_operation_s> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_sign_hash_interruptible_operation_s>(),
		16usize,
		concat!(
			"Size of: ",
			stringify!(psa_sign_hash_interruptible_operation_s)
		)
	);
	assert_eq!(
		::std::mem::align_of::<psa_sign_hash_interruptible_operation_s>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(psa_sign_hash_interruptible_operation_s)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_sign_hash_interruptible_operation_s),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_sign_hash_interruptible_operation_s),
			"::",
			stringify!(private_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_num_ops) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_sign_hash_interruptible_operation_s),
			"::",
			stringify!(private_num_ops)
		)
	);
}
impl psa_sign_hash_interruptible_operation_s {
	#[inline]
	pub fn private_error_occurred(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_error_occurred(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_error_occurred: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			let private_error_occurred: u32 =
				unsafe { ::std::mem::transmute(private_error_occurred) };
			private_error_occurred as u64
		});
		__bindgen_bitfield_unit
	}
}
#[doc = " \\brief The context for PSA interruptible hash verification."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_verify_hash_interruptible_operation_s {
	pub private_id: ::std::os::raw::c_uint,
	pub private_ctx: psa_driver_verify_hash_interruptible_context_t,
	pub _bitfield_align_1: [u8; 0],
	pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
	pub private_num_ops: u32,
}
#[test]
fn bindgen_test_layout_psa_verify_hash_interruptible_operation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_verify_hash_interruptible_operation_s> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_verify_hash_interruptible_operation_s>(),
		16usize,
		concat!(
			"Size of: ",
			stringify!(psa_verify_hash_interruptible_operation_s)
		)
	);
	assert_eq!(
		::std::mem::align_of::<psa_verify_hash_interruptible_operation_s>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(psa_verify_hash_interruptible_operation_s)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_verify_hash_interruptible_operation_s),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_verify_hash_interruptible_operation_s),
			"::",
			stringify!(private_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_num_ops) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_verify_hash_interruptible_operation_s),
			"::",
			stringify!(private_num_ops)
		)
	);
}
impl psa_verify_hash_interruptible_operation_s {
	#[inline]
	pub fn private_error_occurred(&self) -> ::std::os::raw::c_uint {
		unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
	}
	#[inline]
	pub fn set_private_error_occurred(&mut self, val: ::std::os::raw::c_uint) {
		unsafe {
			let val: u32 = ::std::mem::transmute(val);
			self._bitfield_1.set(0usize, 1u8, val as u64)
		}
	}
	#[inline]
	pub fn new_bitfield_1(
		private_error_occurred: ::std::os::raw::c_uint,
	) -> __BindgenBitfieldUnit<[u8; 1usize]> {
		let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
		__bindgen_bitfield_unit.set(0usize, 1u8, {
			let private_error_occurred: u32 =
				unsafe { ::std::mem::transmute(private_error_occurred) };
			private_error_occurred as u64
		});
		__bindgen_bitfield_unit
	}
}
pub type psa_key_handle_t = mbedtls_svc_key_id_t;
extern "C" {
	#[doc = " Open a handle to an existing persistent key.\n\n Open a handle to a persistent key. A key is persistent if it was created\n with a lifetime other than #PSA_KEY_LIFETIME_VOLATILE. A persistent key\n always has a nonzero key identifier, set with psa_set_key_id() when\n creating the key. Implementations may provide additional pre-provisioned\n keys that can be opened with psa_open_key(). Such keys have an application\n key identifier in the vendor range, as documented in the description of\n #psa_key_id_t.\n\n The application must eventually close the handle with psa_close_key() or\n psa_destroy_key() to release associated resources. If the application dies\n without calling one of these functions, the implementation should perform\n the equivalent of a call to psa_close_key().\n\n Some implementations permit an application to open the same key multiple\n times. If this is successful, each call to psa_open_key() will return a\n different key handle.\n\n \\note This API is not part of the PSA Cryptography API Release 1.0.0\n specification. It was defined in the 1.0 Beta 3 version of the\n specification but was removed in the 1.0.0 released version. This API is\n kept for the time being to not break applications relying on it. It is not\n deprecated yet but will be in the near future.\n\n \\note Applications that rely on opening a key multiple times will not be\n portable to implementations that only permit a single key handle to be\n opened. See also :ref:\\`key-handles\\`.\n\n\n \\param key           The persistent identifier of the key.\n \\param[out] handle   On success, a handle to the key.\n\n \\retval #PSA_SUCCESS\n         Success. The application can now use the value of `*handle`\n         to access the key.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY\n         The implementation does not have sufficient resources to open the\n         key. This can be due to reaching an implementation limit on the\n         number of open keys, the number of open key handles, or available\n         memory.\n \\retval #PSA_ERROR_DOES_NOT_EXIST\n         There is no persistent key with key identifier \\p key.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p key is not a valid persistent key identifier.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The specified key exists, but the application does not have the\n         permission to access it. Note that this specification does not\n         define any way to create such a key, but it may be possible\n         through implementation-specific means.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_open_key(key: mbedtls_svc_key_id_t, handle: *mut psa_key_handle_t) -> psa_status_t;
}
extern "C" {
	#[doc = " Close a key handle.\n\n If the handle designates a volatile key, this will destroy the key material\n and free all associated resources, just like psa_destroy_key().\n\n If this is the last open handle to a persistent key, then closing the handle\n will free all resources associated with the key in volatile memory. The key\n data in persistent storage is not affected and can be opened again later\n with a call to psa_open_key().\n\n Closing the key handle makes the handle invalid, and the key handle\n must not be used again by the application.\n\n \\note This API is not part of the PSA Cryptography API Release 1.0.0\n specification. It was defined in the 1.0 Beta 3 version of the\n specification but was removed in the 1.0.0 released version. This API is\n kept for the time being to not break applications relying on it. It is not\n deprecated yet but will be in the near future.\n\n \\note If the key handle was used to set up an active\n :ref:\\`multipart operation <multipart-operations>\\`, then closing the\n key handle can cause the multipart operation to fail. Applications should\n maintain the key handle until after the multipart operation has finished.\n\n \\param handle        The key handle to close.\n                      If this is \\c 0, do nothing and return \\c PSA_SUCCESS.\n\n \\retval #PSA_SUCCESS\n         \\p handle was a valid handle or \\c 0. It is now closed.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p handle is not a valid handle nor \\c 0.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_close_key(handle: psa_key_handle_t) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Library deinitialization.\n\n This function clears all data associated with the PSA layer,\n including the whole key store.\n\n This is an Mbed TLS extension."]
	pub fn mbedtls_psa_crypto_free();
}
#[doc = " \\brief Statistics about\n resource consumption related to the PSA keystore.\n\n \\note The content of this structure is not part of the stable API and ABI\n       of Mbed TLS and may change arbitrarily from version to version."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mbedtls_psa_stats_s {
	pub private_volatile_slots: usize,
	pub private_persistent_slots: usize,
	pub private_external_slots: usize,
	pub private_half_filled_slots: usize,
	pub private_cache_slots: usize,
	pub private_empty_slots: usize,
	pub private_locked_slots: usize,
	pub private_max_open_internal_key_id: psa_key_id_t,
	pub private_max_open_external_key_id: psa_key_id_t,
}
#[test]
fn bindgen_test_layout_mbedtls_psa_stats_s() {
	const UNINIT: ::std::mem::MaybeUninit<mbedtls_psa_stats_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<mbedtls_psa_stats_s>(),
		64usize,
		concat!("Size of: ", stringify!(mbedtls_psa_stats_s))
	);
	assert_eq!(
		::std::mem::align_of::<mbedtls_psa_stats_s>(),
		8usize,
		concat!("Alignment of ", stringify!(mbedtls_psa_stats_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_volatile_slots) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_volatile_slots)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_persistent_slots) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_persistent_slots)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_external_slots) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_external_slots)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_half_filled_slots) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_half_filled_slots)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cache_slots) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_cache_slots)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_empty_slots) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_empty_slots)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_locked_slots) as usize - ptr as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_locked_slots)
		)
	);
	assert_eq!(
		unsafe {
			::std::ptr::addr_of!((*ptr).private_max_open_internal_key_id) as usize - ptr as usize
		},
		56usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_max_open_internal_key_id)
		)
	);
	assert_eq!(
		unsafe {
			::std::ptr::addr_of!((*ptr).private_max_open_external_key_id) as usize - ptr as usize
		},
		60usize,
		concat!(
			"Offset of field: ",
			stringify!(mbedtls_psa_stats_s),
			"::",
			stringify!(private_max_open_external_key_id)
		)
	);
}
#[doc = " \\brief Statistics about\n resource consumption related to the PSA keystore.\n\n \\note The content of this structure is not part of the stable API and ABI\n       of Mbed TLS and may change arbitrarily from version to version."]
pub type mbedtls_psa_stats_t = mbedtls_psa_stats_s;
extern "C" {
	#[doc = " \\brief Get statistics about\n resource consumption related to the PSA keystore.\n\n \\note When Mbed TLS is built as part of a service, with isolation\n       between the application and the keystore, the service may or\n       may not expose this function."]
	pub fn mbedtls_psa_get_stats(stats: *mut mbedtls_psa_stats_t);
}
extern "C" {
	#[doc = " \\brief Inject an initial entropy seed for the random generator into\n        secure storage.\n\n This function injects data to be used as a seed for the random generator\n used by the PSA Crypto implementation. On devices that lack a trusted\n entropy source (preferably a hardware random number generator),\n the Mbed PSA Crypto implementation uses this value to seed its\n random generator.\n\n On devices without a trusted entropy source, this function must be\n called exactly once in the lifetime of the device. On devices with\n a trusted entropy source, calling this function is optional.\n In all cases, this function may only be called before calling any\n other function in the PSA Crypto API, including psa_crypto_init().\n\n When this function returns successfully, it populates a file in\n persistent storage. Once the file has been created, this function\n can no longer succeed.\n\n If any error occurs, this function does not change the system state.\n You can call this function again after correcting the reason for the\n error if possible.\n\n \\warning This function **can** fail! Callers MUST check the return status.\n\n \\warning If you use this function, you should use it as part of a\n          factory provisioning process. The value of the injected seed\n          is critical to the security of the device. It must be\n          *secret*, *unpredictable* and (statistically) *unique per device*.\n          You should be generate it randomly using a cryptographically\n          secure random generator seeded from trusted entropy sources.\n          You should transmit it securely to the device and ensure\n          that its value is not leaked or stored anywhere beyond the\n          needs of transmitting it from the point of generation to\n          the call of this function, and erase all copies of the value\n          once this function returns.\n\n This is an Mbed TLS extension.\n\n \\note This function is only available on the following platforms:\n * If the compile-time option MBEDTLS_PSA_INJECT_ENTROPY is enabled.\n   Note that you must provide compatible implementations of\n   mbedtls_nv_seed_read and mbedtls_nv_seed_write.\n * In a client-server integration of PSA Cryptography, on the client side,\n   if the server supports this feature.\n \\param[in] seed          Buffer containing the seed value to inject.\n \\param[in] seed_size     Size of the \\p seed buffer.\n                          The size of the seed in bytes must be greater\n                          or equal to both #MBEDTLS_ENTROPY_BLOCK_SIZE\n                          and the value of \\c MBEDTLS_ENTROPY_MIN_PLATFORM\n                          in `library/entropy_poll.h` in the Mbed TLS source\n                          code.\n                          It must be less or equal to\n                          #MBEDTLS_ENTROPY_MAX_SEED_SIZE.\n\n \\retval #PSA_SUCCESS\n         The seed value was injected successfully. The random generator\n         of the PSA Crypto implementation is now ready for use.\n         You may now call psa_crypto_init() and use the PSA Crypto\n         implementation.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p seed_size is out of range.\n \\retval #PSA_ERROR_STORAGE_FAILURE\n         There was a failure reading or writing from storage.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The library has already been initialized. It is no longer\n         possible to call this function."]
	pub fn mbedtls_psa_inject_entropy(seed: *const u8, seed_size: usize) -> psa_status_t;
}
extern "C" {
	#[doc = " \\brief Get domain parameters for a key.\n\n Get the domain parameters for a key with this function, if any. The format\n of the domain parameters written to \\p data is specified in the\n documentation for psa_set_key_domain_parameters().\n\n \\note This is an experimental extension to the interface. It may change\n       in future versions of the library.\n\n \\param[in] attributes        The key attribute structure to query.\n \\param[out] data             On success, the key domain parameters.\n \\param data_size             Size of the \\p data buffer in bytes.\n                              The buffer is guaranteed to be large\n                              enough if its size in bytes is at least\n                              the value given by\n                              PSA_KEY_DOMAIN_PARAMETERS_SIZE().\n \\param[out] data_length      On success, the number of bytes\n                              that make up the key domain parameters data.\n\n \\retval #PSA_SUCCESS \\emptydescription\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL \\emptydescription"]
	pub fn psa_get_key_domain_parameters(
		attributes: *const psa_key_attributes_t,
		data: *mut u8,
		data_size: usize,
		data_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Convert an ECC curve identifier from the Mbed TLS encoding to PSA.\n\n \\note This function is provided solely for the convenience of\n       Mbed TLS and may be removed at any time without notice.\n\n \\param grpid         An Mbed TLS elliptic curve identifier\n                      (`MBEDTLS_ECP_DP_xxx`).\n \\param[out] bits     On success, the bit size of the curve.\n\n \\return              The corresponding PSA elliptic curve identifier\n                      (`PSA_ECC_FAMILY_xxx`).\n \\return              \\c 0 on failure (\\p grpid is not recognized)."]
	pub fn mbedtls_ecc_group_to_psa(
		grpid: mbedtls_ecp_group_id,
		bits: *mut usize,
	) -> psa_ecc_family_t;
}
extern "C" {
	#[doc = " Convert an ECC curve identifier from the PSA encoding to Mbed TLS.\n\n \\note This function is provided solely for the convenience of\n       Mbed TLS and may be removed at any time without notice.\n\n \\param curve         A PSA elliptic curve identifier\n                      (`PSA_ECC_FAMILY_xxx`).\n \\param bits          The bit-length of a private key on \\p curve.\n \\param bits_is_sloppy If true, \\p bits may be the bit-length rounded up\n                      to the nearest multiple of 8. This allows the caller\n                      to infer the exact curve from the length of a key\n                      which is supplied as a byte string.\n\n \\return              The corresponding Mbed TLS elliptic curve identifier\n                      (`MBEDTLS_ECP_DP_xxx`).\n \\return              #MBEDTLS_ECP_DP_NONE if \\c curve is not recognized.\n \\return              #MBEDTLS_ECP_DP_NONE if \\p bits is not\n                      correct for \\p curve."]
	pub fn mbedtls_ecc_group_of_psa(
		curve: psa_ecc_family_t,
		bits: usize,
		bits_is_sloppy: ::std::os::raw::c_int,
	) -> mbedtls_ecp_group_id;
}
#[doc = " A slot number identifying a key in a driver.\n\n Values of this type are used to identify built-in keys."]
pub type psa_drv_slot_number_t = u64;
#[doc = " \\brief Encoding of the application role of PAKE\n\n Encodes the application's role in the algorithm is being executed. For more\n information see the documentation of individual \\c PSA_PAKE_ROLE_XXX\n constants."]
pub type psa_pake_role_t = u8;
#[doc = " Encoding of input and output indicators for PAKE.\n\n Some PAKE algorithms need to exchange more data than just a single key share.\n This type is for encoding additional input and output data for such\n algorithms."]
pub type psa_pake_step_t = u8;
#[doc = " Encoding of the type of the PAKE's primitive.\n\n Values defined by this standard will never be in the range 0x80-0xff.\n Vendors who define additional types must use an encoding in this range.\n\n For more information see the documentation of individual\n \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_primitive_type_t = u8;
#[doc = " \\brief Encoding of the family of the primitive associated with the PAKE.\n\n For more information see the documentation of individual\n \\c PSA_PAKE_PRIMITIVE_TYPE_XXX constants."]
pub type psa_pake_family_t = u8;
#[doc = " \\brief Encoding of the primitive associated with the PAKE.\n\n For more information see the documentation of the #PSA_PAKE_PRIMITIVE macro."]
pub type psa_pake_primitive_t = u32;
#[doc = " The type of the data structure for PAKE cipher suites.\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_pake_cipher_suite_t = psa_pake_cipher_suite_s;
#[doc = " The type of the state data structure for PAKE operations.\n\n Before calling any function on a PAKE operation object, the application\n must initialize it by any of the following means:\n - Set the structure to all-bits-zero, for example:\n   \\code\n   psa_pake_operation_t operation;\n   memset(&operation, 0, sizeof(operation));\n   \\endcode\n - Initialize the structure to logical zero values, for example:\n   \\code\n   psa_pake_operation_t operation = {0};\n   \\endcode\n - Initialize the structure to the initializer #PSA_PAKE_OPERATION_INIT,\n   for example:\n   \\code\n   psa_pake_operation_t operation = PSA_PAKE_OPERATION_INIT;\n   \\endcode\n - Assign the result of the function psa_pake_operation_init()\n   to the structure, for example:\n   \\code\n   psa_pake_operation_t operation;\n   operation = psa_pake_operation_init();\n   \\endcode\n\n This is an implementation-defined \\c struct. Applications should not\n make any assumptions about the content of this structure.\n Implementation details can change in future versions without notice."]
pub type psa_pake_operation_t = psa_pake_operation_s;
#[doc = " The type of input values for PAKE operations."]
pub type psa_crypto_driver_pake_inputs_t = psa_crypto_driver_pake_inputs_s;
#[doc = " The type of computation stage for J-PAKE operations."]
pub type psa_jpake_computation_stage_t = psa_jpake_computation_stage_s;
extern "C" {
	#[doc = " Get the length of the password in bytes from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] password_len     Password length.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Password hasn't been set yet."]
	pub fn psa_crypto_driver_pake_get_password_len(
		inputs: *const psa_crypto_driver_pake_inputs_t,
		password_len: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get the password from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] buffer           Return buffer for password.\n \\param      buffer_size      Size of the return buffer in bytes.\n \\param[out] buffer_length    Actual size of the password in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Password hasn't been set yet."]
	pub fn psa_crypto_driver_pake_get_password(
		inputs: *const psa_crypto_driver_pake_inputs_t,
		buffer: *mut u8,
		buffer_size: usize,
		buffer_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get the length of the user id in bytes from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] user_len         User id length.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         User id hasn't been set yet."]
	pub fn psa_crypto_driver_pake_get_user_len(
		inputs: *const psa_crypto_driver_pake_inputs_t,
		user_len: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get the length of the peer id in bytes from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] peer_len         Peer id length.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Peer id hasn't been set yet."]
	pub fn psa_crypto_driver_pake_get_peer_len(
		inputs: *const psa_crypto_driver_pake_inputs_t,
		peer_len: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get the user id from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] user_id          User id.\n \\param      user_id_size     Size of \\p user_id in bytes.\n \\param[out] user_id_len      Size of the user id in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         User id hasn't been set yet.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p user_id is too small."]
	pub fn psa_crypto_driver_pake_get_user(
		inputs: *const psa_crypto_driver_pake_inputs_t,
		user_id: *mut u8,
		user_id_size: usize,
		user_id_len: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get the peer id from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] peer_id          Peer id.\n \\param      peer_id_size     Size of \\p peer_id in bytes.\n \\param[out] peer_id_length   Size of the peer id in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Peer id hasn't been set yet.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p peer_id is too small."]
	pub fn psa_crypto_driver_pake_get_peer(
		inputs: *const psa_crypto_driver_pake_inputs_t,
		peer_id: *mut u8,
		peer_id_size: usize,
		peer_id_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get the cipher suite from given inputs.\n\n \\param[in]  inputs           Operation inputs.\n \\param[out] cipher_suite     Return buffer for role.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BAD_STATE\n         Cipher_suite hasn't been set yet."]
	pub fn psa_crypto_driver_pake_get_cipher_suite(
		inputs: *const psa_crypto_driver_pake_inputs_t,
		cipher_suite: *mut psa_pake_cipher_suite_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the session information for a password-authenticated key exchange.\n\n The sequence of operations to set up a password-authenticated key exchange\n is as follows:\n -# Allocate an operation object which will be passed to all the functions\n    listed here.\n -# Initialize the operation object with one of the methods described in the\n    documentation for #psa_pake_operation_t, e.g.\n    #PSA_PAKE_OPERATION_INIT.\n -# Call psa_pake_setup() to specify the cipher suite.\n -# Call \\c psa_pake_set_xxx() functions on the operation to complete the\n    setup. The exact sequence of \\c psa_pake_set_xxx() functions that needs\n    to be called depends on the algorithm in use.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n A typical sequence of calls to perform a password-authenticated key\n exchange:\n -# Call psa_pake_output(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to get the\n    key share that needs to be sent to the peer.\n -# Call psa_pake_input(operation, #PSA_PAKE_STEP_KEY_SHARE, ...) to provide\n    the key share that was received from the peer.\n -# Depending on the algorithm additional calls to psa_pake_output() and\n    psa_pake_input() might be necessary.\n -# Call psa_pake_get_implicit_key() for accessing the shared secret.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n If an error occurs at any step after a call to psa_pake_setup(),\n the operation will need to be reset by a call to psa_pake_abort(). The\n application may call psa_pake_abort() at any time after the operation\n has been initialized.\n\n After a successful call to psa_pake_setup(), the application must\n eventually terminate the operation. The following events terminate an\n operation:\n - A call to psa_pake_abort().\n - A successful call to psa_pake_get_implicit_key().\n\n \\param[in,out] operation     The operation object to set up. It must have\n                              been initialized but not set up yet.\n \\param[in] cipher_suite      The cipher suite to use. (A cipher suite fully\n                              characterizes a PAKE algorithm and determines\n                              the algorithm as well.)\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The algorithm in \\p cipher_suite is not a PAKE algorithm, or the\n         PAKE primitive in \\p cipher_suite is not compatible with the\n         PAKE algorithm, or the hash algorithm in \\p cipher_suite is invalid\n         or not compatible with the PAKE algorithm and primitive.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The algorithm in \\p cipher_suite is not a supported PAKE algorithm,\n         or the PAKE primitive in \\p cipher_suite is not supported or not\n         compatible with the PAKE algorithm, or the hash algorithm in\n         \\p cipher_suite is not supported or not compatible with the PAKE\n         algorithm and primitive.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_setup(
		operation: *mut psa_pake_operation_t,
		cipher_suite: *const psa_pake_cipher_suite_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the password for a password-authenticated key exchange from key ID.\n\n Call this function when the password, or a value derived from the password,\n is already present in the key store.\n\n \\param[in,out] operation     The operation object to set the password for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the password hasn't\n                              been set yet (psa_pake_set_password_key()\n                              hasn't been called yet).\n \\param password              Identifier of the key holding the password or a\n                              value derived from the password (eg. by a\n                              memory-hard function).  It must remain valid\n                              until the operation terminates. It must be of\n                              type #PSA_KEY_TYPE_PASSWORD or\n                              #PSA_KEY_TYPE_PASSWORD_HASH. It has to allow\n                              the usage #PSA_KEY_USAGE_DERIVE.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_HANDLE\n         \\p password is not a valid key identifier.\n \\retval #PSA_ERROR_NOT_PERMITTED\n         The key does not have the #PSA_KEY_USAGE_DERIVE flag, or it does not\n         permit the \\p operation's algorithm.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The key type for \\p password is not #PSA_KEY_TYPE_PASSWORD or\n         #PSA_KEY_TYPE_PASSWORD_HASH, or \\p password is not compatible with\n         the \\p operation's cipher suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The key type or key size of \\p password is not supported with the\n         \\p operation's cipher suite.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must have been set up.), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_set_password_key(
		operation: *mut psa_pake_operation_t,
		password: mbedtls_svc_key_id_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the user ID for a password-authenticated key exchange.\n\n Call this function to set the user ID. For PAKE algorithms that associate a\n user identifier with each side of the session you need to call\n psa_pake_set_peer() as well. For PAKE algorithms that associate a single\n user identifier with the session, call psa_pake_set_user() only.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to set the user ID for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the user ID hasn't\n                              been set (psa_pake_set_user() hasn't been\n                              called yet).\n \\param[in] user_id           The user ID to authenticate with.\n \\param user_id_len           Size of the \\p user_id buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p user_id is not valid for the \\p operation's algorithm and cipher\n         suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The value of \\p user_id is not supported by the implementation.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_set_user(
		operation: *mut psa_pake_operation_t,
		user_id: *const u8,
		user_id_len: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the peer ID for a password-authenticated key exchange.\n\n Call this function in addition to psa_pake_set_user() for PAKE algorithms\n that associate a user identifier with each side of the session. For PAKE\n algorithms that associate a single user identifier with the session, call\n psa_pake_set_user() only.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to set the peer ID for. It\n                              must have been set up by psa_pake_setup() and\n                              not yet in use (neither psa_pake_output() nor\n                              psa_pake_input() has been called yet). It must\n                              be on operation for which the peer ID hasn't\n                              been set (psa_pake_set_peer() hasn't been\n                              called yet).\n \\param[in] peer_id           The peer's ID to authenticate.\n \\param peer_id_len           Size of the \\p peer_id buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p peer_id is not valid for the \\p operation's algorithm and cipher\n         suite.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The algorithm doesn't associate a second identity with the session.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         Calling psa_pake_set_peer() is invalid with the \\p operation's\n         algorithm, the operation state is not valid, or the library has not\n         been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_set_peer(
		operation: *mut psa_pake_operation_t,
		peer_id: *const u8,
		peer_id_len: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Set the application role for a password-authenticated key exchange.\n\n Not all PAKE algorithms need to differentiate the communicating entities.\n It is optional to call this function for PAKEs that don't require a role\n to be specified. For such PAKEs the application role parameter is ignored,\n or #PSA_PAKE_ROLE_NONE can be passed as \\c role.\n\n Refer to the documentation of individual PAKE algorithm types (`PSA_ALG_XXX`\n values of type ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true)\n for more information.\n\n \\param[in,out] operation     The operation object to specify the\n                              application's role for. It must have been set up\n                              by psa_pake_setup() and not yet in use (neither\n                              psa_pake_output() nor psa_pake_input() has been\n                              called yet). It must be on operation for which\n                              the application's role hasn't been specified\n                              (psa_pake_set_role() hasn't been called yet).\n \\param role                  A value of type ::psa_pake_role_t indicating the\n                              application's role in the PAKE the algorithm\n                              that is being set up. For more information see\n                              the documentation of \\c PSA_PAKE_ROLE_XXX\n                              constants.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         The \\p role is not a valid PAKE role in the \\p operations algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         The \\p role for this algorithm is not supported or is not valid.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid, or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_set_role(
		operation: *mut psa_pake_operation_t,
		role: psa_pake_role_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get output for a step of a password-authenticated key exchange.\n\n Depending on the algorithm being executed, you might need to call this\n function several times or you might not need to call this at all.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_pake_abort().\n\n \\param[in,out] operation    Active PAKE operation.\n \\param step                 The step of the algorithm for which the output is\n                             requested.\n \\param[out] output          Buffer where the output is to be written in the\n                             format appropriate for this \\p step. Refer to\n                             the documentation of the individual\n                             \\c PSA_PAKE_STEP_XXX constants for more\n                             information.\n \\param output_size          Size of the \\p output buffer in bytes. This must\n                             be at least #PSA_PAKE_OUTPUT_SIZE(\\c alg, \\c\n                             primitive, \\p output_step) where \\c alg and\n                             \\p primitive are the PAKE algorithm and primitive\n                             in the operation's cipher suite, and \\p step is\n                             the output step.\n\n \\param[out] output_length   On success, the number of bytes of the returned\n                             output.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_BUFFER_TOO_SMALL\n         The size of the \\p output buffer is too small.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p step is not compatible with the operation's algorithm.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p step is not supported with the operation's algorithm.\n \\retval #PSA_ERROR_INSUFFICIENT_ENTROPY \\emptydescription\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and fully set\n         up, and this call must conform to the algorithm's requirements\n         for ordering of input and output steps), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_output(
		operation: *mut psa_pake_operation_t,
		step: psa_pake_step_t,
		output: *mut u8,
		output_size: usize,
		output_length: *mut usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Provide input for a step of a password-authenticated key exchange.\n\n Depending on the algorithm being executed, you might need to call this\n function several times or you might not need to call this at all.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n If this function returns an error status, the operation enters an error\n state and must be aborted by calling psa_pake_abort().\n\n \\param[in,out] operation    Active PAKE operation.\n \\param step                 The step for which the input is provided.\n \\param[in] input            Buffer containing the input in the format\n                             appropriate for this \\p step. Refer to the\n                             documentation of the individual\n                             \\c PSA_PAKE_STEP_XXX constants for more\n                             information.\n \\param input_length         Size of the \\p input buffer in bytes.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_SIGNATURE\n         The verification fails for a #PSA_PAKE_STEP_ZK_PROOF input step.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         \\p input_length is not compatible with the \\p operations algorithm,\n         or the \\p input is not valid for the \\p operation's algorithm,\n         cipher suite or \\p step.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         \\p step p is not supported with the \\p operation's algorithm, or the\n         \\p input is not supported for the \\p operation's algorithm, cipher\n         suite or \\p step.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The operation state is not valid (it must be active, and fully set\n         up, and this call must conform to the algorithm's requirements\n         for ordering of input and output steps), or\n         the library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_input(
		operation: *mut psa_pake_operation_t,
		step: psa_pake_step_t,
		input: *const u8,
		input_length: usize,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Get implicitly confirmed shared secret from a PAKE.\n\n At this point there is a cryptographic guarantee that only the authenticated\n party who used the same password is able to compute the key. But there is no\n guarantee that the peer is the party it claims to be and was able to do so.\n\n That is, the authentication is only implicit. Since the peer is not\n authenticated yet, no action should be taken yet that assumes that the peer\n is who it claims to be. For example, do not access restricted files on the\n peer's behalf until an explicit authentication has succeeded.\n\n This function can be called after the key exchange phase of the operation\n has completed. It imports the shared secret output of the PAKE into the\n provided derivation operation. The input step\n #PSA_KEY_DERIVATION_INPUT_SECRET is used when placing the shared key\n material in the key derivation operation.\n\n The exact sequence of calls to perform a password-authenticated key\n exchange depends on the algorithm in use.  Refer to the documentation of\n individual PAKE algorithm types (`PSA_ALG_XXX` values of type\n ::psa_algorithm_t such that #PSA_ALG_IS_PAKE(\\c alg) is true) for more\n information.\n\n When this function returns successfully, \\p operation becomes inactive.\n If this function returns an error status, both \\p operation\n and \\c key_derivation operations enter an error state and must be aborted by\n calling psa_pake_abort() and psa_key_derivation_abort() respectively.\n\n \\param[in,out] operation    Active PAKE operation.\n \\param[out] output          A key derivation operation that is ready\n                             for an input step of type\n                             #PSA_KEY_DERIVATION_INPUT_SECRET.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_INVALID_ARGUMENT\n         #PSA_KEY_DERIVATION_INPUT_SECRET is not compatible with the\n         algorithm in the \\p output key derivation operation.\n \\retval #PSA_ERROR_NOT_SUPPORTED\n         Input from a PAKE is not supported by the algorithm in the \\p output\n         key derivation operation.\n \\retval #PSA_ERROR_INSUFFICIENT_MEMORY \\emptydescription\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_STORAGE_FAILURE \\emptydescription\n \\retval #PSA_ERROR_DATA_CORRUPT \\emptydescription\n \\retval #PSA_ERROR_DATA_INVALID \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The PAKE operation state is not valid (it must be active, but beyond\n         that validity is specific to the algorithm), or\n         the library has not been previously initialized by psa_crypto_init(),\n         or the state of \\p output is not valid for\n         the #PSA_KEY_DERIVATION_INPUT_SECRET step. This can happen if the\n         step is out of order or the application has done this step already\n         and it may not be repeated.\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_get_implicit_key(
		operation: *mut psa_pake_operation_t,
		output: *mut psa_key_derivation_operation_t,
	) -> psa_status_t;
}
extern "C" {
	#[doc = " Abort a PAKE operation.\n\n Aborting an operation frees all associated resources except for the \\c\n operation structure itself. Once aborted, the operation object can be reused\n for another operation by calling psa_pake_setup() again.\n\n This function may be called at any time after the operation\n object has been initialized as described in #psa_pake_operation_t.\n\n In particular, calling psa_pake_abort() after the operation has been\n terminated by a call to psa_pake_abort() or psa_pake_get_implicit_key()\n is safe and has no effect.\n\n \\param[in,out] operation    The operation to abort.\n\n \\retval #PSA_SUCCESS\n         Success.\n \\retval #PSA_ERROR_COMMUNICATION_FAILURE \\emptydescription\n \\retval #PSA_ERROR_CORRUPTION_DETECTED \\emptydescription\n \\retval #PSA_ERROR_BAD_STATE\n         The library has not been previously initialized by psa_crypto_init().\n         It is implementation-dependent whether a failure to initialize\n         results in this error code."]
	pub fn psa_pake_abort(operation: *mut psa_pake_operation_t) -> psa_status_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_pake_cipher_suite_s {
	pub algorithm: psa_algorithm_t,
	pub type_: psa_pake_primitive_type_t,
	pub family: psa_pake_family_t,
	pub bits: u16,
	pub hash: psa_algorithm_t,
}
#[test]
fn bindgen_test_layout_psa_pake_cipher_suite_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_pake_cipher_suite_s> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_pake_cipher_suite_s>(),
		12usize,
		concat!("Size of: ", stringify!(psa_pake_cipher_suite_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_pake_cipher_suite_s>(),
		4usize,
		concat!("Alignment of ", stringify!(psa_pake_cipher_suite_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_cipher_suite_s),
			"::",
			stringify!(algorithm)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_cipher_suite_s),
			"::",
			stringify!(type_)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
		5usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_cipher_suite_s),
			"::",
			stringify!(family)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).bits) as usize - ptr as usize },
		6usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_cipher_suite_s),
			"::",
			stringify!(bits)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_cipher_suite_s),
			"::",
			stringify!(hash)
		)
	);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_crypto_driver_pake_inputs_s {
	pub private_password: *mut u8,
	pub private_password_len: usize,
	pub private_user: *mut u8,
	pub private_user_len: usize,
	pub private_peer: *mut u8,
	pub private_peer_len: usize,
	pub private_attributes: psa_key_attributes_t,
	pub private_cipher_suite: psa_pake_cipher_suite_t,
}
#[test]
fn bindgen_test_layout_psa_crypto_driver_pake_inputs_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_crypto_driver_pake_inputs_s> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_crypto_driver_pake_inputs_s>(),
		112usize,
		concat!("Size of: ", stringify!(psa_crypto_driver_pake_inputs_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_crypto_driver_pake_inputs_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_crypto_driver_pake_inputs_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_password) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_password)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_password_len) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_password_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_user) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_user)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_user_len) as usize - ptr as usize },
		24usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_user_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_peer) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_peer)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_peer_len) as usize - ptr as usize },
		40usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_peer_len)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_attributes) as usize - ptr as usize },
		48usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_attributes)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_cipher_suite) as usize - ptr as usize },
		96usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_crypto_driver_pake_inputs_s),
			"::",
			stringify!(private_cipher_suite)
		)
	);
}
pub const psa_crypto_driver_pake_step_PSA_JPAKE_STEP_INVALID: psa_crypto_driver_pake_step = 0;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 1;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 2;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X1_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 3;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 4;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 5;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 6;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_KEY_SHARE: psa_crypto_driver_pake_step = 7;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step = 8;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X2S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 9;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_KEY_SHARE: psa_crypto_driver_pake_step =
	10;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PUBLIC: psa_crypto_driver_pake_step =
	11;
pub const psa_crypto_driver_pake_step_PSA_JPAKE_X4S_STEP_ZK_PROOF: psa_crypto_driver_pake_step = 12;
pub type psa_crypto_driver_pake_step = ::std::os::raw::c_uint;
pub use self::psa_crypto_driver_pake_step as psa_crypto_driver_pake_step_t;
pub const psa_jpake_round_PSA_JPAKE_FIRST: psa_jpake_round = 0;
pub const psa_jpake_round_PSA_JPAKE_SECOND: psa_jpake_round = 1;
pub const psa_jpake_round_PSA_JPAKE_FINISHED: psa_jpake_round = 2;
pub type psa_jpake_round = ::std::os::raw::c_uint;
pub use self::psa_jpake_round as psa_jpake_round_t;
pub const psa_jpake_io_mode_PSA_JPAKE_INPUT: psa_jpake_io_mode = 0;
pub const psa_jpake_io_mode_PSA_JPAKE_OUTPUT: psa_jpake_io_mode = 1;
pub type psa_jpake_io_mode = ::std::os::raw::c_uint;
pub use self::psa_jpake_io_mode as psa_jpake_io_mode_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct psa_jpake_computation_stage_s {
	pub private_round: psa_jpake_round_t,
	pub private_io_mode: psa_jpake_io_mode_t,
	pub private_inputs: u8,
	pub private_outputs: u8,
	pub private_step: psa_pake_step_t,
}
#[test]
fn bindgen_test_layout_psa_jpake_computation_stage_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_jpake_computation_stage_s> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_jpake_computation_stage_s>(),
		12usize,
		concat!("Size of: ", stringify!(psa_jpake_computation_stage_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_jpake_computation_stage_s>(),
		4usize,
		concat!("Alignment of ", stringify!(psa_jpake_computation_stage_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_round) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_jpake_computation_stage_s),
			"::",
			stringify!(private_round)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_io_mode) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_jpake_computation_stage_s),
			"::",
			stringify!(private_io_mode)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_inputs) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_jpake_computation_stage_s),
			"::",
			stringify!(private_inputs)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_outputs) as usize - ptr as usize },
		9usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_jpake_computation_stage_s),
			"::",
			stringify!(private_outputs)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_step) as usize - ptr as usize },
		10usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_jpake_computation_stage_s),
			"::",
			stringify!(private_step)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct psa_pake_operation_s {
	pub private_id: ::std::os::raw::c_uint,
	pub private_alg: psa_algorithm_t,
	pub private_primitive: psa_pake_primitive_t,
	pub private_stage: u8,
	pub private_computation_stage: psa_pake_operation_s__bindgen_ty_1,
	pub private_data: psa_pake_operation_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_1 {
	pub private_dummy: u8,
	pub private_jpake: psa_jpake_computation_stage_t,
}
#[test]
fn bindgen_test_layout_psa_pake_operation_s__bindgen_ty_1() {
	const UNINIT: ::std::mem::MaybeUninit<psa_pake_operation_s__bindgen_ty_1> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_pake_operation_s__bindgen_ty_1>(),
		12usize,
		concat!("Size of: ", stringify!(psa_pake_operation_s__bindgen_ty_1))
	);
	assert_eq!(
		::std::mem::align_of::<psa_pake_operation_s__bindgen_ty_1>(),
		4usize,
		concat!(
			"Alignment of ",
			stringify!(psa_pake_operation_s__bindgen_ty_1)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_dummy) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s__bindgen_ty_1),
			"::",
			stringify!(private_dummy)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_jpake) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s__bindgen_ty_1),
			"::",
			stringify!(private_jpake)
		)
	);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union psa_pake_operation_s__bindgen_ty_2 {
	pub private_ctx: psa_driver_pake_context_t,
	pub private_inputs: psa_crypto_driver_pake_inputs_t,
}
#[test]
fn bindgen_test_layout_psa_pake_operation_s__bindgen_ty_2() {
	const UNINIT: ::std::mem::MaybeUninit<psa_pake_operation_s__bindgen_ty_2> =
		::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_pake_operation_s__bindgen_ty_2>(),
		880usize,
		concat!("Size of: ", stringify!(psa_pake_operation_s__bindgen_ty_2))
	);
	assert_eq!(
		::std::mem::align_of::<psa_pake_operation_s__bindgen_ty_2>(),
		8usize,
		concat!(
			"Alignment of ",
			stringify!(psa_pake_operation_s__bindgen_ty_2)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_ctx) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s__bindgen_ty_2),
			"::",
			stringify!(private_ctx)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_inputs) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s__bindgen_ty_2),
			"::",
			stringify!(private_inputs)
		)
	);
}
#[test]
fn bindgen_test_layout_psa_pake_operation_s() {
	const UNINIT: ::std::mem::MaybeUninit<psa_pake_operation_s> = ::std::mem::MaybeUninit::uninit();
	let ptr = UNINIT.as_ptr();
	assert_eq!(
		::std::mem::size_of::<psa_pake_operation_s>(),
		912usize,
		concat!("Size of: ", stringify!(psa_pake_operation_s))
	);
	assert_eq!(
		::std::mem::align_of::<psa_pake_operation_s>(),
		8usize,
		concat!("Alignment of ", stringify!(psa_pake_operation_s))
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_id) as usize - ptr as usize },
		0usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s),
			"::",
			stringify!(private_id)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_alg) as usize - ptr as usize },
		4usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s),
			"::",
			stringify!(private_alg)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_primitive) as usize - ptr as usize },
		8usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s),
			"::",
			stringify!(private_primitive)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_stage) as usize - ptr as usize },
		12usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s),
			"::",
			stringify!(private_stage)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_computation_stage) as usize - ptr as usize },
		16usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s),
			"::",
			stringify!(private_computation_stage)
		)
	);
	assert_eq!(
		unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
		32usize,
		concat!(
			"Offset of field: ",
			stringify!(psa_pake_operation_s),
			"::",
			stringify!(private_data)
		)
	);
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
